{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://marblemm.gitee.io","root":"/"},"pages":[{"title":"关于","date":"2021-08-08T09:14:53.702Z","updated":"2021-08-08T09:14:53.702Z","comments":false,"path":"about/index.html","permalink":"https://marblemm.gitee.io/about/index.html","excerpt":"","text":"c++开发"},{"title":"分类","date":"2021-08-08T09:12:54.798Z","updated":"2021-08-01T10:13:30.755Z","comments":false,"path":"categories/index.html","permalink":"https://marblemm.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-08-08T08:54:09.245Z","updated":"2021-08-08T08:54:09.245Z","comments":true,"path":"links/index.html","permalink":"https://marblemm.gitee.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"com-com入门2","slug":"com-com入门2","date":"2021-11-06T07:42:43.000Z","updated":"2021-11-06T07:43:57.569Z","comments":true,"path":"2021/11/06/com-com入门2/","link":"","permalink":"https://marblemm.gitee.io/2021/11/06/com-com%E5%85%A5%E9%97%A82/","excerpt":"","text":"上一篇文章简单演示了COM组件的编写，注册及调用，本篇实现COM的自注册和反注册 1. 实现COM组件的自注册和反注册实现COM组件的自注册和反注册，本质上就是写注册表与删注册表。需要在DLL中引出两个函数：DllRegisterServer和DllUnregisterServer，让这两个函数实现注册表操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061LPCTSTR RegTable[][3] =&#123; &#123;L&quot;CLSID\\\\&#123;586CDC7B-09F1-4f44-A110-F0E604AED81E&#125;&quot;, 0, L&quot;BeginningCOM&quot;&#125;, &#123;L&quot;CLSID\\\\&#123;586CDC7B-09F1-4f44-A110-F0E604AED81E&#125;\\\\InprocServer32&quot;, 0, (LPCTSTR)-1&#125;, &#123;L&quot;CLSID\\\\&#123;586CDC7B-09F1-4f44-A110-F0E604AED81E&#125;\\\\InprocServer32&quot;, L&quot;ThreadingModel&quot;, L&quot;Both&quot;&#125;&#125;;STDAPI DllUnregisterServer()&#123; HRESULT hr = S_OK; int regCount = sizeof(RegTable) / sizeof(*RegTable); for(int i = regCount - 1; i &gt;= 0; i--) &#123; LSTATUS error = RegDeleteKey(HKEY_CLASSES_ROOT, RegTable[i][0]); if(error != ERROR_SUCCESS) &#123; hr = S_FALSE; &#125; &#125; return hr;&#125;STDAPI DllRegisterServer(void)&#123; HRESULT hr = S_OK; TCHAR szFileName[MAX_PATH]; ZeroMemory(&amp;szFileName, MAX_PATH * sizeof(TCHAR)); GetModuleFileName(g_hModule, szFileName, MAX_PATH); int regCount = sizeof(RegTable) / sizeof(*RegTable); for(int i = 0; i &lt; regCount; i++) &#123; if(RegTable[i][2] == (LPCTSTR)-1) &#123; RegTable[i][2] = szFileName; &#125; HKEY hKey; LSTATUS error = ::RegCreateKey(HKEY_CLASSES_ROOT, RegTable[i][0], &amp;hKey); if(error == ERROR_SUCCESS) &#123; error = RegSetValueEx(hKey, RegTable[i][1], 0, REG_SZ, (const BYTE*)RegTable[i][2], (lstrlen(RegTable[i][2]) + 1) * sizeof(TCHAR)); RegCloseKey(hKey); &#125; if(error != ERROR_SUCCESS) &#123; DllUnregisterServer(); &#125; &#125; return hr;&#125; 现将需要修改的注册表内容放到一个二维数组中，第一维内容分别是注册表键，项，值。-1为占位符，标识该位置放置COM组件的路径，在写注册表之前将其替换。删注册表时，应该先删子键，否则删除会失败。同时需要在BeginningCOM.def中导出这两个函数： 12345LIBRARY &quot;BeginningCOM&quot;EXPORTS DllGetClassObject private DllRegisterServer private DllUnregisterServer private 这样就可以用regsvr32.exe注册和反注册COM组件。","categories":[{"name":"com","slug":"com","permalink":"https://marblemm.gitee.io/categories/com/"}],"tags":[]},{"title":"com-com入门1","slug":"com-com入门1","date":"2021-11-05T15:57:06.000Z","updated":"2021-11-14T16:19:21.887Z","comments":true,"path":"2021/11/05/com-com入门1/","link":"","permalink":"https://marblemm.gitee.io/2021/11/05/com-com%E5%85%A5%E9%97%A81/","excerpt":"","text":"上篇已经梳理了com的由来，总结如下：COM的思想其实是从OO开始，一点点增加出来的。 （1）既然所有的程序说到底都是一段段二进制执行码，那么COM的标准直接针对二进制码也就理所当然了。这样带来的好处显而易见，就是语言的无关性。 （2）OO中的类和对象思想已经提供了一种高内聚低耦合的实现，因此COM也顺理成章的借鉴了这一切。COM中重用的单位是COM对象，其二进制代码需要满足一定的标准。而这个标准来自于Windows平台下，经VC（GCC一样，其实）编译的，用C++写出来的类在实例化成对象后得到的二进制代码。所以为什么COM对象的开头都是一列指针，每个指针指向一列函数呢？因为C++就是这样实现虚函数和多重继承的。 （3）从COM对象逆推回去，就有了COM类的概念。因为开发者不一定用OO语言来实现COM对象，所以COM类不一定能和OO中的类扯上关系，它们的类似之处只在于抽象提取了COM对象的功能。当然，如果用C++来开发，则C++中的类和对象就都可以平移推到COM上了。 （4）C++中一个类可以有多个实例对象，COM也一样。C++通过名字来标识类，利用操作符new和构造函数来获取内存空间和初始化内存内容，得到实例化的对象。COM类用一个全局唯一的ID（GUID）来标识，称为CLSID，COM利用类厂（ClassFactory）来得到实例化的COM对象。 （5）系统用公共空间保存所有可被重用的COM类的CLSID和其具体位置的对应（在Windows下是保存在注册表中），这样所有的用户只要知道CLSID，都能顺利找到COM类。然后COM类可以利用类厂生成COM对象。COM类和类厂的实现代码可以在DLL中，也可以在EXE中，可以在本地，也可以在网络的另一端。 （6）不管如何，使用COM对象的最终目的还是为了用里面的函数。COM对象要实现多个接口（Interface），每个接口都包含一组函数，也用一个GUID来标识，称为IID。接口的二进制代码很简单，就是一个函数指针数组，因此只要知道接口指针就能顺利调用接口的每一个函数。COM统一了一个标准的接口，每个COM类都必须有的。其中一个函数QueryInterface()就可以根据IID来得到接口指针。 1. 什么是COMCOM–Component Object Model，即组件对象模型，它是微软提出的一套开发软件的方法与规范。它也代表了一种软件开发思想，那就是面向组件编程的思想。 COM组件在物理上是一些DLL或EXE文件； COM组件实现二进制级别的代码重用； COM是与程序设计语言无关，理论上任何语言都可以开发和调用COM组件； COM组件用引用计数实现生命周期的自我管理； COM组件调用者能够查询它所支持的接口； COM组件的位置对调用者是透明的； COM组件依赖于注册表； COM组件都要直接或间接的实现IUnknown接口…… com对象与C++对象的比较封装性 com对象的数据是完全封装在对象内部的，外部不可能直接访问对象的数据属性，因为com对象和客户程序可能在不同的模块中甚至在不同的进程中或不同机器上，com对象的数据成员的封装以组件模块为最终边界，对于对象用户是完全透明的、不可见的； c++对象的封装性只是语义上的封装，通过对类的成员访问进行控制，使用者有可能直接访问对象中的数据成员， 可重用性 可重用性事面向对象的重要特性，com对象的可重用性表现在com对象的包容和聚合，一个对象可以完全使用另一个对象的所有功能；而c++对象的可重用性表现在C++类的继承性，派生类可以调用其父类的非私有成员函数。com对象A如果要使用另一个com对象B的功能，则可以通过包容和聚合来实现，而且当对象B更新了版本或者增强了功能时，对象A自动使用新版本的对象B，而根本不需要重新编译或者重新设置，因此com对象的重用是动态的； c++对象的重用性表现在源代码一级的重用性上，当类A的实现做了修改时，则类B必须重新编译或者需要修改相应的代码，才能适应新的类A。 com对象的标识–CLSIDcom组件的位置对客户来说是透明的，因为客户并不直接去访问com组件，客户程序通过一个全局标识符进行对象的创建和初始化工作，com规范采用128位全局唯一标识符GUID来标识组件对象，这是个随机数，并不需要专门机构进行分配和管理，手工构造128位guid或者编写程序来产生guid是件很麻烦的事，为此Microsoft VisualC++提供了两个工具实现这样的目的：UUIDGen.exe和GUIDGen.exe，前者是一个命令行程序，后者是一个基于对话框的应用程序。com库为我们提供了以下API函数可以产生GUID:HRESULT CoCreateGuid(GUID *pguid);CLSID是用来标识com对象的GUID，因此CLSID在结构定义上与GUID一致 2. IUnknown接口所有COM组件都直接或间接实现IUnknown接口，IUnknown接口是COM的根接口，其声明为： 123456interface IUnknown&#123; virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, VOID** ppv) = 0; virtual ULONG STDMETHODCALLTYPE AddRef(VOID) = 0; virtual ULONG STDMETHODCALLTYPE Release(void)= 0;&#125;; 标准C++中没有interface关键字，这里的interface是typedef struct interface。 1STDMETHODCALLTYPE等价于__stdcall COM规定，调用函数的方式必须为__stdcall，这是pascal语言缺省的调用函数的方式：函数的参数从右到左依次压栈，函数退出时自己清空占用的堆栈，大多数的系统API也都使用这种调用习惯；与之相对的为__cdecl，这是C/C++语言缺省的调用函数的方式：函数的参数从右到左依次压栈，函数退出时，由调用者清空函数占用的堆栈，主要是可以实现可变参数的特性（例如printf函数） QueryInterface函数，客户通过该函数查询COM实现的接口；riid是接口的标识，为GUID形式；返回值标识查询的接口是否实现，如果实现了，则返回S_OK，并且ppv指向接口的实例，否则返回E_NOINTERFACE，ppv指向的内容无效。QueryInterface函数隔离了不同编程语言构造对象实例的差异。 AddRef和Release函数实现了COM对象生命周期的自我管理。实现该接口的类需要有一个ULONG型成员记录其实例的引用计数，如果AddRef一次，引用计数加1，否则引用计数减1，如果引用计数为0时，就释放该实例。这两个函数隔离了不同变成语言释放对象实例的差异。 3. 实现一个最最简单的COM组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//BeginningCOM.h#ifndef __BEGINNINGCOM_H__#define __BEGINNINGCOM_H__#pragma once#include &lt;windows.h&gt;// &#123;7BB69A25-68E4-427a-BE4B-B06ED17531AA&#125;CLSID CLSID_BeginningCOM =&#123; 0x7bb69a25, 0x68e4, 0x427a, &#123; 0xbe, 0x4b, 0xb0, 0x6e, 0xd1, 0x75, 0x31, 0xaa &#125; &#125;;#endif //__BEGINNINGCOM_H__//BeginningCOM.cpp#include &quot;BeginningCOM.h&quot;class BeginningCOM : public IUnknown&#123;public: BeginningCOM(VOID); STDMETHODIMP QueryInterface(REFIID riid, VOID** ppv); STDMETHODIMP_(ULONG) AddRef(VOID); STDMETHODIMP_(ULONG) Release(VOID);protected: ULONG m_ulRefCount;&#125;;BeginningCOM::BeginningCOM(VOID) : m_ulRefCount(0)&#123;&#125;STDMETHODIMP BeginningCOM::QueryInterface(REFIID riid, VOID** ppv)&#123; if(riid == IID_IUnknown) &#123; *ppv = static_cast&lt;IUnknown*&gt;(this); &#125; else &#123; *ppv = NULL; return E_NOINTERFACE; &#125; reinterpret_cast&lt;IUnknown*&gt;(*ppv) -&gt; AddRef(); return S_OK;&#125;STDMETHODIMP_(ULONG) BeginningCOM::AddRef(VOID)&#123; return InterlockedIncrement(&amp;m_ulRefCount);&#125;STDMETHODIMP_(ULONG) BeginningCOM::Release(VOID)&#123; ULONG tmp = InterlockedDecrement(&amp;m_ulRefCount); if(tmp == 0) &#123; delete this; &#125; return tmp;&#125;// DLL entry point.BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)&#123; if(rclsid == CLSID_BeginningCOM) &#123; BeginningCOM *pbc = new BeginningCOM; if(pbc == NULL) &#123; return E_OUTOFMEMORY; &#125; return pbc -&gt; QueryInterface(riid, ppv); &#125; *ppv = 0; return CLASS_E_CLASSNOTAVAILABLE;&#125; BeginningCOM.h中，先定义一个GUID作为实现接口的class的ID。BeginningCOM.cpp中实现IUnknown接口。DllGetClassObject是客户调用COM组件的入口，需要导出这个函数： 1234//BeginningCOM.defLIBRARY &quot;BeginningCOM&quot;EXPORTS DllGetClassObject private 4. 注册COM组件在HKEY_CLASSES_ROOT\\CLSID键下注册COM组件的class信息。创建一个reg文件，导入注册表即可。 123456789//regsvr.regWindows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\CLSID\\&#123;7BB69A25-68E4-427a-BE4B-B06ED17531AA&#125;]@=&quot;BeginningCOM&quot;[HKEY_CLASSES_ROOT\\CLSID\\&#123;7BB69A25-68E4-427a-BE4B-B06ED17531AA&#125;\\InprocServer32]@=&quot;E:\\\\Projects\\\\BeginningCOM\\\\Debug\\\\BeginningCOM.dll&quot;&quot;ThreadingModel&quot;=&quot;Both&quot; @=”BeginningCOM”是class的描述信息，可忽略。“ThreadingModel”=”Both”是COM组件的套件类型，后面介绍。 相应的卸载COM组件的reg文件内容应该为： 12345//unregsvr.regWindows Registry Editor Version 5.00[-HKEY_CLASSES_ROOT\\CLSID\\&#123;7BB69A25-68E4-427a-BE4B-B06ED17531AA&#125;]@=&quot;BeginningCOM&quot; 需要注意的是，在Win64中，如果COM组件编译选择的是X86，那么注册表会进行重定向，读取位置变为HKEY_CLASSES_ROOT\\Wow6432Node\\CLSID，因此，注册时，键值应该写在这个路径下。 5. 调用COM组件要调用COM组件，必须向客户公布接口ID，class ID等，我们这里把需要公布的信息放到BeginningCOM.h中。下面的代码用于调用刚创建的COM组件。 1234567891011121314151617181920212223242526272829#include &lt;Windows.h&gt;#include &lt;tchar.h&gt;#include &lt;iostream&gt;#include &quot;../BeginningCOM/BeginningCOM.h&quot;using namespace std;int _tmain(int argc, _TCHAR* argv[])&#123; CoInitialize(NULL); HRESULT hr = NULL; IUnknown *puk; hr = CoGetClassObject(CLSID_BeginningCOM, CLSCTX_INPROC_SERVER, NULL, IID_IUnknown, (void**)&amp;puk); if(SUCCEEDED(hr)) &#123; //do nothing puk -&gt; Release(); &#125; else &#123; cout &lt;&lt; &quot;Failed to create object&quot;&lt;&lt;endl; &#125; CoUninitialize(); return 0;&#125; 在使用COM组件前，需要初始化COM调用环境，CoInitialize初始化单线程套间，只有一个保留的参数，CoInitializeEx除了一个保留的参数，还可以指定初始化的套件类型。 进程内组件和进程外组件com的实现与操作系统平台密切相关，因为com最初源于Microsoft Windows平台，所以com的实现部分很多地方直接用到了windows系统的一些特性，比如系统注册表、动态链接库等，但实际上，com是一个与平台无关的组件软件模型 不管COM对象有多少花哨的东西，其本质只是一段内存，有数据有代码而已。因此当一个COM对象被使用的时候，是谁，并且怎样把这些数据和代码载入内存呢？首先，最简单的就是调用者和COM对象在一起，这时候函数调用就是普通的调用，没有任何使用上的障碍。然而这样一来显然无法把COM对象独立出来，自然无法做到重用。因此COM对象首先应该孤立于任何调用者，单独被保存在系统中。这时候作为可执行程序，它可以是DLL，也可以是EXE。COM对象作为DLL被使用时，调用者会先用LoadLibrary()把DLL整个装入自己的进程空间，然后获取里面类厂的地址，再通过调用类厂的接口函数来生成COM对象。此时COM对象是在用户进程空间内生成的，对用户而言能够更加方便快速的使用COM对象提供的功能。另外一种方式是COM对象作为EXE被使用。此时调用者会先给当前进程创立一个子进程来运行该EXE，然后通过进程之间的通信来依次调用类厂的接口函数，COM对象的接口函数，等等。 这两者区别仅仅在于调用者和COM对象是否存在于同一个进程空间而已。 进程内组件进程内组件和客户程序运行在同一个进程地址空间中，所以一旦客户程序与组件程序建立起通信关系之后，客户程序得到的接口指针直接指向组件程序中接口的虚表，客户代码可以直接调用这些成员函数，所以其效率非常高 进程外组件我们也可以让组件程序独占一个进程，而不使用客户程序的进程空间，因为它运行在客户进程的外面，所以我们把这种组件程序称为进程外组件程序，有时也称为进程外服务程序因为进程外组件程序和客户程序位于不同的进程空间之中，它们使用不同的地址空间，所以组件和客户之间的通信必须跨越进程边界，这就涉及到以下一些问题： 1、一个进程如何调用另一个进程中的函数 2、参数如何从一个进程被传递到另一个进程中 Windows平台上，在不同进程之间进行通信的办法很多，包括动态数据交换（DDE）, 命名管道（named pipe）,或者共享内存等等，COM采用了本地过程调用LPC(Local Procedure Call)和远程过程调用RPC(Remote Procedure Call)来进行进程之间的通信。 运行在同一个操作系统上的进程之间进行通信是经常发生的事情，系统本身有许多服务是跨越进程实现的，应用程序在调用系统服务时也可能要跨越进程，所以跨进程通信是操作系统实现的重要部分，而且，在系统底层实现跨进程操作更为便利，因为在系统级，它可以控制应用进程的资源分配，包括逻辑内存空间到物理内存的映射、CPU时间的调度等，从控制能力来讲，操作系统可以调用任何一个进程中的函数。 首先我们来分析一下应用程序调用其他进程中系统服务的过程。比如，应用程序A通过系统API函数调用系统提供的服务f，因为系统服务（是在另一个进程中实现的，所以这个调用过程不是直接进行的，调用过程中要涉及到跨进程操作，实际上也就是要用到LPC 从图1可以看出，应用A实际上调用的是系统模块DLL，在这里我们把该DLL称为存根（stub）模块，因为它是动态连接库模块，所以这个调用是直接进行的。在存根DL中，它把应用的请求再通过IPC的方式调用到了进程B中的服务f，当f完成服务之后，它也通过LPC把结果信息返回到存根DLL中，最后由存根DLL，把结果返回给A 因为LPC是在存根模块DLL和服务「之间进行的，所以对于应用A来说，它并不需要进行LPC调用操作，它只需像一般的函数调用一样去调用系统提供的API函数即可。而操作系统当然知道该如何处理这样的系统调用，它不仅可以正确完成跨进程的调用，而且也会把参数和返回结果在进程之间传递。 客户程序和进程外组件之间的调用关系与此类似，如图2所示，客户程序只与同一进程中的代理对象打交道，组件程序只与同一进程中的存根DLL打交道，LPC调用只在代理对象和存根DLL之间进行，当客户程序需要调用组件提供的功能服务时，它需要执行图中所示的六个步骤才能完成一个函数调用，因此进程外组件的运行效率比进程内组件的效率要低，但是跨进程的调用也为客户程序带来了安全性，组件进程的严重错误不会使客户进程崩溃，这是其优越与进程内组件的地方 代理 DLL和存根DLL除了完成LPC调用之外，它还需要对参数和返回值进行翻译和传递，客户程序调用的参数，首先经过代理DLL的处理，它把参数以及其他的一些调用信息组装成一个数据包传递给组件进程，这个过程称为参数列集（marshaling）；组件进程接收到数据包之后，要进行解包操作，把参数信息提取出来，这个过程被称为散集（unmarshal—ing）；然后再进行实际的接口功能调用。函数的返回值和输出参数在返回的过程中也要进行列集和散集操作，只是在存根DLL一端进行列集、在代理DLL一端进行散集，最后把散集后的结果值返回给客户程序，完成一次功能调用。 现在我们了解了进程外组件的结构和参数的传递过程，除了实现组件程序外，还应该实现代理DLL和存根DLL两个程序模块。从上面的分析我们可以发现，代理DLL和存根DLL只与COM接口有关，它只负责接口成员函数调用过程中的中间处理工作，所以我们应该针对接口实现代理DLL和存根DLL。 如果我们使用自定义的COM接口，则应该建立自己的DLL程序； 如果我们使用COM预定义的标准接口或者OLE接口，则可以直接使用系统提供的DLL，COM库会为我们处理这些细节。 注册表管理COM规范使用128位GUID来标识COM对象和接口，客户程序通过这些CUID值来创建COM对象并与对象进行交互。因为客户程序与组件程序是独立的，客户程序在创建对象时并不一定知道组件程序的确切位置，按照COM规范，客户程序通过COM库完成对象的创建工作。COM库通过系统注册表所提供的信息进行组件的创建工作，系统注册表是一个全操作系统范围公用的信息仓库，其中包含了所有的COM组件必要的信息以及其他一些信息。 Windows注册表是一个树状的层次结构，根节点下包含了一些键和一些值，每个键又可以包含子键和值，com用到的注册表是HKEY_CLASSES_ROOT，最主要的是CLSID子键，列出了当前机器上所有组件的信息，在每个CLSID键下面，包含了与该组件对象相关的一些信息，就目前来说我们最关心的是组件程序的路径，对于不同的组件程序类型，其信息也有所不同。 如果是进程内组件，则组件的CLSID子键下包含了inprocServer32子键，该子键的缺省值为组件程序的全路径文件名； 如果是进程外组件，则组件CISID子键下包含了LocalServer32子键，该子键的缺省值为组件程序的全路径文件名。 在组件CLSID子键下还可以包含其他一些与组件相关的信息，例如，组件程序的版本、OLE组件的InprocHander32子键、组件程序的图标信息、组件程序的类型库等等 com组件的注册操作注册表是客户和组件程序共同访问的信息仓库，通常情况下，当组件程序被安装到机器上之后，必须通过某种途径把它的信息注册到注册表中，然后客户程序才能根据注册表中的信息对组件程序进行操作。根据组件程序的能力不同，我们把组件程序分为自注册组件程序和非自注册组件程序。 进程内组件程序和进程外组件程序的自注册过程有所不同，对于进程内组件，因为它只是一个动态链接库，本身不能直接运行，所以必须被某个进程调用才能获得控制；而进程外组件，因为它本身是一个可执行的程序，所以它可以直接执行，在执行过程中完成自身的注册操作。 Windows系统提供了一个用于注册进程内组件的实用工具regsvr32.exe，只要进程内组件提供了相应的入口函数，则regsvr32就可以完成注册或反注册工作。组件程序的两个用于注册的入口函数为DllRegisterServer和DllUnregisterServer，而regsvr32程序本身并不进行注册工作。 regsvr32 d:\\testcom.dll regsvr32调用组件程序testcom.dll中的DllRegisterServer函数完成组件程序的注册工作； regsvr32 -u d:\\testcom.dll regsvr32调用组件程序testcom.dll中的DllUnRegisterServer函数完成组件程序的注册工作. 类厂客户程序并不直接调用组件程序的引出函数，它调用com库的函数来进行组件对象的创建工作，com库的创建函数根据注册表的信息并调用组件程序的入口函数来创建组件对象。组件程序需要提供一个标准的入口函数DllGetClassObject，用于提供本组件程序的组件信息。 类厂和DllGetClassObject函数类厂（ClassFactory）这个名词其实有点迷惑性，因为这个东西实际上应该叫对象工厂。类厂也是一个普通的COM对象，它有一个特殊的接口IClassFactory，这个接口的一个函数CreateInstance()能够生成COM对象，并返回其需要的接口。如果把C++中的概念平移过来，就会发现类厂的作用本质上就是那个被C++编译器隐藏了的new。在COM中没有类定义，自然也没有new，要想生成COM对象，只能靠COM类的规范。类厂就实现了从COM类规范到COM对象的过程。 123456789101112131415IClassFactory : public IUnknown&#123;public: virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance( /* [annotation][unique][in] */ _In_opt_ IUnknown *pUnkOuter, /* [annotation][in] */ _In_ REFIID riid, /* [annotation][iid_is][out] */ _COM_Outptr_ void **ppvObject) = 0; virtual /* [local] */ HRESULT STDMETHODCALLTYPE LockServer( /* [in] */ BOOL fLock) = 0; &#125;; 接口IClassFactory有一个重要的成员函数CreateInstance,用于创建对应的com对象，LockServer用于控制组件的生命周期。 类厂本身也是个com对象，它被用于其他com对象的创建过程，而类厂对象是由DllGetClassObject引出函数创建的，DllGetClassObject函数并不是com库函数，而是由组件程序实现的引出函数， com库在接到对象创建的指令后，它要调用进程内组件的DllGetClassObject函数，由该函数创建类厂对象，并返回类厂对象的接口指针，com库或者客户一旦有了类厂的接口指针，它们就可以通过类厂接口IClassFactory的成员函数CreateInstance创建相应的com对象。 com库与类厂的交互在com库中，有3个api函数可用于对象的创建，它们分别是CoGetClassObject、CoCreateInstance和CoCreateInstanceEx, https://gitee.com/marblemm/test-com/tree/master/outofProc 参考：https://www.cnblogs.com/zxjay/archive/2010/08/28/1811163.html","categories":[{"name":"com","slug":"com","permalink":"https://marblemm.gitee.io/categories/com/"}],"tags":[]},{"title":"com-为什么需要com","slug":"com-为什么需要com","date":"2021-10-27T15:51:52.000Z","updated":"2021-11-13T16:10:04.194Z","comments":true,"path":"2021/10/27/com-为什么需要com/","link":"","permalink":"https://marblemm.gitee.io/2021/10/27/com-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81com/","excerpt":"","text":"软件分发从传统意义上讲，c++类库一直以源代码的形式分发，类库的用户可以把实现代码加入到他们的系统工程中，然后用他们的c++编译器在本地重新编译库的源代码，这么做的结果是，类库的可执行代码将成为客户应用中不可分割的一部分，想象有一个库厂商已经开发了一个算法可以在O(1)时间阶内完成子串搜索运算，字符串类定义如下： 1234567891011121314151617181920212223242526272829303132333435class FastString&#123;public: FastString(const char* psz); ~FastString(); int Length() const; int Find(const char* psz) const;private: char* m_psz;&#125;;#include &quot;FastString.h&quot;#include &lt;string.h&gt;FastString::FastString(const char* psz) :m_psz(new char[strlen(psz) + 1])&#123; strcpy(m_psz, psz);&#125;FastString::~FastString()&#123; delete[] m_psz;&#125;int FastString::Length() const&#123; return strlen(m_psz);&#125;int FastString::Find(const char* psz) const&#123; //O(1)&#125; 假设FastString类的四个方法所产生的机器码将在目标可执行文件中占有16MB的空间（空间换时间的策略）,如果三个应用都使用FastString库，那么每个可执行文件都将包含16M的类库代码，这意味着，如果一个最终用户安装了所有这三个应用程序，那么FastString实现将会占用48M的磁盘空间，更糟糕的是如果最终用户同时运行这三个程序，那么FastString代码将会占用48M的虚拟内存，因为操作系统不能够检测到多个可执行文件中重复出现的代码 这种情况下的另一个问题是，FastString类有更新，客户的应用程序必须得重新编译，以便用上更新后的代码 动态链接解决上面的问题的一种技术是把FastString类以动态链接库（DLL）的形式包装起来,最简单的技术就是用类层次上的编辑器指示符，强迫FastString的所有方法都从Dll中引出去。Microsoft C++编译器为这种用法提供了__declspec(dllexport)关键字： 123456789101112131415161718192021222324252627282930313233class __declspec(dllexport) FastStringExport&#123;public: FastStringExport(const char* psz); ~FastStringExport(); int Length() const; int Find(const char* psz) const;private: char* m_psz;&#125;;FastStringExport::FastStringExport(const char* psz) :m_psz(new char[strlen(psz) + 1])&#123; strcpy(m_psz, psz);&#125;FastStringExport::~FastStringExport()&#123; delete[] m_psz;&#125;int FastStringExport::Length() const&#123; return strlen(m_psz);&#125;int FastStringExport::Find(const char* psz) const&#123; //O(1)&#125; 在使用这项技术的时候， FastString的所有方法都将被加到FastString.DLL的引出表（export list）中，允许在运行时把每个方法的名字解析到内存中对应的地址。而且，链接器将会产生一个引入库（import library） ，这个库暴露了FastString的方法成员的符号。引入库并没有包含实际的代码，它只是简单地包含一些引用，这些引用指向DLL的文件名和被引出的符号的名字。当客户链接引入库时，有一些存根会被加入到可执行文件中，它在运行时通知装载器动态装载FastString DLL，并且把所有被引入的符号解析到内存中相应的位置上。当操作系统启动客户程序时，便会引发这个解析过程，但是整个过程完全是透明的。 图1.2演示了当FastString位于DLL中时，它的运行时模型。注意，引入库往往非常小（差不多是引出符号文本的两倍大小） 。当FastString从DLL中引出时，它的机器码在用户的硬盘上只保留一份就可以了。当多个客户访问库中的代码时，操作系统的装载器可以很灵活地让所有的客户程序共享同一份“包含FastString只读可执行代码”的物理内存页。而且，如果库的厂商发现了库中的错误的话，理论上讲它可以给最终用户发放一个新的DLL，使所有的客户应用同时修正原来的错误实现代码。很显然，把FastString库放到DLL中，这是从原始的C++类走向可替换的、有效的可重用组件的重要一步。 封装和分离为了提高Length操作的效率，可以在构造函数中把字符串的长度缓存起来，就不用重复计算长度了，厂商做了以下改进： 12345678910111213141516171819202122232425262728293031323334class __declspec(dllexport) FastString&#123;public: FastString(const char* psz); ~FastString(); int Length() const; int Find(const char* psz) const;private: char* m_psz; const int m_cch;&#125;;FastString::FastString(const char* psz) :m_psz(new char[strlen(psz) + 1]) ,m_cch(strlen(psz))&#123; strcpy(m_psz, psz);&#125;FastString::~FastString()&#123; delete[] m_psz;&#125;int FastString::Length() const&#123; return m_cch;&#125;int FastString::Find(const char* psz) const&#123; //O(1)&#125; 做了这三个修改之后，库厂商重新编译链接FastString DLL，发现DLL可以通过检验，于是向客户发放FastString 2.0版本，这里厂商过于相信c++支持的封装性了，c++通过private和public关键字确实支持语法上的封装性，但是c++草案标准并没有定义二进制层次上的封装性，这是因为c++编译模型要求客户的编译器必须能够访问与对象的内存布局有关的所有信息，这样才能构造类的实例，或者调用类的非虚成员函数。这些信息包括对象的私有成员和公共成员的大小和顺序。 从根本上讲，版本问题的根源在于C＋＋的编译模型，这种模型不能支持独立二进制组件的设计。C＋＋的编译模型要求客户必须知道对象的布局结构，从而导致了客户和对象可执行代码之间的二进制耦合关系。通常情况下，二进制耦合对于C＋＋非常有好处，因为这使得编译器可以产生非常高效的代码。但是不幸的是，这种紧密耦合性使得在不重新编译客户的情况下，类的实现无法被替换。由于这种耦合性，以及上一节提到的编译器和链接器的不兼容性，“简单地把C＋＋类的定义从DLL中引出来”这种方案并不能提供合理的二进制组件结构。 接口分离上面的问题可以这样来解决：构造一个模型，把两个抽象概念（接口和实现）做成两个分离的实体，即c++类，定义一个c++类使它代表指向一定数据类型的接口；定义另一个c++类作为数据类型的实际实现，下面的类定义说明了这项技术： 1234567891011121314151617181920212223242526272829303132class __declspec(dllexport) FastStringItf&#123;public: FastStringItf(const char* psz); ~FastStringItf(); int Length() const; int Find(const char* psz) const;private: class FastString; FastString* m_pThis;&#125;;FastStringItf::FastStringItf(const char* psz) :m_pThis(new FastString(psz))&#123;&#125;FastStringItf::~FastStringItf()&#123; delete m_pThis;&#125;int FastStringItf::Length() const&#123; return m_pThis-&gt;Length();&#125;int FastStringItf::Find(const char* psz) const&#123; return m_pThis-&gt;Find(psz);&#125; 这个接口类的二进制布局结构并不会随着实现类FastString中数据成员的加入或者删除而改变。而且，使用这样的声明也意味着FastString的类声明不需要被包含在这个头文件中就可以进行编译。这就很有效地把FastString的实现部分隐藏起来，客户的编译器不需要知道这些细节。在使用这项技术的时候，接口方法的机器码变成了对象DLL的唯一入口点，它们的二进制结构形式永远也不会再改变。接口类方法的实现只是把方法调用传递给实际的实现类. 以上这些传递调用的方法将被编译成为FastString DLL的一部分，所以当c++实现类FastString的内存结构发生变化时，客户永远也不会包含c++实现类FastString的类定义，这使得FastString实现者非常灵活，可以随着时间的推移改变它的实现过程，而不会打断现有的客户。 虽然使用接口分离的方法有它的优点，但是接口类必须要把每个方法调用显示地传递给实现类，编写这些传递过程非常冗长，对于性能方面每个方法增加两个函数调用的开销也不理想 抽象类作为二进制接口__declspec(dllexport) 解决了函数导出的问题，但是c++为了允许操作符重载和函数重载，c++编译器会将每个入口点的符号名进行篡改，也就是名字改编，而不同编译器的改编方案又不统一，消除名字改编的技术是extern “C”,但是它针对的是全局函数而不能是成员函数。 接口分离确实可以解决c++编译器链接器的部分兼容问题，但是如何在不同编译器上统一运行时表现语言的特征，就需要所有c++编译器都实现同样的虚函数调用机制。 在c++中，虚函数的运行时实现了vptr和vtbl的形式，每个类的实例包含一个不可见的数据成员，被称为虚函数指针，这个指针被构造函数自动初始化，指向类的vtbl中，当客户调用虚函数的时候，编译器产生代码反指向到vptr，索引到vtbl中，然后在指定的位置上找到函数指针，并发出调用，这就是c++中实现多态性以及动态调用分发的过程。于是我们可以这样定义c++接口类：所有对数据类型的公共操作都被定义成虚函数，这样可以保证所有的编译器将为客户端的方法调用产生等价的机器码而且接口类不能包含数据成员把接口定义为纯虚函数相当于告诉编译器，接口类不要求实现这些方法。 1234567891011121314151617181920class IFastString&#123;public: virtual int Length() const = 0; virtual int Find(const char* psz) const = 0;&#125;;class FastString : public IFastString&#123;public: FastString(const char* psz); ~FastString(); int Length() const; int Find(const char* psz) const;private: char* m_psz; const int m_cch;&#125;; 最终FastString和IFastString的关系图如下图所示 此时客户没有实现类的定义仍然不能构造FastString类的对象，但是把实现类的定义暴露给客户就等于绕过了接口的二进制封装，从而破坏了使用接口类的基本意图所以得引出一个全局函数，由它代表客户调用new操作符 12345678extern &quot;C&quot; IFastString * CreateFastString(const char* psz);IFastString* CreateFastString(const char* psz)&#123; return new FastString(psz);&#125; 客户调用代码如下 12345678910#include &quot;IFastString.h&quot;int main()&#123; IFastString* pfs = CreateFastString(&quot;hello world&quot;); int n = pfs-&gt;Find(&quot;hello&quot;); delete pfs; return n;&#125; 客户端调用逻辑有问题，因为接口类的析构并不是虚函数，这意味着对delete操作符的调用并不会动态找到最终派生类的析构函数，所以会发生内存泄漏。针对这个问题一个显而易见的解决方案是把接口类的析构函数做成虚函数，但是这将会破坏接口类的编译器独立性，因为虚析构函数在vtbl中的位置随着编译器的不同而不同，对于这个问题，一个可行的解决方案是显式地增加一个Delete方法,作为接口类的另一个纯虚函数，并且让派生类在这个方法实现中删除自身 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class IFastString&#123;public: virtual void Delete() = 0; virtual int Length() const = 0; virtual int Find(const char* psz) const = 0;&#125;;extern &quot;C&quot; IFastString * CreateFastString(const char* psz);class FastString : public IFastString&#123;public: FastString(const char* psz); ~FastString(); void Delete(); int Length() const; int Find(const char* psz) const;private: char* m_psz; const int m_cch;&#125;;IFastString* CreateFastString(const char* psz)&#123; return new FastString(psz);&#125;FastString::FastString(const char* psz) :m_psz(new char[strlen(psz) + 1]) , m_cch(strlen(psz))&#123; strcpy(m_psz, psz);&#125;FastString::~FastString()&#123; delete[] m_psz;&#125;void FastString::Delete()&#123; delete this;&#125;int FastString::Length() const&#123; return m_cch;&#125;int FastString::Find(const char* psz) const&#123; //O(1)&#125;int main()&#123; int n = -1; IFastString* pfs = CreateFastString(&quot;hello world&quot;); if (pfs) &#123; n = pfs-&gt;Find(&quot;hello&quot;); pfs-&gt;Delete(); &#125; return n;&#125; 下图显示了FastString的运行时内存结构 在FasString DLL中，除了一个入口函数之外，其他所有的入口函数都是虚函数。接口类的虚函数总是通过保存在vtbl中的函数指针被间接调用，客户程序不需要在开发时候链接这些函数的符号名。这意味着接口方法可以不受“不同编译器之间符号名改编方式的不同”的影响。唯一需要通过名字显式链接的入口函数是CreateFastString，这个全局函数使得客户可以进入到FastString的世界中。然而，请注意，这个函数使用extern “C”被引出，从而避免了符号名改编方式的冲突。这也隐含着所有的C++编译器都期望引入库和DLL引出同样的符号。使用这项技术的一个直接结果是，我们可以安全地在一个C++环境中暴露DLL中的类，并且在另一个C++开发环境中访问这个类。 运行时多态性FastString DLL只引出了一个符号CreateFastString，这使得客户可以很方便地按需动态装入DLL（使用LoadLibrary)，并且使用GetProcAddress得到唯一的入口函数 123456789101112131415161718const TCHAR szDLL[] = _TEXT(&quot;FastString.dll&quot;);const char szfs[] = &quot;CreateFastString&quot;;HINSTANCE h = ::LoadLibrary(szDLL);if (h)&#123; typedef IFastString* (*pfn)(const char*); pfn fs = (pfn)GetProcAddress(h, szfs); if (fs) &#123; IFastString* cfs = (fs)(&quot;hello world&quot;); if (cfs) &#123; int size = cfs-&gt;Length(); cfs-&gt;Delete(); &#125; &#125;&#125; 使用这项技术有两种好处：1、当客户程序在没有安装对象实现的机器上运行时，可以避免操作系统产生错误，而且客户并不需要链接dll的引入库，所以对dll并没有依赖性，即使机器上没有安装相应的DLL，它也一样可以执行；2、减少进程地址空间初始化的工作，加快客户的启动速度 对象扩展性尽管接口具有不变性的原则，但是我们通常要在一个接口已经被设计好之后，希望能够加入原先没有预见到的新功能，我们可以利用vtbl布局结构的知识，简单地把新的方法追加在现有接口定义的尾部 123456789class IFastString&#123;public: virtual void Delete() = 0; virtual int Length() const = 0; virtual int Find(const char* psz) const = 0; virtual int FindN(const char* psz, int n);&#125;; 这种方案可以正常工作，当老客户得到了包含FindN的新对象时，它们仍然能够正常工作，然而，新的客户总是期望IFastString有第四个方法，但它碰巧使用老的对象时，程序就会崩溃 这项技术的问题在于，它修改了公开的接口，从而打破了对象的封装性。这意味这接口必须是不可改变的，一旦公开之后，接口就不能再变化。这个问题的解决办法是”允许实现类暴露多个接口“，这可以通过两种途径获得：设计一个接口使它继承另一个相关的接口，或者让实现类继承多个不相关的接口类，无论哪种途径，客户总是可以使用c++的运行时类型识别功能 为了在IFastString接口中增加FindN操作，使客户可以找到一个子串第n次出现的位置，我们可以从IFastString接口派生出另一个接口 123456class IFastString2 : IFastString&#123;public: virtual int FindN(const char* psz, int n) = 0;&#125;; 客户可以在运行时询问对象，以确定对象是否与IFastString相容，客户可以使用c++的dynamic_cast操作符 1234567int test(IFastString* pfs)&#123; IFastString2* pfs2 = dynamic_cast&lt;IFastString2*&gt;(pfs); if (pfs2) return pfs2-&gt;FindN(&quot;mm&quot;, 10); ...&#125; 这种动态系统可以随时间的推移不断提供新的扩展功能。 当对象需要暴露新的正交功能时，考虑一下当我们需要为FastString实现类增加永久性支持的功能，我们可以在IFastString扩展版本的接口中加入Load和Save方法，但是极有可能其他非IFastString兼容的对象也需要永久性，此时IpersistentObject接口应该具有通用性，应该是一个独立的接口，不需要从IFastString继承： 12345678class IPersistentObject&#123;public: virtual void Delete() = 0; virtual bool Load(const char* pszFileName) = 0; virtual bool Save(const char* pszFileName) = 0;&#125;; 这样的定义并没有妨碍FastString实现也可以具有永久性，只是必须同时实现IFastString和IPersistentObject接口。 12345678910111213141516class FastString : public IFastString , public IPersistentObject&#123;public: FastString(const char* psz); ~FastString(); void Delete(); int Length() const; int Find(const char* psz) const; bool Load(const char* pszFileName); bool Save(const char* pszFileName);private: char* m_psz; const int m_cch;&#125;; 为了把FastString保存到磁盘上，客户只要简单地使用RTTI得到一个指向对象暴露出来的IPersistentObject接口即可： 12345678bool SaveString(IFastString* pfs, const char* pszFN)&#123; bool bResult = false; IPersistentObject* ppo = dynamic_cast&lt;IPersistentObject*&gt;(pfs); if (ppo) bResult = ppo-&gt;Save(pszFN); return bResult;&#125; 这项技术可以正常工作，编译器可以在运行时检查对象，以便确定对象是否继承自IPersistentObject，但是这里仍然有问题。RTTI是一个与编译器极为相关的特征，每个编译器厂商对RTTI的实现则是独有的，也是私有的，这就大大破坏了”以抽象基类作为接口而获得的编译器独立性“。一个很简捷的办法不使用实际与编译器相关的语言特征，从每一个接口显示地暴露一个广为人知的办法，由这个方法完成与dynamic_cast语言等价的功能 1234567891011121314151617class IFastString&#123;public: virtual void* Dynamic_Cast(const char* pszType) = 0; virtual void Delete() = 0; virtual int Length() const = 0; virtual int Find(const char* psz) const = 0;&#125;;class IPersistentObject&#123;public: virtual void* Dynamic_Cast(const char* pszType) = 0; virtual void Delete() = 0; virtual bool Load(const char* pszFileName) = 0; virtual bool Save(const char* pszFileName) = 0;&#125;; 既然所有的接口都需要暴露这个方法以及Delete方法，于是很自然的想法是把这些公共的方法提升到一个基接口中，然后所有其他的接口都从这个接口继承得到： 123456789101112131415161718192021class IExtensibleObject&#123;public: virtual void* Dynamic_Cast(const char* pszType) = 0; virtual void Delete() = 0;&#125;;class IFastString : public IExtensibleObject&#123;public: virtual int Length() const = 0; virtual int Find(const char* psz) const = 0;&#125;;class IPersistentObject : public IExtensibleObject&#123;public: virtual bool Load(const char* pszFileName) = 0; virtual bool Save(const char* pszFileName) = 0;&#125;; Dynamic_Cast的实现通过操作对象的类型层次结构，模拟出RTTI的功能，如下图所示因为实现类是从它所暴露的每个接口派生而来的，所以FastString中Dynamic_Cast的实现可以简单地使用显式的静态类型转换功能，把this指针转换到客户所请求的子类型： 12345678910void* FastString::Dynamic_Cast(const char* pszType)&#123; if (strcmp(pszType, &quot;IFastString&quot;) == 0) return static_cast&lt;IFastString*&gt;(this); else if (strcmp(pszType, &quot;IPersistentObject&quot;) == 0) return static_cast&lt;IPersistentObject*&gt;(this); else if (strcmp(pszType, &quot;IExtensibleObject&quot;) == 0) return static_cast&lt;IFastString*&gt;(this); return 0;&#125; cast指令的编译版本只是简单地在对象的this指针上加上固定的偏移，就可以找到基类的布局结构的起始处。 资源管理当我们检查客户对Dynamic_Cast方法的使用模式时，我们发现单个对象支持多个接口还有个问题需要解决。 12345678910111213141516171819void f()&#123; IFastString* pfs = 0; IPersistentObject* ppo = 0; pfs = CreateFastString(&quot;hello world&quot;); if (pfs) &#123; ppo = (IPersistentObject*)pfs-&gt;Dynamic_Cast(&quot;IPersistentObject&quot;); if (!ppo) &#123; pfs-&gt;Delete(); &#125; else &#123; ppo-&gt;Save(&quot;d:\\\\test.txt&quot;); ppo-&gt;Delete(); &#125; &#125;&#125; 尽管对象最初是通过其 IFastString 接口与客户联系起来的，但是客户代码却是通过IPersistentObject 接口调用Delete 方法的。有了C＋＋中多重继承的行为方式，这不成问题，因为所有属于该类的、从IExtensibleObject 派生的vtbl都将指向 Delete方法的唯一 一份实现代码。然而，客户现在必须要记录下哪个指针是与哪个对象联系在一起的，并且每个对象只能调用一次Delete方法。对于上面给出的简单代码，这不是繁重的负担。但是在复杂的客户代码中，管理这些关系会变得非常复杂，并且很容易出错。简化客户的任务的一种办法是，把管理对象生命周期的责任推给对象实现部分。毕竟，允许客户显式地删除一个对象，这种做法会泄露出另一个实现细节：对象是被分配在堆（heap）上的事实。 对于这个问题，一个简单的解决方法是让每个对象都维护一个引用计数，当接口指针被复制的时候，该计数值增加；当接口指针被销毁的时候，该计数值减少。这意味着要把IExtensibleObject定义修改下 1234567891011121314class IExtensibleObject&#123;public: virtual void* Dynamic_Cast(const char* pszType) = 0; virtual void Delete() = 0;&#125;;改成class IExtensibleObject&#123;public: virtual void* Dynamic_Cast(const char* pszType) = 0; virtual void AddRef() = 0; virtual void Release() = 0;&#125;; 有了这些方法之后，现在IExtensibleObject的所有客户必须遵守下面两条要求：1、当借口指针被复制的时候，要求调用AddRef；2、当接口指针不再使用时，要求调用Release;这些方法可以在每一个对象中很方便地加以实现，只要时时注意活动指针的数目，如果不存在未完结的指针则将对象销毁： 1234567891011121314151617class FastString : public IFastString , public IPersistentObject&#123;public: ... FastString(const char* psz) : m_ref(0)&#123;&#125; void AddRef()&#123;++m_ref;&#125; void Release() &#123; if(--m_ref == 0) delete this; &#125;private: ... int m_ref;&#125;; 很容易可以将这份样板代码放到基类中，或者放到预编译宏中，供所有实现类使用。为了支持这些方法，所有操作或者管理接口指针的代码必须遵守关于AddRef/Release的两条简单规则。对于FastString实现来说，需要修改两个函数 123456789101112131415161718192021222324IFastString* CreateFastString(const char* psz)&#123; IFastString* pFsResult = new FastString(psz); if (pFsResult) pFsResult-&gt;AddRef(); return pFsResult;&#125;void* FastString::Dynamic_Cast(const char* pszType)&#123; void* pvResult = 0; if (strcmp(pszType, &quot;IFastString&quot;) == 0) pvResult = static_cast&lt;IFastString*&gt;(this); else if (strcmp(pszType, &quot;IPersistentObject&quot;) == 0) pvResult = static_cast&lt;IPersistentObject*&gt;(this); else if (strcmp(pszType, &quot;IExtensibleObject&quot;) == 0) pvResult = static_cast&lt;IFastString*&gt;(this); else return 0; (IPersistentObject*)pvResult-&gt;AddRef(); return pvResult;&#125; 有了这两处修改之后，对应的客户代码现在也变得更加统一，更加明确了 12345678910111213141516void f()&#123; IFastString* pfs = 0; IPersistentObject* ppo = 0; pfs = CreateFastString(&quot;hello world&quot;); if (pfs) &#123; ppo = (IPersistentObject*)pfs-&gt;Dynamic_Cast(&quot;IPersistentObject&quot;); if (ppo) &#123; ppo-&gt;Save(&quot;d:\\\\test.txt&quot;); ppo-&gt;Release(); &#125; pfs-&gt;Release(); &#125;&#125; 因为每个指针都被看做一个具有独立生命周期的实体，所以客户并不需要把哪个指针与哪个对象联系起来。客户只需要地遵守两条简单的规则，从而允许对象自己管理它的生命周期。而且AddRef/Release的调用可以很容易地被隐藏到c++智能指针的后面。 以上就是组件对象模型（COM）","categories":[{"name":"com","slug":"com","permalink":"https://marblemm.gitee.io/categories/com/"}],"tags":[]},{"title":"CMake教程","slug":"CMake教程","date":"2021-09-11T06:40:23.000Z","updated":"2021-09-11T07:13:40.717Z","comments":true,"path":"2021/09/11/CMake教程/","link":"","permalink":"https://marblemm.gitee.io/2021/09/11/CMake%E6%95%99%E7%A8%8B/","excerpt":"","text":"cmake官网：www.cmake.org 优点： 1、开源代码，使用类BSD许可发布。 2、跨平台，并可以生成native编译配置文件，在linux/Unix平台，生成makefile,在苹果平台可以生成Xcode,在windows平台，可以生成MSVC的工程文件。 3、能够管理大型项目。 4、简化编译构建过程和编译过程。cmake的工具链：cmake+make。 5、高效率，因为cmake在工具链中没有libtool。 6、可扩展，可以为cmake编写特定功能的模块，扩展cmake功能。 缺点： 1、cmake只是看起来比较简单，使用并不简单； 2、每个项目使用一个CMakeLists.txt（每个目录一个），使用的是cmake语法。 3、cmake跟已有体系配合不是特别的理想，比如pkgconfig。 下面是cmake官网教程，共分为12章来讲解https://cmake.org/cmake/help/latest/guide/tutorial/index.html 对应的代码在github地址https://github.com/Kitware/CMake/tree/master/Help/guide/tutorial 接下来主要对cmake的一些常用语法进行总结 1.1 指定cmake的最小版本cmake_minimum_required(version 版本号) 例如： cmake_minimum_required(version 2.8) 1.2 定义工程名称#定义工程名称 project(项目名称) 例如： project(MyTest) 1.3 显示定义变量set(var [value]) 例如： # 第一种用法，生成代码文件列表 #先直接设置SRC_LIST的值 set(SRC_LIST add.h add.cpp) #然后再在SRC_LIST中追加main.cpp set(SRC_LIST $&#123;SRC_LIST&#125; main.cpp) # 第二中用法，设置库生成目录或者可执行文件生成目录 set( LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib/linux) set( EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) 1.4 设置编译类型# 编译静态库 add_library(库名称 STATIC 代码文件名称) # 编译动态库 add_library(库名称 SHARED 代码文件名称) # 编译可执行程序 add_executable(可执行程序名 代码文件名称) 例如： # 编译静态库 add_library(add STATIC add.h add.cpp) add_library(add STATIC $&#123;ADD_SRC&#125; $&#123;ADD_HDR&#125;) # 编译动态库 add_library(add SHARED add.h add.cpp) add_library(add SHARED $&#123;ADD_SRC&#125; $&#123;ADD_HDR&#125;) # 编译可执行程序 add_executable(main add.h add.cpp mai.cpp) add_executable(main $&#123;MAIN_SRC&#125; $&#123;MAIN_HDR&#125;) 1.5 指定静态库或者动态库编译输出目录例如将当前编译的静态库或者动态库输出到当前项目文件夹lib子目录下 set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib) 1.6 指定可执行程序编译输出目录例如将当前可执行程序输出到当前项目文件夹的bin子目录下 #设定可执行二进制文件的目录 set( EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) 1.7 设置链接库搜索目录例如将链接库搜索目录设置为当前项目文件夹下lib/linux文件夹 link_directories( $&#123;PROJECT_SOURCE_DIR&#125;/lib/linux) 1.8 设置包含目录例如将包含目录设置为当前项目文件夹下include文件夹 include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include) 1.9 设置宏定义#预定义宏 add_definitions(-D宏名称)例如： add_definitions(-DWINDOWS) add_definitions(-DLINUX) 1.10 链接静态库link_libraries( 静态库1 静态库2 静态库3 ... ) 注意，link_libraries中的静态库为全路径，常与1.7 link_directories 搭配使用，例如： lib1.a lib2.a在目录$&#123;PROJECT_SOURCE_DIR&#125;/lib/linux下，则先设置链接目录，再链接相应的库 #设置链接目录 link_directories( $&#123;PROJECT_SOURCE_DIR&#125;/lib/linux) link_libraries( lib1.a lib2.a ) 1.11 链接动态库target_link_libraries(所需生成的文件名称 所需链接的动态库名称)例如 target_link_libraries(main dl) 1.12 link_libraries 和 target_link_libraries 区别在cmake语法中，link_libraries和target_link_libraries是很重要的两个链接库的方式，虽然写法上很相似，但是功能上有很大区别： (1) link_libraries用在add_executable之前，target_link_libraries用在add_executable之后 (2) link_libraries用来链接静态库，target_link_libraries用来链接导入库，即按照header file + .lib + .dll方式隐式调用动态库的.lib库 1.13 file语法1.13.1 将文件夹所有的类型的文件添加到文件列表例如将当前文件夹下所有.cpp文件的文件名加入到MAIN_SRC中，将当前文件夹下所有.h加入到MAIN_HDR中。 file(GLOB MAIN_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp) file(GLOB MAIN_HDR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.h) 例如将当前文件夹子目录src文件夹下所有.cpp文件的文件名加入到MAIN_SRC中，将当前文件夹子目录src文件夹下所有.h加入到MAIN_HDR中。 file(GLOB MAIN_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp) file(GLOB MAIN_HDR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h) 1.13.2 递归搜索该文件夹，将文件夹下（包含子目录）符合类型的文件添加到文件列表例如将当前文件夹下（包括子目录下）所有.cpp文件的文件名加入到MAIN_SRC中，所有.h加入到MAIN_HDR中 file(GLOB_RECURSE MAIN_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp) file(GLOB_RECURSE MAIN_HDR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.h) 1.14 List操作常见的List操作包括： list(LENGTH &lt;list&gt; &lt;output variable&gt;) list(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;) list(APPEND &lt;list&gt; [&lt;element&gt; ...]) list(FIND &lt;list&gt; &lt;value&gt; &lt;output variable&gt;) list(INSERT &lt;list&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...]) list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...]) list(REMOVE_AT &lt;list&gt; &lt;index&gt; [&lt;index&gt; ...]) list(REMOVE_DUPLICATES &lt;list&gt;) list(REVERSE &lt;list&gt;) list(SORT &lt;list&gt;) 1.14.1 List移除指定项例如从MAIN_SRC移除指定项 list(REMOVE_ITEM MAIN_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/add.cpp) 1.14.2 将两个List链接起来# 搜索当前目录 file(GLOB MAIN_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp) file(GLOB MAIN_HDR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.h) # 递归搜索当前目录下src子目录 file(GLOB_RECURSE MAIN_SRC_ELSE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp) file(GLOB_RECURSE MAIN_HDR_ELSE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h) # 将MAIN_SRC_ELSE中的值添加到MAIN_SRC # 将MAIN_HDR_ELSE中的值添加到MAIN_HDR list(APPEND MAIN_SRC $&#123;MAIN_SRC_ELSE&#125;) list(APPEND MAIN_HDR $&#123;MAIN_HDR_ELSE&#125;) 1.15 添加子文件夹例如 add_subdirectory(src) 该语句会在执行完当前文件夹CMakeLists.txt之后执行src子目录下的CMakeLists.txt 1.16 message输出消息机制输出正常： message(STATUS &quot;Enter cmake $&#123;CMAKE_CURRENT_LIST_DIR&#125;&quot;) 输出警告 message(WARNING &quot;Enter cmake $&#123;CMAKE_CURRENT_LIST_DIR&#125;&quot;) 输出错误： message(FATAL_ERROR &quot;Enter cmake $&#123;CMAKE_CURRENT_LIST_DIR&#125;&quot;) 1.17 安装install 指令用于定义安装规则，安装的内容包括二进制可执行文件、动态库、静态库以及文件、目录、脚本等。 1.17.1 目标文件安装例如： install(TARGETS util RUNTIME DESTINATION bin LIBRARY DESTINATION lib ARCHIVE DESTINATION lib) ARCHIVE指静态库，LIBRARY指动态库，RUNTIME指可执行目标二进制，上述示例的意思是： 如果目标util是可执行二进制目标，则安装到$&#123;CMAKE_INSTALL_PREFIX&#125;/bin目录 如果目标util是静态库，则安装到安装到$&#123;CMAKE_INSTALL_PREFIX&#125;/lib目录 如果目标util是动态库，则安装到安装到$&#123;CMAKE_INSTALL_PREFIX&#125;/lib目录 1.17.2 文件夹安装install(DIRECTORY include/ DESTINATION include/util) 这个语句的意思是将include/目录安装到include/util目录 1.18 设置编译选项设置编译选项可以通过add_compile_options命令，也可以通过set命令修改CMAKE_CXX_FLAGS或CMAKE_C_FLAGS。 方式1 set( CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11 -march=native -O3 -frtti -fpermissive -fexceptions -pthread&quot;) 方式2 add_compile_options(-march=native -O3 -fexceptions -pthread -fPIC) 这两种方式的区别在于： add_compile_options命令添加的编译选项是针对所有编译器的(包括c和c++编译器)，而set命令设置CMAKE_C_FLAGS或CMAKE_CXX_FLAGS变量则是分别只针对c和c++编译器的。 1.19 预定义变量1.19.1 基本变量==PROJECT_SOURCE_DIR==-----------------------------------------我们使用cmake命令后紧跟的目录，一般是工程的根目录； ==PROJECT_BINARY_DIR== ------------------------------------------执行cmake命令的目录,通常是$&#123;PROJECT_SOURCE_DIR&#125;/build； ==CMAKE_INCLUDE_PATH==-----------------------------------------系统环境变量,非cmake变量； ==CMAKE_LIBRARY_PATH==------------------------------------------系统环境变量,非cmake变量； ==CMAKE_CURRENT_SOURCE_DIR==---------------------------当前处理的CMakeLists.txt所在的路径； ==CMAKE_CURRENT_BINARY_DIR==-----------------------------target编译目录（使用ADD_SURDIRECTORY(src bin)可以更改此变量的值 ，SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)并不会对此变量有影响,只是改变了最终目标文件的存储路径）； ==CMAKE_CURRENT_LIST_FILE==--------------------------------输出调用这个变量的CMakeLists.txt的完整路径； ==CMAKE_CURRENT_LIST_LINE==--------------------------------输出这个变量所在的行； ==CMAKE_MODULE_PATH==-----------------------------------------定义自己的cmake模块所在的路径（这个变量用于定义自己的cmake模块所在的路径，如果你的工程比较复杂，有可能自己编写一些cmake模块，比如SET(CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake),然后可以用INCLUDE命令来调用自己的模块）； ==EXECUTABLE_OUTPUT_PATH==------------------------------重新定义目标二进制可执行文件的存放位置； ==LIBRARY_OUTPUT_PATH==--------------------------------------重新定义目标链接库文件的存放位置； ==PROJECT_NAME==-------------------------------------------------返回通过PROJECT指令定义的项目名称； ==CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS==—用来控制IF ELSE语句的书写方式； 1.19.2 操作系统变量==CMAKE_MAJOR_VERSION==-----------------------------cmake主版本号,如3.4.1中的3； ==CMAKE_MINOR_VERSION==-----------------------------cmake次版本号,如3.4.1中的4； ==CMAKE_PATCH_VERSION==-----------------------------cmake补丁等级,如3.4.1中的1； ==CMAKE_SYSTEM==----------------------------------------操作系统名称，包括版本名，如Linux-2.6.22； ==CAMKE_SYSTEM_NAME==-------------------------------操作系统名称，不包括版本名，如Linux； ==CMAKE_SYSTEM_VERSION==--------------------------操作系统版本号,如2.6.22； ==CMAKE_SYSTEM_PROCESSOR==--------------------电脑处理器名称，如i686； ==UNIX==--------------------------------------------------------在所有的类UNIX平台为TRUE,包括OS X和cygwin，Linux/Unix操作系统； ==WIN32==-----------------------------------------------------在所有的win32平台为TRUE,包括cygwin，Windows操作系统； ==APPLE==----------------------------------------------------苹果操作系统； 例如操作系统判断方式一： if(WIN32) message(STATUS “This operating system is Windows.”) elseif(UNIX) message(STATUS “This operating system is Linux.”) elseif(APPLE) message(STATUS “This operating system is APPLE.”) endif(WIN32) 操作系统判断方式二： if (CMAKE_SYSTEM_NAME MATCHES &quot;Linux&quot;) message(STATUS &quot;current platform: Linux &quot;) elseif (CMAKE_SYSTEM_NAME MATCHES &quot;Windows&quot;) message(STATUS &quot;current platform: Windows&quot;) elseif (CMAKE_SYSTEM_NAME MATCHES &quot;FreeBSD&quot;) message(STATUS &quot;current platform: FreeBSD&quot;) else () message(STATUS &quot;other platform: $&#123;CMAKE_SYSTEM_NAME&#125;&quot;) endif (CMAKE_SYSTEM_NAME MATCHES &quot;Linux&quot;) 1.19.3 开关选项==BUILD_SHARED_LIBS==---------------------------------------------控制默认的库编译方式。如果未进行设置,使用ADD_LIBRARY时又没有指定库类型,默认编译生成的库都是静态库； ==CMAKE_C_FLAGS==-------------------------------------------------设置C编译选项，也可以通过指令ADD_DEFINITIONS()添加； ==CMAKE_CXX_FLAGS==----------------------------------------------设置C++编译选项，也可以通过指令ADD_DEFINITIONS()添加； ==CMAKE_C_COMPILER==--------------------------------------------指定C编译器； ==CMAKE_CXX_COMPILER==----------------------------------------指定C++编译器； ==CMAKE_BUILD_TYPE==:：build 类型(Debug, Release, …)-CMAKE_BUILD_TYPE=Debug 1.19.4 环境变量设置环境变量： set(env&#123;name&#125; value) 调用环境变量： $env&#123;name&#125; 例如 message(STATUS &quot;$env&#123;name&#125;&quot;) 1.19.5 CMAKE_INCLUDE_CURRENT_DIR自动添加CMAKE_CURRENT_BINARY_DIR和CMAKE_CURRENT_SOURCE_DIR到当前处理 的CMakeLists.txt。 相当于在每个CMakeLists.txt加入： include_directories($&#123;CMAKE_CURRENT_BINARY_DIR&#125; $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;) 1.20 条件判断1.20.1 逻辑判断和比较==if (expression)==：expression 不为空时为真，false的值包括（0,N,NO,OFF,FALSE,NOTFOUND）； ==if (not exp)==：与上面相反； ==if (var1 AND var2)==：如果两个变量都为真时为真； ==if (var1 OR var2)==：如果两个变量有一个为真时为真； ==if (COMMAND cmd)==：如果 cmd 确实是命令并可调用为真； ==if (EXISTS dir) if (EXISTS file)==：如果目录或文件存在为真； ==if (file1 IS_NEWER_THAN file2)==：当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径； ==if (IS_DIRECTORY dir)==：当 dir 是目录时为真； ==if (DEFINED var)==：如果变量被定义为真； ==if (var MATCHES regex)==：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 var 可以用 var 名，也可以用 $&#123;var&#125;； ==if (string MATCHES regex)==：给定的字符串能够匹配正则表达式regex时为真。 1.20.2 数字比较==if (variable LESS number)==：如果variable小于number时为真； ==if (string LESS number)==：如果string小于number时为真； ==if (variable GREATER number)==：如果variable大于number时为真； ==if (string GREATER number)==：如果string大于number时为真； ==if (variable EQUAL number)==：如果variable等于number时为真； ==if (string EQUAL number)==：如果string等于number时为真。 1.20.3 字母表顺序比较==if (variable STRLESS string)== ==if (string STRLESS string)== ==if (variable STRGREATER string)== ==if (string STRGREATER string)== ==if (variable STREQUAL string)== ==if (string STREQUAL string)== 1.21 循环1.21.1 foreachstart 表示起始数，stop 表示终止数，step 表示步长 foreach(loop_var RANGE start stop [step]) ... endforeach(loop_var) 1.21.2 whilewhile(condition) ... endwhile() 1.22 自动检测编译器是否支持C++11include(CheckCXXCompilerFlag) CHECK_CXX_COMPILER_FLAG(&quot;-std=c++11&quot; COMPILER_SUPPORTS_CXX11) CHECK_CXX_COMPILER_FLAG(&quot;-std=c++0x&quot; COMPILER_SUPPORTS_CXX0X) if(COMPILER_SUPPORTS_CXX11) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;) elseif(COMPILER_SUPPORTS_CXX0X) set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++0x&quot;) else() message(STATUS &quot;The compiler $&#123;CMAKE_CXX_COMPILER&#125; has no C++11 support. Please use a different C++ compiler.&quot;) endif() 1.23 CMake生成VS解决方案将项目放置在设定文件夹下例如，我们在工程中引用了许多的第三方开源库，这些库的源码与自己所写的代码需要进行区分和隔离，通常情况下会单独开一个third筛选器存储这些第三方库的项目，怎么做？ 第一步： 在第三方库的CMakeLists.txt中cmake_minimum_required(VERSION 2.6)中加上set_property(GLOBAL PROPERTY USE_FOLDERS On) 第二步：在生成编译目标的语法之后，如： add_executable(demo demo.cpp) # 生成可执行文件 add_library(common STATIC util.cpp) # 生成静态库 add_library(common SHARED util.cpp) # 生成动态库或共享库 加入一句 set_target_properties($&#123;第三方库项目名称&#125; PROPERTIES FOLDER “目标文件夹名称”) cmake构建mkdir build cmake .. make 参考： https://www.jianshu.com/p/6b7aabfbace0https://zhuanlan.zhihu.com/p/315768216https://blog.csdn.net/qq_38410730/article/details/102677143","categories":[{"name":"cmake","slug":"cmake","permalink":"https://marblemm.gitee.io/categories/cmake/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"https://marblemm.gitee.io/tags/cmake/"}]},{"title":"VS中头文件stdafx.h的作用","slug":"VS中头文件stdafx-h的作用","date":"2021-09-07T14:42:45.000Z","updated":"2021-09-07T15:04:47.527Z","comments":true,"path":"2021/09/07/VS中头文件stdafx-h的作用/","link":"","permalink":"https://marblemm.gitee.io/2021/09/07/VS%E4%B8%AD%E5%A4%B4%E6%96%87%E4%BB%B6stdafx-h%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"","text":"在 Visual Studio 中，新生成的C++项目文件的的头文件夹下会默认有头文件stdafx.h，而源文件夹下则默认有源文件stdafx.cpp，手动将这些文件删除后，编译时系统还会报错。下面总结关于头文件stdafx.h的信息。 使用预编译头为了提高编译速度 stdafx.h并不是标准C++头文件，也就是说，该文件本质上相当于自定义的一个头文件( 这里是VS默认自定义的文件)，与项目的源代码文件存放在同一个文件文件夹下，通过#include”stdafx.h”引用； 从内容上来说，头文件stdafx.h中可以包含 1.标准系统包含文件 2.经常使用的但不常更改的特定于项目的包含文件 标准系统包含文件 : 即常用的与C标准库对应的头文件，如标准输入头文件stdio.h、字符串头文件string.h等文件。 自定义的包含文件 : 即用户根据项目需要自定义的头文件。 在使用头文件 stdafx.h 时，将所有源程序中所需的包含文件( .h 文件 )都包含在头文件stdafx.h中，具体的做法就是将原本各个文件中所需要的类似于#include&lt;stdio.h&gt;的头文件包含语句都存放在头文件stdfax.h中，之后各个单独的文件中不需要再对存在于stdafx.h中的头文件进行单独声明，而只需要包含有头文件stdafx.h即可。 #include&quot;stdafx.h&quot; //通过该语句包含头文件stdafx.h，该语句需放在每个源文件文件的开头，否则会报错 同时，stdafx.h也可以存放内容改动较少的自定义的头文件。 相应的，源文件stdafx.cpp中内容仅包含以下语句 #include &quot;stdafx.h&quot; //事实上，stdfax.cpp只用于编译头文件stdafx.h中包含的所有内容 事实上，stdafx.cpp只用于编译头文件stdafx.h中包含的所有内容。 开启/关闭预编译头 选中目标项目，右键 -&gt; 属性 -&gt; C/C++ -&gt; 预编译头，在右侧的选项中可以修改预编译头的相关设置。 1.可以修改选项为使用/不使用预编译头，从而开启/关闭预编译头机制； 2.可以修改预编译头文件的名字(预编译头是一种机制，具体的头文件名是可以自行指定的)； 3.修改预编译头输出文件的路径； 实际上，每个单独的源文件中均存在关于预编译头的属性，用于指定不同的编译策略，可供使用者自行选择。特别的，源文件stdafx.cpp的预编译头属性栏应设置为 创建(/Yc)，这样设置表示预编译头是由该源文件生成，而被其他文件使用。 预编译头的原理 在标准头文件中，往往包含有大量的函数声明、宏定义等方面的内容。一方面，原始预处理过程会将实际头文件的内容复制到源程序中，这给编译过程增加很大的开销；另一方面，多个不同的单独的源文件可能会重复声明头文件的包含关系来满足传统的函数声明的要求，这也给编译器带来了重复劳动。另外，当文件发生修改时，整个文件需要重新编译，而作为文件中内容不会更改的头文件的内容也需要重新编译，造成不必要的开销。为了降低在编译过程中诸如此类不必要的开销，引入了预编译头的机制。 在编译过程中，stdafx.cpp和stdafx.h文件用于生成一个预编译头文件 project.pch和预编译类型文件stdafx.obj。 如前面提到的，stdafx.cpp存放的是#include “stdafx.h”。在第一次编译过程中，stdafx.cpp首先被编译处理，将头文件stdafx.h中包含的所有的头文件进行预编译，从而生成一个预编译头文件project.pch，在之后的编译过程中，只要stdafx.h没有被修改(时间戳没有发生改变)，则编译器可以直接使用预编译头文件project.pch的内容，而不需要重新编译stdafx.h。之后的每个包含有stdafx.h头文件的独立文件编译过程都会使用该pch文件中的内容，即一次集中编译头文件后，之后可重复使用。 实际上，生成预编译头文件同样是耗时的，但是在后续的修改编译过程中，只要没有修改stdafx.h和stdafx.cpp文件的内容，就不需要重新生成预编译头文件，也就避免了许多头文件处理的过程，从而大大减少了传统重复处理头文件的开销。相应的，由于预编译头文件包含有众多头文件的处理信息，故而其本身会占用较大的存储空间，故而可以注意清理不需要的预编译头。 一般来说，将被项目中多个独立文件引用的标准头文件和特定项目中一般不做修改的头文件放在stdafx.h中可以大大提升程序编译时的效率。 关于报错 在使用预编译头机制时，可能会遇到一些问题 1. 无法打开预编译头文件”xxx.pch”:no such file or directory 的问题 分析：根据上面的原理解释，可能是由于编译器无法通过stdafx.cpp创建一个预编译文件，从而其他文件没有办法去引用该pch文件。 解决方案：选中源文件stdafx.cpp，右键 -&gt; 属性 -&gt; C/C++ -&gt; 预编译头，出现上述问题一般是由于预编译头的选项从 创建 变为了 使用 ，通过将选项重新改为创建可解决问题。 2. 在查找预编译头文件时遇到意外的文件结尾 需要将指令#include”stdafx.h” 放在每个文件的开始位置，以供处理。 参考： https://www.cnblogs.com/yhjoker/p/8110684.html https://docs.microsoft.com/zh-cn/cpp/build/creating-precompiled-header-files?view=msvc-160","categories":[{"name":"tool","slug":"tool","permalink":"https://marblemm.gitee.io/categories/tool/"}],"tags":[]},{"title":"cpp类型转换","slug":"cpp类型转换","date":"2021-09-04T04:34:42.000Z","updated":"2021-09-05T15:21:15.464Z","comments":true,"path":"2021/09/04/cpp类型转换/","link":"","permalink":"https://marblemm.gitee.io/2021/09/04/cpp%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是： static_cast 用于良性转换，一般不会导致意外发生，风险很低。 const_cast 用于 const 与非 const、volatile 与非 volatile 之间的转换。 reinterpret_cast 高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。 dynamic_cast 借助 RTTI，用于类型安全的向下转型（Downcasting）。 static_cast详解：static_cast相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法： 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。 把空指针转换成目标类型的空指针。 把任何类型的表达式转换成void类型。注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性 基本类型数据转换举例如下：1234567891011char a = &#x27;a&#x27;;int b = static_cast&lt;char&gt;(a);//正确，将char型数据转换成int型数据double *c = new double;void *d = static_cast&lt;void*&gt;(c);//正确，将double指针转换成void指针int e = 10;const int f = static_cast&lt;const int&gt;(e);//正确，将int型数据转换成const int型数据const int g = 20;int *h = static_cast&lt;int*&gt;(&amp;g);//编译错误，static_cast不能转换掉g的const属性 类上行和下行转换：12345678910111213class Base&#123;&#125;;class Derived : public Base&#123;&#125;Base* pB = new Base();if(Derived* pD = static_cast&lt;Derived*&gt;(pB))&#123;&#125;//下行转换是不安全的(坚决抵制这种方法)Derived* pD = new Derived();if(Base* pB = static_cast&lt;Base*&gt;(pD))&#123;&#125;//上行转换是安全的 const_castconst限定符通常被用来限定变量，用于表示该变量的值不能被修改。 而const_cast则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。 用法：const_cast (expression) 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。 常量指针被转化成非常量指针，并且仍然指向原来的对象； 常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。 [例3]一个错误的例子： const int a = 10; const int * p = &amp;a; *p = 20; //compile error int b = const_cast&lt;int&gt;(a); //compile error 在本例中出现了两个编译错误，第一个编译错误是*p因为具有常量性，其值是不能被修改的；另一处错误是const_cast强制转换对象必须为指针或引用，而例3中为一个变量，这是不允许的！ 下面我们以 const 为例来说明 const_cast 的用法： 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; const int n = 100; int *p = const_cast&lt;int*&gt;(&amp;n); *p = 234; cout&lt;&lt;&quot;n = &quot;&lt;&lt;n&lt;&lt;endl; cout&lt;&lt;&quot;*p = &quot;&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 运行结果： n = 100 *p = 234 &amp;n用来获取 n 的地址，它的类型为const int *，必须使用 const_cast 转换为int *类型后才能赋值给 p。由于 p 指向了 n，并且 n 占用的是栈内存，有写入权限，所以可以通过 p 修改 n 的值。 有读者可能会问，为什么通过 n 和 *p 输出的值不一样呢？这是因为 C++ 对常量的处理更像是编译时期的#define，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100。换句话说，第 8 行代码被修改成了下面的形式： cout&lt;&lt;&quot;n = &quot;&lt;&lt;100&lt;&lt;endl; 这样以来，即使程序在运行期间修改 n 的值，也不会影响 cout 语句了 使用 const_cast 进行强制类型转换可以突破 C/C++ 的常数限制，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。 reinterpret_cast 关键字reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。 reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。 下面的代码代码演示了 reinterpret_cast 的使用： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class A&#123;public: A(int a = 0, int b = 0): m_a(a), m_b(b)&#123;&#125;private: int m_a; int m_b;&#125;;int main()&#123; //将 char* 转换为 float* char str[]=&quot;http://c.biancheng.net&quot;; float *p1 = reinterpret_cast&lt;float*&gt;(str); cout&lt;&lt;*p1&lt;&lt;endl; //将 int 转换为 int* int *p = reinterpret_cast&lt;int*&gt;(100); //将 A* 转换为 int* p = reinterpret_cast&lt;int*&gt;(new A(25, 96)); cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 运行结果： 3.0262e+29 25 可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将A转换为int，使用指针直接访问 private 成员刺穿了一个类的封装性，更好的办法是让类提供 get/set 函数，间接地访问成员变量。 dynamic_cast 关键字dynamic_cast 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。 （1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。 （2）不能用于内置的基本数据类型的强制转换。 （3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。 （4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。 B中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见&lt;Inside c++ object model&gt;）中， 只有定义了虚函数的类才有虚函数表。 （5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。 向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。 向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。 在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。 （1）指针类型举例，Base为包含至少一个虚函数的基类，Derived是Base的共有派生类，如果有一个指向Base的指针bp，我们可以在运行时将它转换成指向Derived的指针，代码如下： if(Derived *dp = dynamic_cast&lt;Derived *&gt;(bp))&#123; //使用dp指向的Derived对象 &#125; else&#123; //使用bp指向的Base对象 &#125; 值得注意的是，在上述代码中，if语句中定义了dp，这样做的好处是可以在一个操作中同时完成类型转换和条件检查两项任务。 （2）引用类型 因为不存在所谓空引用，所以引用类型的dynamic_cast转换与指针类型不同，在引用转换失败时，会抛出std::bad_cast异常，该异常定义在头文件typeinfo中。 void f(const Base &amp;b)&#123; try&#123; const Derived &amp;d = dynamic_cast&lt;const Base &amp;&gt;(b); //使用b引用的Derived对象 &#125; catch(std::bad_cast)&#123; //处理类型转换失败的情况 &#125; &#125; 转换注意事项： 尽量少使用转型操作，尤其是dynamic_cast，耗时较高，会导致性能的下降，尽量使用其他方法替代。","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]},{"title":"cpp类默认的八种函数","slug":"cpp类默认的八种函数","date":"2021-09-03T12:49:23.000Z","updated":"2021-09-11T14:49:24.858Z","comments":true,"path":"2021/09/03/cpp类默认的八种函数/","link":"","permalink":"https://marblemm.gitee.io/2021/09/03/cpp%E7%B1%BB%E9%BB%98%E8%AE%A4%E7%9A%84%E5%85%AB%E7%A7%8D%E5%87%BD%E6%95%B0/","excerpt":"","text":"c++类的默认八种函数在C++中，一个类有八个默认函数： 1、默认构造函数； 2、默认拷贝构造函数； 3、默认析构函数； 4、默认重载赋值运算符函数； 5、默认重载取址运算符函数； 6、默认重载取址运算符const函数； 7、默认移动构造函数（C++11）； 8、默认重载移动赋值操作符函数（C++11）。 只是声明一个空类，不做任何事情的话，编译器会自动为你生成一个默认构造函数、一个默认拷贝构造函数、一个默认重载赋值操作符函数和一个默认析构函数。这些函数只有在第一次被调用时，才会被编译器创建，当然这几个生成的默认函数的实现就是什么都不做。所有这些函数都是inline和public的。 我们不希望对象被显示构造（单列模式）或赋值，可以将对应函数声明为private，或者写一个基类，开放部分默认函数，子类去继承就可以了。C++11新增标识符default和delete,控制这些默认函数是否使用。 default：被标识的默认函数将使用类的默认行为，如：A() = default; delete：被标识的默认函数将禁用，如：A() = delete; override：被标识的函数需要强制重写基类虚函数； final：被标识的函数禁止重写基类虚函数； 123456789101112131415161718192021222324252627282930class A&#123;public: // 默认构造函数; A(); // 默认拷贝构造函数 A(const A&amp;); // 默认析构函数 ~A(); // 默认重载赋值运算符函数 A&amp; operator = (const A&amp;); // 默认重载取址运算符函数 A* operator &amp; (); // 默认重载取址运算符const函数 const A* operator &amp; () const; // 默认移动构造函数 A(A&amp;&amp;); // 默认重载移动赋值操作符 A&amp; operator = (const A&amp;&amp;);&#125;; 1、构造函数 1.构造函数作用是对对象进行初始化，在堆上new一个对象或在栈上定义一个临时对象时，会自动调用对象的构造函数。有初始化列表和构造函数体内赋值两种方式， 2.函数名与类名相同，可以重载，不能为虚函数，不能有返回值，连void也不行； 3.如果没有显式定义，编译器会自动生成一个默认的构造函数，默认的构造函什么都不会做； 4.无参构造函数和带有缺省值的构造函数（全缺省）都认为是缺省的构造函数，并且缺省的构造函数只能有一个； 5.函数体内可以使用this指针，但不可以用于初始化列表。因为构造函数只是初始化对象，初始化之前此对象已经存在了，所以可以有this，函数体里面是进行赋值，初始化列表是对类中的各个成员变量进行初始化，初始化的位置对象不完整，所以不能使用this用于初始化列表； 6.对于出现单参数的构造函数需要注意，C++会默认将参数对应的类型转换为该类类型，有时候这种隐式的转换是我们不想要的，需要使用explicit关键字来限制这种转换； 7.构造顺序：虚拟基类的构造函数（如果有多个虚拟基类，按照它们被继承的顺序构造，而不是它们在成员初始化列表中的顺序）；非虚拟基类的构造函函（如果有多个非虚拟基类，按照它们被继承的顺序构造，而不是它们在成员初始化列表中的顺序）；成员对象的构造函数（如果有多个成员类对象，按照它们声明的顺序调用，而不是它们在成员初始化列表中的顺序）；本类构造函数。构造的过程是递归的。 初始化列表构造函数除了有名字，参数列表和函数体之外，还可以有初始化列表，初始化列表以冒号开头，后跟一系列以逗号分隔的初始化字段。在C++中，struct和class的唯一区别是默认的访问性不同，而这里我们不考虑访问性的问题，所以下面的代码都以struct来演示。 struct foo &#123; string name ; int id ; foo(string s, int i):name(s), id(i)&#123;&#125; ; // 初始化列表 &#125;; 构造函数的两个执行阶段构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段。 初始化阶段 所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。 计算阶段 一般用于执行构造函数体内的赋值操作，下面的代码定义两个结构体，其中Test1有构造函数，拷贝构造函数及赋值运算符，为的是方便查看结果。Test2是个测试类，它以Test1的对象为成员，我们看一下Test2的构造函数是怎么样执行的。 12345678910111213141516171819202122232425262728293031struct Test1&#123; Test1() // 无参构造函数 &#123; cout &lt;&lt; &quot;Construct Test1&quot; &lt;&lt; endl ; &#125; Test1(const Test1&amp; t1) // 拷贝构造函数 &#123; cout &lt;&lt; &quot;Copy constructor for Test1&quot; &lt;&lt; endl ; this-&gt;a = t1.a ; &#125; Test1&amp; operator = (const Test1&amp; t1) // 赋值运算符 &#123; cout &lt;&lt; &quot;assignment for Test1&quot; &lt;&lt; endl ; this-&gt;a = t1.a ; return *this; &#125; int a ;&#125;;struct Test2&#123; Test1 test1 ; Test2(Test1 &amp;t1) &#123; test1 = t1 ; &#125;&#125;; 调用代码 Test1 t1 ; Test2 t2(t1) ; 输出 Construct Test1 Construct Test1 assignment for Test1 解释一下，第一行输出对应调用代码中第一行，构造一个Test1对象。第二行输出对应Test2构造函数中的代码，用默认的构造函数初始化对象test1，这就是所谓的初始化阶段。第三行输出对应Test1的赋值运算符，对test1执行赋值操作，这就是所谓的计算阶段。 为什么使用初始化列表初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。使用初始化列表主要是基于性能问题，对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，但是对于类类型来说，最好使用初始化列表，为什么呢？由上面的测试可知，使用初始化列表少了一次调用默认构造函数的过程，这对于数据密集型的类来说，是非常高效的。同样看上面的例子，我们使用初始化列表来实现Test2的构造函数 struct Test2 &#123; Test1 test1 ; Test2(Test1 &amp;t1):test1(t1)&#123;&#125; &#125; 使用同样的调用代码，输出结果如下。 Construct Test1 Copy constructor for Test1 第一行输出对应 调用代码的第一行。第二行输出对应Test2的初始化列表，直接调用拷贝构造函数初始化test1，省去了调用默认构造函数的过程。所以一个好的原则是，能使用初始化列表的时候尽量使用初始化列表。 哪些东西必须放在初始化列表中除了性能问题之外，有些时场合初始化列表是不可或缺的，以下几种情况时必须使用初始化列表 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。对于没有默认构造函数的类，我们看一个例子。 1234567891011121314struct Test1&#123; Test1(int a):i(a)&#123;&#125; int i ;&#125;;struct Test2&#123; Test1 test1 ; Test2(Test1 &amp;t1) &#123; test1 = t1 ; &#125;&#125;; 以上代码无法通过编译，因为Test2类中Test1 test1;需要调用默认的构造函数，但是Test1类没有无参的构造函数，但是由于Test1没有默认的构造函数，故而编译错误。正确的代码如下，使用初始化列表代替赋值操作。 struct Test2 &#123; Test1 test1 ; Test2(Test1 &amp;t1):test1(t1)&#123;&#125; &#125; 成员变量的初始化顺序成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的，看代码。 struct foo &#123; int i ; int j ; foo(int x):i(x), j(i)&#123;&#125;; // ok, 先初始化i，后初始化j &#125;; 再看下面的代码 struct foo &#123; int i ; int j ; foo(int x):j(x), i(j)&#123;&#125; // i值未定义 &#125;; 这里i的值是未定义的，虽然j在初始化列表里面出现在i前面，但是i先于j定义，所以先初始化i，但i由j初始化，此时j尚未初始化，所以导致i的值未定义。所以，一个好的习惯是，按照成员定义的顺序进行初始化。 2、拷贝构造函数（Copy Constructor） 1.拷贝构造函数实际上是构造函数的重载，具有一般构造函数的所有特性，用此类已有的对象创建一个新的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中。用类的一个已知的对象去初始化该类的另一个对象时，会自动调用对象的拷贝构造函数； 2.函数名与类名相同，第一个参数是对某个同类对象的引用，且没有其他参数或其他参数都有默认值，返回值是类对象的引用，通过返回引用值可以实现连续构造，即类似A(B©)这样； 3.如果没有显式定义，编译器会自动生成一个默认的拷贝构造函数，默认的拷贝构造函数会依次拷贝类的数据成员完成初始化； 4.浅拷贝和深拷贝：编译器创建的默认拷贝构造函数只会执行”浅拷贝”，也就是通过赋值完成，如果该类的数据成员中有指针成员，也只是地址的拷贝，会使得新的对象与拷贝对象该指针成员指向的地址相同，delete该指针时则会导致两次重复delete而出错，如果指针成员是new出来就是“深拷贝”。 使用场景 使用已存在的对象创建新的对象 CDate d1(1990, 1, 1); CDate d2(d1); 传值方式作为函数的参数 void FunTest(const CDate date) &#123;&#125; 传值方式作为函数的返回值 CDate FunTest() &#123; CDate date; return date; &#125; 3、析构函数（Destructor） 1.析构函数作用并不是删除对象，而是做一些清理工作，delete一个对象或对象生命周期结束时，会自动调用对象的析构函数； 2.函数名在类名前加上字符~，没有参数（可以有void类型的参数），也没有返回值，可以为虚函数（通过基类的指针去析构子类对象时候），不能重载，故析构函数只有一个； 3.如果没有显式定义，编译器会自动生成一个默认的析构函数，默认的析构函什么都不会做； 4.析构顺序：和构造函数顺序相反。析构的过程也是递归的。 4、重载赋值运算符函数（Copy Assignment operator） 1.它是两个已有对象，一个给另一个赋值的过程。当两个对象之间进行赋值时，会自动调用重载赋值运算符函数，它不同于拷贝构造函数，拷贝构造函数是用已有对象给新生成的对象赋初值的过程； 2.赋值运算符重载函数参数中const和&amp;没有强制要求，返回值是类对象的引用，通过返回引用值可以实现连续赋值，即类似a=b=c这样，返回值类型也不是强制的，可以返回void，使用时就不能连续赋值； 3.赋值运算符重载函只能定义为类的成员函数，不能是静态成员函数，也不能是友元函数，赋值运算符重载函数不能被继承，要避免自赋值； 4.如果没有显式定义，编译器会自动生成一个默认的赋值运算符重载函数，默认的赋值运算符重载函数实现将数据成员逐一赋值的一种浅拷贝，会导致指针悬挂问题。 5、重载取址运算符（const）函数 1.重载取址运算符函数没有参数； 2.如果没有显式定义，编译器会自动生成默认的重载取址运算符函数，函数内部直接return this，一般使用默认即可。 6、移动构造函数和重载移动赋值操作符函数 1.C++11 新增move语义：源对象资源的控制权全部交给目标对象，可以将原对象移动到新对象， 用于a初始化b后，就将a析构的情况； 2.移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用； 3.临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候就可以使用移动构造。移动构造可以减少不必要的复制，带来性能上的提升。 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#define _CRT_SECURE_NO_WARNINGS#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;string&gt;class MyClass&#123;public: MyClass(const char * str = nullptr); // 默认带参构造函数 // 默认构造函数指不带参数或者所有参数都有缺省值的构造函数 ~MyClass(void); // 默认析构函数 MyClass(const MyClass &amp;); // 默认拷贝构造函数 MyClass &amp; operator =(const MyClass &amp;); // 默认重载赋值运算符函数 MyClass * operator &amp;(); // 默认重载取址运算符函数 MyClass const * operator &amp;() const; // 默认重载取址运算符const函数 MyClass(MyClass &amp;&amp;); // 默认移动构造函数 MyClass &amp; operator =(MyClass &amp;&amp;); // 默认重载移动赋值操作符函数private: char *m_pData;&#125;;// 默认带参构造函数MyClass::MyClass(const char * str)&#123; if (!str) &#123; m_pData = nullptr; &#125; else &#123; this-&gt;m_pData = new char[strlen(str) + 1]; strcpy(this-&gt;m_pData, str); &#125; std::cout &lt;&lt; &quot;默认带参构造函数&quot; &lt;&lt; &quot; this addr: &quot; &lt;&lt; this &lt;&lt; std::endl;&#125; // 默认析构函数MyClass::~MyClass(void)&#123; if (this-&gt;m_pData) &#123; delete[] this-&gt;m_pData; this-&gt;m_pData = nullptr; &#125; std::cout &lt;&lt; &quot;默认析构函数&quot; &lt;&lt; &quot; this addr: &quot; &lt;&lt; this &lt;&lt; std::endl;&#125;// 默认拷贝构造函数MyClass::MyClass(const MyClass &amp;m)&#123; if (!m.m_pData) &#123; this-&gt;m_pData = nullptr; &#125; else &#123; this-&gt;m_pData = new char[strlen(m.m_pData) + 1]; strcpy(this-&gt;m_pData, m.m_pData); &#125; std::cout &lt;&lt; &quot;默认拷贝构造函数&quot; &lt;&lt; &quot; this addr: &quot; &lt;&lt; this &lt;&lt; std::endl;&#125;// 默认重载赋值运算符函数MyClass &amp; MyClass::operator =(const MyClass &amp;m)&#123; if ( this == &amp;m ) &#123; return *this; &#125; delete[] this-&gt;m_pData; if (!m.m_pData) &#123; this-&gt;m_pData = nullptr; &#125; else &#123; this-&gt;m_pData = new char[strlen(m.m_pData) + 1]; strcpy(this-&gt;m_pData, m.m_pData); &#125; std::cout &lt;&lt; &quot;默认重载赋值运算符函数&quot; &lt;&lt; &quot; this addr: &quot; &lt;&lt; this &lt;&lt; std::endl; return *this;&#125;// 默认重载取址运算符函数MyClass * MyClass::operator &amp;()&#123; std::cout &lt;&lt; &quot;默认重载取址运算符函数&quot; &lt;&lt; &quot; this addr: &quot; &lt;&lt; this &lt;&lt; std::endl; return this;&#125;// 默认重载取址运算符const函数MyClass const * MyClass::operator &amp;() const&#123; std::cout &lt;&lt; &quot;默认重载取址运算符const函数&quot; &lt;&lt; &quot; this addr: &quot; &lt;&lt; this &lt;&lt; std::endl; return this;&#125;// 默认移动构造函数MyClass::MyClass(MyClass &amp;&amp; m): m_pData(std::move(m.m_pData))&#123; std::cout &lt;&lt; &quot;默认移动构造函数&quot; &lt;&lt; std::endl; m.m_pData = nullptr;&#125;// 默认重载移动赋值操作符函数MyClass &amp; MyClass::operator =(MyClass &amp;&amp; m)&#123; if ( this == &amp;m ) &#123; return *this; &#125; this-&gt;m_pData = nullptr; this-&gt;m_pData = std::move(m.m_pData); m.m_pData = nullptr; std::cout &lt;&lt; &quot;默认重载移动赋值操作符函数&quot; &lt;&lt; &quot; this addr: &quot; &lt;&lt; this &lt;&lt; std::endl; return *this;&#125;void funA(MyClass a)&#123; std::cout &lt;&lt; &quot;调用funA函数&quot; &lt;&lt; &quot; param addr: &quot; &lt;&lt; &amp;a &lt;&lt; std::endl;&#125;void mytest1(void)&#123; std::cout &lt;&lt; &quot;mytest1 &gt;&gt;&gt;&gt;&quot; &lt;&lt; std::endl; MyClass myclass1; // 等价于 MyClass myclass1 = MyClass(); // 调用默认带参构造函数 myclass1 = MyClass(); // MyClass()为右值，需要右值引用 // 先调用默认带参构造函数，然后调用默认重载取址运算符函数，最后调用默认重载移动赋值操作符函数 std::cout &lt;&lt; &quot;&lt;&lt;&lt;&lt;&lt; mytest1&quot; &lt;&lt; std::endl; // 析构两次 1: myclass1 = MyClass()中的MyClass() 2: MyClass myclass1&#125;void mytest2(void)&#123; std::cout &lt;&lt; &quot;mytest2 &gt;&gt;&gt;&gt;&quot; &lt;&lt; std::endl; MyClass myclass1; // 等价于 MyClass myclass1 = MyClass(); // 调用默认带参构造函数 MyClass myclass2(myclass1); // 调用默认拷贝构造函数 myclass2 = myclass1; // myclass2为左值，所以此操作为赋值操作，会调用默认重载取址运算符const函数，然后调用默认重载赋值运算符函数 funA(myclass1); // 参数传值会导致赋值操作，会调用默认拷贝构造函数，然后funA函数调用默认重载取址运算符函数取得参数 funA(std::move(myclass1)); // funA函数的参数现为右值，会调用默认移动构造函数，然后funA函数调用默认重载取址运算符函数取得参数 // 在移动构造函数中对于基本类型所谓移动只是把其值拷贝，对于如string这类类成员来说才会真正的所谓资源移动 std::cout &lt;&lt; &quot;&lt;&lt;&lt;&lt;&lt; mytest2&quot; &lt;&lt; std::endl;&#125;void mytest3(void)&#123; std::cout &lt;&lt; &quot;mytest3 &gt;&gt;&gt;&gt;&quot; &lt;&lt; std::endl; funA(MyClass()); // 会调用默认带参构造函数，生成该类的对象，然后funA函数调用默认重载取址运算符函数取得参数 std::cout &lt;&lt; &quot;&lt;&lt;&lt;&lt;&lt; mytest3&quot; &lt;&lt; std::endl; // 析构一次 1: funA(MyClass())中的MyClass()形成的对象，是在funA函数结束调用的时候，调用默认析构函数&#125;void mytest(void)&#123; std::cout &lt;&lt; &quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot; &lt;&lt; std::endl; mytest1(); mytest2(); mytest3(); std::cout &lt;&lt; &quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot; &lt;&lt; std::endl;&#125;int main(int argc, char * argv[], char * envp[])&#123; mytest(); system(&quot;pause&quot;); return 0;&#125; 输出结果： &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; mytest1 &gt;&gt;&gt;&gt; 默认带参构造函数 this addr: 000000225173F8B8 默认带参构造函数 this addr: 000000225173F8C8 默认重载取址运算符函数 this addr: 000000225173F8C8 默认重载移动赋值操作符函数 this addr: 000000225173F8B8 默认析构函数 this addr: 000000225173F8C8 &lt;&lt;&lt;&lt;&lt; mytest1 默认析构函数 this addr: 000000225173F8B8 mytest2 &gt;&gt;&gt;&gt; 默认带参构造函数 this addr: 000000225173F878 默认拷贝构造函数 this addr: 000000225173F898 默认重载取址运算符const函数 this addr: 000000225173F878 默认重载赋值运算符函数 this addr: 000000225173F898 默认拷贝构造函数 this addr: 000000225173F8A8 默认重载取址运算符函数 this addr: 000000225173F8A8 调用funA函数 param addr: 000000225173F8A8 默认析构函数 this addr: 000000225173F8A8 默认移动构造函数 默认重载取址运算符函数 this addr: 000000225173F8B8 调用funA函数 param addr: 000000225173F8B8 默认析构函数 this addr: 000000225173F8B8 &lt;&lt;&lt;&lt;&lt; mytest2 默认析构函数 this addr: 000000225173F898 默认析构函数 this addr: 000000225173F878 mytest3 &gt;&gt;&gt;&gt; 默认带参构造函数 this addr: 000000225173F8C0 默认重载取址运算符函数 this addr: 000000225173F8C0 调用funA函数 param addr: 000000225173F8C0 默认析构函数 this addr: 000000225173F8C0 &lt;&lt;&lt;&lt;&lt; mytest3 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 请按任意键继续. . . 参考： https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html https://blog.csdn.net/JMW1407/article/details/108785842 https://blog.csdn.net/cherrydreamsover/article/details/81949668 http://c.biancheng.net/view/7847.html","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]},{"title":"cpp智能指针总结","slug":"cpp智能指针总结","date":"2021-09-02T15:03:19.000Z","updated":"2021-09-02T15:21:20.800Z","comments":true,"path":"2021/09/02/cpp智能指针总结/","link":"","permalink":"https://marblemm.gitee.io/2021/09/02/cpp%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"智能指针背后的设计思想我们先来看一个简单的例子： 12345678910void remodel(std::string &amp; str)&#123; std::string * ps = new std::string(str); ... if (weird_thing()) throw exception(); str = *ps; delete ps; return;&#125; 当出现异常时（weird_thing()返回true），delete将不被执行，因此将导致内存泄露。 如何避免这种问题？有人会说，这还不简单，直接在throw exception();之前加上delete ps;不就行了。是的，你本应如此，问题是很多人都会忘记在适当的地方加上delete语句（连上述代码中最后的那句delete语句也会有很多人忘记吧），如果你要对一个庞大的工程进行review，看是否有这种潜在的内存泄露问题，那就是一场灾难！这时我们会想：当remodel这样的函数终止（不管是正常终止，还是由于出现了异常而终止），本地变量都将自动从栈内存中删除—因此指针ps占据的内存将被释放，如果ps指向的内存也被自动释放，那该有多好啊。我们知道析构函数有这个功能。如果ps有一个析构函数，该析构函数将在ps过期时自动释放它指向的内存。但ps的问题在于，它只是一个常规指针，不是有析构凼数的类对象指针。如果它指向的是对象，则可以在对象过期时，让它的析构函数删除指向的内存。 这正是 auto_ptr、unique_ptr和shared_ptr这几个智能指针背后的设计思想。我简单的总结下就是：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。 因此，要转换remodel()函数，应按下面3个步骤进行： 包含头文件memory（智能指针所在的头文件）； 将指向string的指针替换为指向string的智能指针对象； 删除delete语句。 下面是使用auto_ptr修改该函数的结果： 1234567891011# include &lt;memory&gt;void remodel (std::string &amp; str)&#123; std::auto_ptr&lt;std::string&gt; ps (new std::string(str))； ... if (weird_thing ()) throw exception()； str = *ps； // delete ps； NO LONGER NEEDED return;&#125; 2. C++智能指针简单介绍STL一共给我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr和weak_ptr（本文章暂不讨论）。模板auto_ptr是C++98提供的解决方案，C+11已将将其摒弃，并提供了另外两种解决方案。然而，虽然auto_ptr被摒弃，但它已使用了好多年：同时，如果您的编译器不支持其他两种解决力案，auto_ptr将是唯一的选择。 使用注意点 所有的智能指针类都有一个explicit构造函数，以指针作为参数。比如auto_ptr的类模板原型为： templet&lt;class T&gt; class auto_ptr &#123; explicit auto_ptr(X* p = 0) ; ... &#125;; 因此不能自动将指针转换为智能指针对象，必须显式调用： shared_ptr&lt;double&gt; pd; double *p_reg = new double; pd = p_reg; // not allowed (implicit conversion) pd = shared_ptr&lt;double&gt;(p_reg); // allowed (explicit conversion) shared_ptr&lt;double&gt; pshared = p_reg; // not allowed (implicit conversion) shared_ptr&lt;double&gt; pshared(p_reg); // allowed (explicit conversion) 对全部三种智能指针都应避免的一点： string vacation(&quot;I wandered lonely as a cloud.&quot;); shared_ptr&lt;string&gt; pvac(&amp;vacation); // No pvac过期时，程序将把delete运算符用于非堆内存，这是错误的。 使用举例 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;class report&#123;private: std::string str;public: report(const std::string s) : str(s) &#123; std::cout &lt;&lt; &quot;Object created.\\n&quot;; &#125; ~report() &#123; std::cout &lt;&lt; &quot;Object deleted.\\n&quot;; &#125; void comment() const &#123; std::cout &lt;&lt; str &lt;&lt; &quot;\\n&quot;; &#125;&#125;;int main() &#123; &#123; std::auto_ptr&lt;report&gt; ps(new report(&quot;using auto ptr&quot;)); ps-&gt;comment(); &#125; &#123; std::shared_ptr&lt;report&gt; ps(new report(&quot;using shared ptr&quot;)); ps-&gt;comment(); &#125; &#123; std::unique_ptr&lt;report&gt; ps(new report(&quot;using unique ptr&quot;)); ps-&gt;comment(); &#125; return 0;&#125; 3. 为什么摒弃auto_ptr？先来看下面的赋值语句: auto_ptr&lt; string&gt; ps (new string (&quot;I reigned lonely as a cloud.”）; auto_ptr&lt;string&gt; vocation; vocaticn = ps; 上述赋值语句将完成什么工作呢？如果ps和vocation是常规指针，则两个指针将指向同一个string对象。这是不能接受的，因为程序将试图删除同一个对象两次——一次是ps过期时，另一次是vocation过期时。要避免这种问题，方法有多种： 定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。 建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和uniqiie_ptr 的策略，但unique_ptr的策略更严格。 创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。 当然，同样的策略也适用于复制构造函数。每种方法都有其用途，但为何说要摒弃auto_ptr呢？下面举个例子来说明。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;int main() &#123; auto_ptr&lt;string&gt; films[5] = &#123; auto_ptr&lt;string&gt; (new string(&quot;Fowl Balls&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Duck Walks&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Chicken Runs&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Turkey Errors&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Goose Eggs&quot;)) &#125;; auto_ptr&lt;string&gt; pwin; pwin = films[2]; // films[2] loses ownership. 将所有权从films[2]转让给pwin，此时films[2]不再引用该字符串从而变成空指针 cout &lt;&lt; &quot;The nominees for best avian baseballl film are\\n&quot;; for(int i = 0; i &lt; 5; ++i) cout &lt;&lt; *films[i] &lt;&lt; endl; cout &lt;&lt; &quot;The winner is &quot; &lt;&lt; *pwin &lt;&lt; endl; cin.get(); return 0;&#125; 运行下发现程序崩溃了，原因在上面注释已经说的很清楚，films[2]已经是空指针了，下面输出访问空指针当然会崩溃了。但这里如果把auto_ptr换成shared_ptr或unique_ptr后，程序就不会崩溃，原因如下： 使用shared_ptr时运行正常，因为shared_ptr采用引用计数，pwin和films[2]都指向同一块内存，在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。 使用unique_ptr时编译出错，与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，而在编译器因下述代码行出现错误： unique_ptr pwin; pwin = films[2]; // films[2] loses ownership.指导你发现潜在的内存错误。这就是为何要摒弃auto_ptr的原因，一句话总结就是：避免潜在的内存崩溃问题。 4. unique_ptr为何优于auto_ptr？可能大家认为前面的例子已经说明了unique_ptr为何优于auto_ptr，也就是安全问题，下面再叙述的清晰一点。请看下面的语句: auto_ptr&lt;string&gt; p1(new string (&quot;auto&quot;) ； //#1 auto_ptr&lt;string&gt; p2; //#2 p2 = p1; //#3 在语句#3中，p2接管string对象的所有权后，p1的所有权将被剥夺。前面说过，这是好事，可防止p1和p2的析构函数试图刪同—个对象； 但如果程序随后试图使用p1，这将是件坏事，因为p1不再指向有效的数据。 下面来看使用unique_ptr的情况： unique_ptr&lt;string&gt; p3 (new string (&quot;auto&quot;); //#4 unique_ptr&lt;string&gt; p4； //#5 p4 = p3; //#6 编译器认为语句#6非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。 但unique_ptr还有更聪明的地方。有时候，会将一个智能指针赋给另一个并不会留下危险的悬挂指针。假设有如下函数定义： unique_ptr&lt;string&gt; demo(const char * s) &#123; unique_ptr&lt;string&gt; temp (new string (s))； return temp； &#125; 并假设编写了如下代码： unique_ptr&lt;string&gt; ps; ps = demo(&#39;Uniquely special&quot;)； demo()返回一个临时unique_ptr，然后ps接管了原本归返回的unique_ptr所有的对象，而返回时临时的 unique_ptr 被销毁，也就是说没有机会使用 unique_ptr 来访问无效的数据，换句话来说，这种赋值是不会出现任何问题的，即没有理由禁止这种赋值。实际上，编译器确实允许这种赋值，这正是unique_ptr更聪明的地方。 总之，党程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如： unique_ptr&lt;string&gt; pu1(new string (&quot;hello world&quot;)); unique_ptr&lt;string&gt; pu2; pu2 = pu1; // #1 not allowed unique_ptr&lt;string&gt; pu3; pu3 = unique_ptr&lt;string&gt;(new string (&quot;You&quot;)); // #2 allowed 其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。 当然，您可能确实想执行类似于#1的操作，仅当以非智能的方式使用摒弃的智能指针时（如解除引用时），这种赋值才不安全。要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。下面是一个使用前述demo()函数的例子，该函数返回一个unique_ptr对象： 使用move后，原来的指针仍转让所有权变成空指针，可以对其重新赋值。 unique_ptr&lt;string&gt; ps1, ps2; ps1 = demo(&quot;hello&quot;); ps2 = move(ps1); ps1 = demo(&quot;alexia&quot;); cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl; 5. 如何选择智能指针？在掌握了这几种智能指针后，大家可能会想另一个问题：在实际应用中，应使用哪种智能指针呢？下面给出几个使用指南。 （1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括： 有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；两个对象包含都指向第三个对象的指针；STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。 （2）如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr存储到STL容器在那个，只要不调用将一个unique_ptr复制或赋给另一个算法（如sort()）。例如，可在程序中使用类似于下面的代码段。 123456789101112131415161718unique_ptr&lt;int&gt; make_int(int n)&#123; return unique_ptr&lt;int&gt;(new int(n));&#125;void show(unique_ptr&lt;int&gt; &amp;p1)&#123; cout &lt;&lt; *a &lt;&lt; &#x27; &#x27;;&#125;int main()&#123; ... vector&lt;unique_ptr&lt;int&gt; &gt; vp(size); for(int i = 0; i &lt; vp.size(); i++) vp[i] = make_int(rand() % 1000); // copy temporary unique_ptr vp.push_back(make_int(rand() % 1000)); // ok because arg is temporary for_each(vp.begin(), vp.end(), show); // use for_each() ...&#125; 其中push_back调用没有问题，因为它返回一个临时unique_ptr，该unique_ptr被赋给vp中的一个unique_ptr。另外，如果按值而不是按引用给show()传递对象，for_each()将非法，因为这将导致使用一个来自vp的非临时unique_ptr初始化pi，而这是不允许的。前面说过，编译器将发现错误使用unique_ptr的企图。 在unique_ptr为右值时，可将其赋给shared_ptr，这与将一个unique_ptr赋给一个需要满足的条件相同。与前面一样，在下面的代码中，make_int()的返回类型为unique_ptr： unique_ptr&lt;int&gt; pup(make_int(rand() % 1000)); // ok shared_ptr&lt;int&gt; spp(pup); // not allowed, pup as lvalue shared_ptr&lt;int&gt; spr(make_int(rand() % 1000)); // ok 模板shared_ptr包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr。shared_ptr将接管原来归unique_ptr所有的对象。 在满足unique_ptr要求的条件时，也可使用auto_ptr，但unique_ptr是更好的选择。如果你的编译器没有unique_ptr，可考虑使用Boost库提供的scoped_ptr，它与unique_ptr类似。 参考： https://www.cnblogs.com/lanxuezaipiao/p/4132096.html","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]},{"title":"cpp关键字explicit","slug":"cpp关键字explicit","date":"2021-08-31T14:48:32.000Z","updated":"2021-08-31T15:37:11.253Z","comments":true,"path":"2021/08/31/cpp关键字explicit/","link":"","permalink":"https://marblemm.gitee.io/2021/08/31/cpp%E5%85%B3%E9%94%AE%E5%AD%97explicit/","excerpt":"","text":"首先, C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式). 那么显示声明的构造函数和隐式声明的有什么区别呢? 我们来看下面的例子: 1234567891011121314151617181920212223242526272829303132class CxString // 没有使用explicit关键字的类声明, 即默认为隐式声明 &#123; public: char *_pstr; int _size; CxString(int size) &#123; _size = size; // string的预设大小 _pstr = malloc(size + 1); // 分配string的内存 memset(_pstr, 0, size + 1); &#125; CxString(const char *p) &#123; int size = strlen(p); _pstr = malloc(size + 1); // 分配string的内存 strcpy(_pstr, p); // 复制字符串 _size = strlen(_pstr); &#125; // 析构函数这里不讨论, 省略... &#125;; // 下面是调用: CxString string1(24); // 这样是OK的, 为CxString预分配24字节的大小的内存 CxString string2 = 10; // 这样是OK的, 为CxString预分配10字节的大小的内存 CxString string3; // 这样是不行的, 因为没有默认构造函数, 错误为: “CxString”: 没有合适的默认构造函数可用 CxString string4(&quot;aaaa&quot;); // 这样是OK的 CxString string5 = &quot;bbb&quot;; // 这样也是OK的, 调用的是CxString(const char *p) CxString string6 = &#x27;c&#x27;; // 这样也是OK的, 其实调用的是CxString(int size), 且size等于&#x27;c&#x27;的ascii码 string1 = 2; // 这样也是OK的, 为CxString预分配2字节的大小的内存 string2 = 3; // 这样也是OK的, 为CxString预分配3字节的大小的内存 string3 = string1; // 这样也是OK的, 至少编译是没问题的, 但是如果析构函数里用free释放_pstr内存指针的时候可能会报错, 完整的代码必须重载运算符&quot;=&quot;, 并在其中处理内存释放 上面的代码中, “CxString string2 = 10;” 这句为什么是可以的呢? 在C++中, 如果的构造函数只有一个参数时, 那么在编译的时候就会有一个缺省的转换操作:将该构造函数对应数据类型的数据转换为该类对象. 也就是说 “CxString string2 = 10;” 这段代码, 编译器自动将整型转换为CxString类对象, 实际上等同于下面的操作: 1234CxString string2(10); 或 CxString temp(10); CxString string2 = temp; 但是, 上面的代码中的_size代表的是字符串内存分配的大小, 那么调用的第二句 “CxString string2 = 10;” 和第六句 “CxString string6 = ‘c’;” 就显得不伦不类, 而且容易让人疑惑. 有什么办法阻止这种用法呢? 答案就是使用explicit关键字. 我们把上面的代码修改一下, 如下: 123456789101112131415161718192021222324252627class CxString // 使用关键字explicit的类声明, 显示转换 &#123; public: char *_pstr; int _size; explicit CxString(int size) &#123; _size = size; // 代码同上, 省略... &#125; CxString(const char *p) &#123; // 代码同上, 省略... &#125; &#125;; // 下面是调用: CxString string1(24); // 这样是OK的 CxString string2 = 10; // 这样是不行的, 因为explicit关键字取消了隐式转换 CxString string3; // 这样是不行的, 因为没有默认构造函数 CxString string4(&quot;aaaa&quot;); // 这样是OK的 CxString string5 = &quot;bbb&quot;; // 这样也是OK的, 调用的是CxString(const char *p) CxString string6 = &#x27;c&#x27;; // 这样是不行的, 其实调用的是CxString(int size), 且size等于&#x27;c&#x27;的ascii码, 但explicit关键字取消了隐式转换 string1 = 2; // 这样也是不行的, 因为取消了隐式转换 string2 = 3; // 这样也是不行的, 因为取消了隐式转换 string3 = string1; // 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符&quot;=&quot;的重载 explicit关键字的作用就是防止类构造函数的隐式自动转换. 上面也已经说过了, explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了. 例如: 12345678910111213141516171819class CxString // explicit关键字在类构造函数参数大于或等于两个时无效 &#123; public: char *_pstr; int _age; int _size; explicit CxString(int age, int size) &#123; _age = age; _size = size; // 代码同上, 省略... &#125; CxString(const char *p) &#123; // 代码同上, 省略... &#125; &#125;; // 这个时候有没有explicit关键字都是一样的 但是, 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数, 例子如下: 12345678910111213141516171819202122232425class CxString // 使用关键字explicit声明 &#123; public: int _age; int _size; explicit CxString(int age, int size = 0) &#123; _age = age; _size = size; // 代码同上, 省略... &#125; CxString(const char *p) &#123; // 代码同上, 省略... &#125; &#125;; // 下面是调用: CxString string1(24); // 这样是OK的 CxString string2 = 10; // 这样是不行的, 因为explicit关键字取消了隐式转换 CxString string3; // 这样是不行的, 因为没有默认构造函数 string1 = 2; // 这样也是不行的, 因为取消了隐式转换 string2 = 3; // 这样也是不行的, 因为取消了隐式转换 string3 = string1; // 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符&quot;=&quot;的重载 总结： explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。 google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。 effective c++中说：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。 参考： https://www.cnblogs.com/rednodel/p/9299251.html","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]},{"title":"字符串BSTR","slug":"字符串BSTR","date":"2021-08-29T15:57:04.000Z","updated":"2021-08-30T11:15:41.239Z","comments":true,"path":"2021/08/29/字符串BSTR/","link":"","permalink":"https://marblemm.gitee.io/2021/08/29/%E5%AD%97%E7%AC%A6%E4%B8%B2BSTR/","excerpt":"","text":"BSTR为什么需要BSTR COM是一种跨编程语言的平台，需要提供语言无关的数据类型。多数编程语言有自己的字符串表示。 C++ 字符串是以0结束的ASCII或Unicode字符数组。 Visual Basic字符串是一个ASCII字符数组加上表示长度的前缀。 Java字符串是以0结束的Unicode字符数组。 需要定义一种通用的字符串类型，可以很容易的匹配到不同编程语言。在C++中，就是BSTR。 什么是BSTR BSTR是“Basic STRing”的简称，微软在COM/OLE中定义的标准字符串数据类型。 对于C++，Windows头文件wtypes.h中定义如下： typedef wchar_t WCHAR; typedef WCHAR OLECHAR; typedef OLECHAR __RPC_FAR *BSTR;; 使用以Null结尾的简单字符串在COM component间传递不太方便。因此，标准BSTR是一个有长度前缀和null结束符的OLECHAR数组。BSTR的前4字节是一个表示字符串长度的前缀。BSTR长度域的值是字符串的字节数，并且不包括0结束符。 由于是Unicode串，所以字符数是字节数的一半。这种方式的优点是允许程序员在BSTR串中间嵌入NULL字符。但是，BSTR的前四个字节表示长度，而OLECHAR数组的前四字节表示前两个字符。这种情况下，对于C++程序，如何实现BSTR和OLECHAR的交换？答案是COM提供了两个BSTR分配用的API：SysAllocString / SysReallocString。函数返回的指针指向BSTR的第一个字符，而不是BSTR在内存的第一个字节。 BSTR的特殊性BSTR字符串可以内嵌零个或多个NULL，因为决定其长度的不是NULL，而是其前缀保存的数值，所以不能以NULL来判断字符串的结束。； 必须用SysAllocString()和SysFreeString（）函数族来分配和释放，用SysStringLen()等取得字符串的长度； BSTR相关函数族内存分配和重分配函数 SysAllocString SysAllocStringLen SysAllocStringByteLen SysReAllocString SysReAllocStringLen 注：通过以上函数分配空间的同时将根据字符串实际占用的字节数填写前缀 字符串释放函数 SysFreeString 注：这个函数的参数可以传入NULL，即在调用此函数时可以不用判断参数是否为NULL 字符串（占用空间）长度函数 SysStringLen SysStringByteLen 如何避免BSTR造成的内存泄漏 对于BSTR的管理（申请、释放和计算长度）严格使用上述对应的函数族，不要使用new、delete、CoTaskMemAlloc、CoTaskMemFree、sizeof 等。 不要在BSTR字符串中嵌入NULL 定义BSTR时要赋初值NULL BSTR bstr = NULL; 调用SysFreeString后要给bstr赋NULL SysFreeString(bstr)； bstr = NULL; 不要给BSTR直接初始化字符串 BSTR bstr = L“kkkkkk”;//BSTR bstr = SysAllocString (L“kkkkkk”); 因为直接初始化字符串时前缀的值可能是一个随机数，这样的话，其他地方使用这个BSTR时将无法决定出字符串的长度，特别在跨进程传送数据时将会出现致命错误。 在给一个BSTR赋值前，如果不能确定它目前是否指向一个有效的空间，最好先调一下SysFreeString，如： SysFreeString（bstr）; bstr = SysAllocString(L“kkkkkk”); 不要将一个BSTR通过“=”赋给另一个BSTR bstr1 = bstr2;//bstr1 = SysAllocString(bstr2); 避免调用SysFreeString（bstr1）和SysFreeString（bstr2）对同一块内存空间释放两次。 参数为[out]的BSTR注意点比如函数GetBSTR([out] BSTR* bstr) 对于客户端 BSTR bstr = NULL；// 传入的bstr必须为NULL GetBSTR(&amp;bstr); 。。。。。。 SysFreeString（bstr）；// 使用完bstr后别忘了释放 bstr = NULL; 对于服务端 HRESULT GetBSTR(BSTR* bstr) &#123; // 一般来说，传入的bstr不指向任何空间应该由客户端保证的，所以下面的判断和释放不是必须的，但有的话可能更安全。 if ( NULL != *bstr ) SysFreeString（*bstr）； // 创建成员变量的拷贝，不要将其值直接给出去（特别对于进程内组件） *bstr = m_bstr;// *bstr = SysAllocString( m_str ); &#125; 参数为[in]的BSTR注意点HRESULT SetBSTR(/*[in]*/ BSTR bstr)&#123; // 如果服务器需要保存传入的bstr供以后使用，必须将成员变量释放，然后重新分配。 SysFreeString(m_bstr); m_bstr = bstr; // m_bstr = SysAllocString( bstr ); &#125; 参数为[out]的数据结构中包含BSTR的注意点typedef struct kk&#123; long i; BSTR bstr; &#125; KK; KK param; param.bstr = NULL; GetKK(&amp;param); 。。。。。。 SysFreeString（param .bstr）；// 这种内嵌在结构体内的BSTR非常容易忽略释放 param .bstr = NULL; BSTR作为SysAllocString或SysReAllocString的参数时的注意点如果bstr作为SysAllocString或SysReAllocString的参数传入，并且不确定这个传入的bstr是否包含内嵌NULL时，为保险起见，请务必改用下面两函数。 SysAllocStringLen SysReAllocStringLen 原因：因为上述4个函数的参数类型都是OLECHAR FAR* 而不是BSTR，但后两个函数多了传入数量的参数。 BSTR的ATL封装类CCOMBSTR 建议：必须在非常清楚CComBSTR各个函数（特别是赋值操作符和构造函数）如何使用和注意事项的情况下才使用它，否则建议使用BSTR，因为使用不慎非常容易造成内存泄漏。 BSTR是一个带长度前缀的字符串,主要由操作系统来管理的,所以要用api.主要用来和VB打交道的(VB里的string就是指它)要操作它的API函数有很多.比如SysAllocString,SysFreeString等等. vc里封装它的类如_bstr_t,及ATL中的CComBSTR等. 一个 BSTR 由头部和字符串组成，头部包含了字符串的长度信息，字符串中可以包含嵌入的 null 值。 BSTR 是以指针的形式进行传递的。(指针是一个变量，包含另外一个变量的内存地址，而不是数据。) BSTR 是 Unicode 的，即每个字符需要两个字节。 BSTR 通常以两字节的 null 字符结束。 wstr是宽字符，以双字节表示一个字符 bstr是为了与原先的basic字符兼容，它的最前面的4个字节为其长度，以’\\0’结束. ATL基础BSTR CComBSTR SysAllocStringATL提供了 BSTR 和 CComBSTR ，还有OLEAUTO32.DLL导出一个API叫SysAllocString。这些东西有什么意思？有什么用呢？ BSTR 是一个typedef，你可以理解为 typedef WCHAR* BSTR它就是一个指针。所以 BSTR p = L”hello”;编译是没问题的。不过不推荐这么做。因为按MSDN，BSTR应该只接收 SysAllocString 的返回值。 就是说，第一，SysAllocString 的返回值是一个 BSTR 第二，如果我们看到一个BSTR，那它应该总从由一个 SysAllocString 得到的，它总是应该用 SysFreeString 释放。 我们可以想像，SysAllocString 实际上做了一个malloc分配了一块内存，然后把内存长度放第一个DWORD，把这个DWORD后面位置作为BSTR返回。因为在BSTR减4的位置已经保存了块长度，所以对BSTR不应该用 wcslen 之类的方法来得到它的长度，要用 SysStringLen。这就是为什么不推荐用 BSTR p = L”hello”这种方法直接给BSTR赋值，因为这样得到到BSTR不符合减4位置有块长度的规范，也不能用 SysStringLen 得到长度，也不能用 SysFreeString 来释放。乱了规矩。 又一个问题，为什么需要 SysAllocString ? 我用 new 或 malloc 不行吗？因为用ATL常常是为了写COM。而COM控件是跨语言的。你用C++写一个COM控件，可能被HTML中的一个VBSCRIPT或PHP调用。你返回的那个BSTR字串可能需要在VBSCRIPT中释放。而 new 或 malloc 等常规的C++分配内存函数，都要求内存在本模块内释放。所以，SysAllocString 分析的内存，是为了支持跨模块使用，并在外地free的。 那么 CComBSTR 又是什么呢？上面讲了，BSTR只是一个指针，它太简单了。如果我要实现字串查找，字串合并等复杂的操作就要自己写代码了。于是就有了 CComBSTR这个类。它只有一个成员 BSTR m_str 但它有大量的方法函数，足够你所可能需要的所有字串操作。 最后结论： * BSTR 只是一个指针，要小心使用，除了 SysAllocString 不要对它赋值。 * 如果发现一个 BSTR， 那它一定是用 SysAllocString 得到的。一定要用 SysStringLen 来得到长度。一定要用 SysFreeString 来释放它 * 如果需要对 BSTR 做字串操作，把它变成 CComBSTR ，总有一个现成的函数直接使用。 * 这一系列东西，都是为了COM跨模块把字串当作返回值使用的。如果一个字串只在本模块内有效，还是用 new 或 malloc 或 CString 来得简单。 SysAllocString,SysFreeString大致伪逻辑如下 1234567891011121314WCHAR* SysAllocString(WCHAR *str)&#123; size_t sz = 4 + wcslen(str)*sizeof(WCHAR); WCHAR *lpstart = malloc(); *(int*)lpstart = sz; wcscpy(lpstart+2,str); return lpstart + 2;&#125;void SysFreeString(WCHAR *str)&#123; str -= 2; free(str);&#125; 参考： https://blog.csdn.net/shihuaguo/article/details/8541172 https://bbs.pediy.com/thread-125705.htm https://www.cnblogs.com/qinfengxiaoyue/p/3428540.html https://blog.csdn.net/weixin_30478757/article/details/97589060","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]},{"title":"cpp11计时器-chrono","slug":"cpp11计时器-chrono","date":"2021-08-23T15:21:16.000Z","updated":"2021-08-23T15:55:27.187Z","comments":true,"path":"2021/08/23/cpp11计时器-chrono/","link":"","permalink":"https://marblemm.gitee.io/2021/08/23/cpp11%E8%AE%A1%E6%97%B6%E5%99%A8-chrono/","excerpt":"","text":"计时有很多用途，比如：测试某一段代码的运行时间，时间越短，则性能相对越高。计时有很多方法，我将首先给出我以前常用的一种计时方法，然后给出我认为的最佳方法（采用了C++11的标准技术）。 首先给出我以前常用的一种“传统”的计时方法： 12345678910111213#include &lt;ctime&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; clock_t start = clock(); // do something... clock_t end = clock(); cout &lt;&lt; &quot;花费了&quot; &lt;&lt; (double)(end - start) / CLOCKS_PER_SEC &lt;&lt; &quot;秒&quot; &lt;&lt; endl;&#125; 此方法可以精确到毫秒，输出样例：花费了0.123秒 c++11计时器C++11有了chrono库，可以在不同系统中很容易的实现定时功能。 要使用chrono库，需要#include，其所有实现均在std::chrono namespace下。注意标准库里面的每个命名空间代表了一个独立的概念。 chrono是一个模版库，使用简单，功能强大，只需要理解三个概念：duration、time_point、clock 时钟chrono库定义了三种不同的时钟: std::chrono::system_clock: 依据系统的当前时间 (不稳定) std::chrono::steady_clock: 以统一的速率运行(不能被调整) std::chrono::high_resolution_clock: 提供最高精度的计时周期(可能是steady_clock或者system_clock的typedef) system_clock就类似Windows系统右下角那个时钟，是系统时间。明显那个时钟是可以乱设置的。明明是早上10点，却可以设置成下午3点。 steady_clock则针对system_clock可以随意设置这个缺陷而提出来的，他表示时钟是不能设置的。 high_resolution_clock则是一个高分辨率时钟。 这三个时钟类都提供了一个静态成员函数now()用于获取当前时间，该函数的返回值是一个time_point类型， 时间精度其实也就是时间分辨率。抛开时间量纲单论分辨率，其实就是一个比率。如：1000110001、101101、1111 、110110、1100011000。这些比率加上距离量纲就变成距离分辨率，加上时间量纲就变成时间分辨率了。为此，C++11定义了一个新的模板类ratio，用于表示比率，定义如下： 123//#include&lt;ration&gt;template&lt;std::intmax_t Num, std::intmax_t Denom = 1&gt; //前者是分子，后者是分母class ratio; 为了方便，C++标准委员会还预定义了下面这些分辨率，供用户使用。 1234567//#include&lt;ratio&gt;typedef ratio&lt;1, 1000000000000000000&gt; atto;typedef ratio&lt;1, 1000000000000000&gt; femto;typedef ratio&lt;1, 1000000000000&gt; pico;typedef ratio&lt;1, 1000000000&gt; nano;typedef ratio&lt;1, 1000000&gt; micro;typedef ratio&lt;1, 1000&gt; milli; 1234567891011121314#include &lt;chrono&gt; #include &lt;iostream&gt;using namespace std;using namespace chrono;int main()&#123; auto start = system_clock::now(); // do something... auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; &quot;花费了&quot; &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; &quot;秒&quot; &lt;&lt; endl;&#125; 此方法可以精确到微妙，输出样例：花费了0.123456秒 microseconds 表示微妙。除此之外，还有五种时间单位：hours, minutes, seconds, milliseconds, nanosecondsnum 和 den分别表示分子(numerator)和分母(denominator)。在我给出的代码中，num等于1， den等于1,000,000 system_clock除了now()函数外，还提供了to_time_t()静态成员函数。用于将系统时间转换成熟悉的std::time_t类型， 得到了time_t类型的值，在使用ctime()函数将时间转换成字符串格式，就可以很方便地打印当前时间了。 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;ctime&gt;//将时间格式的数据转换成字符串#include&lt;chrono&gt;using namespace std::chrono;using namespace std;int main()&#123; //获取系统的当前时间 auto t = system_clock::now(); //将获取的时间转换成time_t类型 auto tNow = system_clock::to_time_t(t); //ctime()函数将time_t类型的时间转化成字符串格式,这个字符串自带换行符 string str_time = std::ctime(&amp;tNow); cout&lt;&lt;str_time; return 0;&#125; 二、持续的时间 - durationstd::chrono::duration&lt;int,ratio&lt;60,1&gt;&gt; ,表示持续的一段时间,这段时间的单位是由ratio&lt;60,1&gt;决定的,int表示这段时间的值的类型,函数返回的类型还是一个时间段duration std::chrono::duration&lt;double,ratio&lt;60,1&gt;&gt; 由于各种时间段(duration)表示不同，chrono库提供了duration_cast类型转换函数。 duration_cast用于将duration进行转换成另一个类型的duration。 duration还有一个成员函数count(),用来表示这一段时间的长度 1234567891011121314151617#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;chrono&gt;using namespace std::chrono;using namespace std;int main()&#123; auto start = steady_clock::now(); for(int i=0;i&lt;100;i++) cout&lt;&lt;&quot;nice&quot;&lt;&lt;endl; auto end = steady_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); cout&lt;&lt;&quot;程序用时=&quot;&lt;&lt;tt.count()&lt;&lt;&quot;微秒&quot;&lt;&lt;endl; return 0;&#125; 三、时间点 - time_point123//#include&lt;chrono&gt;template&lt; class Clock, class Duration = typename Clock::duration &gt; class time_point; std::chrono::time_point 表示一个具体时间，如上个世纪80年代、今天下午3点、火车出发时间等，只要它能用计算机时钟表示。第一个模板参数Clock用来指定所要使用的时钟（标准库中有三种时钟，system_clock，steady_clock和high_resolution_clock。见4时钟详解），第二个模板函数参数用来表示时间的计量单位(特化的std::chrono::duration&lt;&gt; ) 时间点都有一个时间戳，即时间原点。chrono库中采用的是Unix的时间戳1970年1月1日 00:00。所以time_point也就是距离时间戳(epoch)的时间长度（duration）。 时间点有个重要的函数：duration time_since_epoch() (用于获取当前时间点距离时间戳的时间长度)即经常用来得到当前时间点到1970年1月1日00:00的时间距离、该函数返回的duration的精度和构造time_point的时钟(Clock)有关(见4时钟详解)。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;ctime&gt;using namespace std;int main()&#123; //距离时间戳2两秒 chrono::time_point&lt;chrono::system_clock, chrono::seconds&gt; tp(chrono::seconds(2)); cout &lt;&lt; &quot;to epoch : &quot; &lt;&lt;tp.time_since_epoch().count() &lt;&lt; &quot;s&quot; &lt;&lt;endl; //转化为ctime，打印输出时间点 time_t tt = chrono::system_clock::to_time_t(tp); char a[50]; ctime_s(a, sizeof(a), &amp;tt); cout &lt;&lt; a; system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]},{"title":"cpp单例模式总结","slug":"cpp单例模式总结","date":"2021-08-22T08:40:01.000Z","updated":"2021-08-27T16:40:45.739Z","comments":true,"path":"2021/08/22/cpp单例模式总结/","link":"","permalink":"https://marblemm.gitee.io/2021/08/22/cpp%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"C++ 单例模式总结与剖析单例可能是最常用的简单的一种设计模式，实现方法多样，根据不同的需求有不同的写法; 同时单例也有其局限性，因此有很多人是反对使用单例的。本文对C++ 单例的常见写法进行了一个总结, 包括懒汉式、线程安全、单例模板等； 按照从简单到复杂，最终回归简单的的方式循序渐进地介绍，并且对各种实现方法的局限进行了简单的阐述，大量用到了C++ 11的特性如智能指针, magic static，线程锁; 从头到尾理解下来，对于学习和巩固C++语言特性还是很有帮助的。本文的全部代码在 g++ 5.4.0 编译器下编译运行通过，可以在这个github 仓库中找到。 一、什么是单例单例 Singleton 是设计模式的一种，其特点是只提供唯一一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;具体运用场景如： 设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动; 数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取; 二、C++单例的实现2.1 基础要点 全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private） 线程安全 禁止赋值和拷贝 用户通过接口获取实例：使用 static 类成员函数 2.2 C++ 实现单例的几种方式2.2.1 有缺陷的懒汉式懒汉式(Lazy-Initialization)的方法是直到使用时才实例化对象，也就说直到调用get_instance() 方法的时候才 new 一个单例的对象， 如果不被调用就不会占用内存。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;// version1:// with problems below:// 1. thread is not safe// 2. memory leakclass Singleton&#123;private: Singleton()&#123; std::cout&lt;&lt;&quot;constructor called!&quot;&lt;&lt;std::endl; &#125; Singleton(Singleton&amp;)=delete; Singleton&amp; operator=(const Singleton&amp;)=delete; static Singleton* m_instance_ptr;public: ~Singleton()&#123; std::cout&lt;&lt;&quot;destructor called!&quot;&lt;&lt;std::endl; &#125; static Singleton* get_instance()&#123; if(m_instance_ptr==nullptr)&#123; m_instance_ptr = new Singleton; &#125; return m_instance_ptr; &#125; void use() const &#123; std::cout &lt;&lt; &quot;in use&quot; &lt;&lt; std::endl; &#125;&#125;;Singleton* Singleton::m_instance_ptr = nullptr;int main()&#123; Singleton* instance = Singleton::get_instance(); Singleton* instance_2 = Singleton::get_instance(); return 0;&#125; 运行的结果是 1constructor called! 可以看到，获取了两次类的实例，却只有一次类的构造函数被调用，表明只生成了唯一实例，这是个最基础版本的单例实现，他有哪些问题呢？ 线程安全的问题,当多线程获取单例时有可能引发竞态条件：第一个线程在if中判断 m_instance_ptr是空的，于是开始实例化单例;同时第2个线程也尝试获取单例，这个时候判断m_instance_ptr还是空的，于是也开始实例化单例;这样就会实例化出两个对象,这就是线程安全问题的由来; 解决办法:加锁 内存泄漏. 注意到类中只负责new出对象，却没有负责delete对象，因此只有构造函数被调用，析构函数却没有被调用;因此会导致内存泄漏。解决办法： 使用共享指针;因此，这里提供一个改进的，线程安全的、使用智能指针的实现; 2.2.2 线程安全、内存安全的懒汉式单例 （智能指针，锁）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;memory&gt; // shared_ptr#include &lt;mutex&gt; // mutex// version 2:// with problems below fixed:// 1. thread is safe now// 2. memory doesn&#x27;t leakclass Singleton&#123;public: typedef std::shared_ptr&lt;Singleton&gt; Ptr; ~Singleton()&#123; std::cout&lt;&lt;&quot;destructor called!&quot;&lt;&lt;std::endl; &#125; Singleton(Singleton&amp;)=delete; Singleton&amp; operator=(const Singleton&amp;)=delete; static Ptr get_instance()&#123; // &quot;double checked lock&quot; if(m_instance_ptr==nullptr)&#123; std::lock_guard&lt;std::mutex&gt; lk(m_mutex); if(m_instance_ptr == nullptr)&#123; m_instance_ptr = std::shared_ptr&lt;Singleton&gt;(new Singleton); &#125; &#125; return m_instance_ptr; &#125;private: Singleton()&#123; std::cout&lt;&lt;&quot;constructor called!&quot;&lt;&lt;std::endl; &#125; static Ptr m_instance_ptr; static std::mutex m_mutex;&#125;;// initialization static variables out of classSingleton::Ptr Singleton::m_instance_ptr = nullptr;std::mutex Singleton::m_mutex;int main()&#123; Singleton::Ptr instance = Singleton::get_instance(); Singleton::Ptr instance2 = Singleton::get_instance(); return 0;&#125; 运行结果如下，发现确实只构造了一次实例，并且发生了析构。 12constructor called!destructor called! shared_ptr和mutex都是C++11的标准，以上这种方法的优点是 基于 shared_ptr, 用了C++比较倡导的 RAII思想，用对象管理资源,当 shared_ptr 析构的时候，new 出来的对象也会被 delete掉。以此避免内存泄漏。 加了锁，使用互斥量来达到线程安全。这里使用了两个 if判断语句的技术称为双检锁；好处是，只有判断指针为空的时候才加锁，避免每次调用 get_instance的方法都加锁，锁的开销毕竟还是有点大的。 不足之处在于： 使用智能指针会要求用户也得使用智能指针，非必要不应该提出这种约束; 使用锁也有开销; 同时代码量也增多了，实现上我们希望越简单越好。 还有更加严重的问题，在某些平台（与编译器和指令集架构有关），双检锁会失效！具体可以看这篇文章，解释了为什么会发生这样的事情。 因此这里还有第三种的基于 Magic Staic的方法达到线程安全 2.2.3 最推荐的懒汉式单例(magic static )——局部静态变量123456789101112131415161718192021222324252627#include &lt;iostream&gt;class Singleton&#123;public: ~Singleton()&#123; std::cout&lt;&lt;&quot;destructor called!&quot;&lt;&lt;std::endl; &#125; Singleton(const Singleton&amp;)=delete; Singleton&amp; operator=(const Singleton&amp;)=delete; static Singleton&amp; get_instance()&#123; static Singleton instance; return instance; &#125;private: Singleton()&#123; std::cout&lt;&lt;&quot;constructor called!&quot;&lt;&lt;std::endl; &#125;&#125;;int main(int argc, char *argv[])&#123; Singleton&amp; instance_1 = Singleton::get_instance(); Singleton&amp; instance_2 = Singleton::get_instance(); return 0;&#125; 运行结果 12constructor called!destructor called! 这种方法又叫做 Meyers’ SingletonMeyer’s的单例， 是著名的写出《Effective C++》系列书籍的作者 Meyers 提出的。所用到的特性是在C++11标准中的Magic Static特性： 12If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。 这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。 C++静态变量的生存期 是从声明到程序结束，这也是一种懒汉式。 这是最推荐的一种单例实现方式： 通过局部静态变量的特性保证了线程安全 (C++11, GCC &gt; 4.3, VS2015支持该特性); 不需要使用共享指针，代码简洁； 注意在使用的时候需要声明单例的引用 Single&amp; 才能获取对象。另外网上有人的实现返回指针而不是返回引用1234static Singleton* get_instance()&#123; static Singleton instance; return &amp;instance;&#125; 这样做并不好，理由主要是无法避免用户使用delete instance导致对象被提前销毁。还是建议大家使用返回引用的方式。 2.2.4 函数返回引用有人在网上提供了这样一种单例的实现方式； 12345678910111213141516171819202122232425#include &lt;iostream&gt;class A&#123;public: A() &#123; std::cout&lt;&lt;&quot;constructor&quot; &lt;&lt;std::endl; &#125; ~A()&#123; std::cout&lt;&lt;&quot;destructor&quot;&lt;&lt;std::endl; &#125;&#125;;A&amp; ret_singleton()&#123; static A instance; return instance;&#125;int main(int argc, char *argv[])&#123; A&amp; instance_1 = ret_singleton(); A&amp; instance_2 = ret_singleton(); return 0;&#125; 严格来说，这不属于单例了，因为类A只是个寻常的类，可以被定义出多个实例，但是亮点在于提供了ret_singleton的方法，可以返回一个全局（静态）变量，起到类似单例的效果，这要求用户必须保证想要获取 全局变量A ，只通过ret_singleton()的方法。 以上是各种方法实现单例的代码和说明，解释了各种技术实现的初衷和原因。这里会比较推荐 C++11 标准下的 2.2.3 的方式，即使用static local的方法，简单的理由来说是因为其足够简单却满足所有需求和顾虑。 在某些情况下，我们系统中可能有多个单例，如果都按照这种方式的话，实际上是一种重复，有没有什么方法可以只实现一次单例而能够复用其代码从而实现多个单例呢？ 很自然的我们会考虑使用模板技术或者继承的方法，在我的博客中有介绍过如何使用单例的模板。 2.3 单例的模板2.3.1 CRTP 奇异递归模板模式实现代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// brief: a singleton base class offering an easy way to create singleton#include &lt;iostream&gt;template&lt;typename T&gt;class Singleton&#123;public: static T&amp; get_instance()&#123; static T instance; return instance; &#125; virtual ~Singleton()&#123; std::cout&lt;&lt;&quot;destructor called!&quot;&lt;&lt;std::endl; &#125; Singleton(const Singleton&amp;)=delete; Singleton&amp; operator =(const Singleton&amp;)=delete;protected: Singleton()&#123; std::cout&lt;&lt;&quot;constructor called!&quot;&lt;&lt;std::endl; &#125;&#125;;/********************************************/// Example:// 1.friend class declaration is requiered!// 2.constructor should be privateclass DerivedSingle:public Singleton&lt;DerivedSingle&gt;&#123; // !!!! attention!!! // needs to be friend in order to // access the private constructor/destructor friend class Singleton&lt;DerivedSingle&gt;;public: DerivedSingle(const DerivedSingle&amp;)=delete; DerivedSingle&amp; operator =(const DerivedSingle&amp;)= delete;private: DerivedSingle()=default;&#125;;int main(int argc, char* argv[])&#123; DerivedSingle&amp; instance1 = DerivedSingle::get_instance(); DerivedSingle&amp; instance2 = DerivedSingle::get_instance(); return 0;&#125; 以上实现一个单例的模板基类，使用方法如例子所示意，子类需要将自己作为模板参数T 传递给 Singleton 模板; 同时需要将基类声明为友元，这样才能调用子类的私有构造函数。 基类模板的实现要点是： 构造函数需要是 protected，这样子类才能继承； 使用了奇异递归模板模式CRTP(Curiously recurring template pattern) get instance 方法和 2.2.3 的static local方法一个原理。 在这里基类的析构函数可以不需要 virtual ，因为子类在应用中只会用 Derived 类型，保证了析构时和构造时的类型一致2.3.2 不需要在子类声明友元的实现方法在 stackoverflow上， 有大神给出了不需要在子类中声明友元的方法，在这里一并放出;精髓在于使用一个代理类 token，子类构造函数需要传递token类才能构造，但是把 token保护其起来， 然后子类的构造函数就可以是公有的了，这个子类只有 Derived(token)的这样的构造函数，这样用户就无法自己定义一个类的实例了，起到控制其唯一性的作用。代码如下。123456789101112131415161718192021222324252627282930313233343536373839404142// brief: a singleton base class offering an easy way to create singleton#include &lt;iostream&gt;template&lt;typename T&gt;class Singleton&#123;public: static T&amp; get_instance() noexcept(std::is_nothrow_constructible&lt;T&gt;::value)&#123; static T instance&#123;token()&#125;; return instance; &#125; virtual ~Singleton() =default; Singleton(const Singleton&amp;)=delete; Singleton&amp; operator =(const Singleton&amp;)=delete;protected: struct token&#123;&#125;; // helper class Singleton() noexcept=default;&#125;;/********************************************/// Example:// constructor should be public because protected `token` control the accessclass DerivedSingle:public Singleton&lt;DerivedSingle&gt;&#123;public: DerivedSingle(token)&#123; std::cout&lt;&lt;&quot;destructor called!&quot;&lt;&lt;std::endl; &#125; ~DerivedSingle()&#123; std::cout&lt;&lt;&quot;constructor called!&quot;&lt;&lt;std::endl; &#125; DerivedSingle(const DerivedSingle&amp;)=delete; DerivedSingle&amp; operator =(const DerivedSingle&amp;)= delete;&#125;;int main(int argc, char* argv[])&#123; DerivedSingle&amp; instance1 = DerivedSingle::get_instance(); DerivedSingle&amp; instance2 = DerivedSingle::get_instance(); return 0;&#125; 2.3.3 函数模板返回引用在 2.2.4 中提供了一种类型的全局变量的方法，可以把一个一般的类，通过这种方式提供一个类似单例的全局性效果（但是不能阻止用户自己声明定义这样的类的对象）;在这里我们把这个方法变成一个 template 模板函数，然后就可以得到任何一个类的全局变量。12345678910111213141516171819202122232425#include &lt;iostream&gt;class A&#123;public: A() &#123; std::cout&lt;&lt;&quot;constructor&quot; &lt;&lt;std::endl; &#125; ~A()&#123; std::cout&lt;&lt;&quot;destructor&quot;&lt;&lt;std::endl; &#125;&#125;;template&lt;typename T&gt;T&amp; get_global()&#123; static T instance; return instance;&#125;int main(int argc, char *argv[])&#123; A&amp; instance_1 = get_global&lt;A&gt;(); A&amp; instance_2 = get_global&lt;A&gt;(); return 0;&#125; 可以看到这种方式确实非常简洁，同时类仍然具有一般类的特点而不受限制，当然也因此失去了单例那么强的约束（禁止赋值、构造和拷贝构造）。这里把函数命名为 get_global() 是为了强调，这里可以通过这种方式获取得到单例最重要的全局变量特性；但是并不是单例的模式。 三、何时应该使用或者不使用单例根据stackoverflow上的一个高票答案 singleton-how-should-it-be-used： 12You need to have one and only one object of a type in system你需要系统中只有唯一一个实例存在的类的全局变量的时候才使用单例。 如果使用单例，应该用什么样子的1234567891011How to create the best singleton:The smaller, the better. I am a minimalistMake sure it is thread safeMake sure it is never nullMake sure it is created only onceLazy or system initialization? Up to your requirementsSometimes the OS or the JVM creates singletons for you (e.g. in Java every class definition is a singleton)Provide a destructor or somehow figure out how to dispose resourcesUse little memory越小越好，越简单越好，线程安全，内存不泄露 反对单例的理由当然程序员是分流派的，有些是反对单例的，有些人是反对设计模式的，有些人甚至连面向对象都反对 😃. 反对单例的理由有哪些： 参考文章在本文写作的过程中参考了一些博客和stackoverflow 的回答，以超链接的方式体现在文中。另外还有一些我觉得非常精彩的回答，放在下面供读者拓展阅读 推荐阅读： 高票回答中提供了一系列有益的链接(https://stackoverflow.com/questions/1008019/c-singleton-design-pattern/1008289#1008289) 面试中的单例(http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html) 一些观点(https://segmentfault.com/q/1010000000593968) https://www.cnblogs.com/sunchaothu/p/10389842.html","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]},{"title":"cpp中std::ref","slug":"cpp中std-ref","date":"2021-08-22T07:07:29.000Z","updated":"2021-08-22T07:09:20.535Z","comments":true,"path":"2021/08/22/cpp中std-ref/","link":"","permalink":"https://marblemm.gitee.io/2021/08/22/cpp%E4%B8%ADstd-ref/","excerpt":"","text":"C++本身有引用（&amp;），为什么C++11又引入了std::ref（或者std::cref）？使用std::ref可以在模板传参的时候传入引用，否则只能传值。主要是考虑函数式编程（如std::bind）在使用时，是对参数直接拷贝，而不是引用。如下例子： 12345678910111213141516171819202122#include &lt;functional&gt;#include &lt;iostream&gt; void f(int&amp; n1, int&amp; n2, const int&amp; n3)&#123; std::cout &lt;&lt; &quot;In function: &quot; &lt;&lt; n1 &lt;&lt; &#x27; &#x27; &lt;&lt; n2 &lt;&lt; &#x27; &#x27; &lt;&lt; n3 &lt;&lt; &#x27;\\n&#x27;; ++n1; // increments the copy of n1 stored in the function object ++n2; // increments the main()&#x27;s n2 // ++n3; // compile error&#125; int main()&#123; int n1 = 1, n2 = 2, n3 = 3; std::function&lt;void()&gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout &lt;&lt; &quot;Before function: &quot; &lt;&lt; n1 &lt;&lt; &#x27; &#x27; &lt;&lt; n2 &lt;&lt; &#x27; &#x27; &lt;&lt; n3 &lt;&lt; &#x27;\\n&#x27;; bound_f(); std::cout &lt;&lt; &quot;After function: &quot; &lt;&lt; n1 &lt;&lt; &#x27; &#x27; &lt;&lt; n2 &lt;&lt; &#x27; &#x27; &lt;&lt; n3 &lt;&lt; &#x27;\\n&#x27;;&#125; 输出： 1234Output:Before function: 10 11 12In function: 1 11 12After function: 10 12 12 上述代码在执行std::bind后，在函数f()中n1的值仍然是1，n2和n3改成了修改的值。说明std::bind使用的是参数的拷贝而不是引用。具体为什么std::bind不使用引用，可能确实有一些需求，使得C++11的设计者认为默认应该采用拷贝，如果使用者有需求，加上std::ref即可。 &amp;是类型说明符， std::ref 是一个函数，返回 std::reference_wrapper类型。另外std::cref() 用于const引用的版本。 参考： https://www.cnblogs.com/chen-cs/p/13059896.html","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]},{"title":"cpp中的RAII机制","slug":"cpp中的RAII机制","date":"2021-08-20T15:52:47.000Z","updated":"2021-08-22T16:36:28.839Z","comments":true,"path":"2021/08/20/cpp中的RAII机制/","link":"","permalink":"https://marblemm.gitee.io/2021/08/20/cpp%E4%B8%AD%E7%9A%84RAII%E6%9C%BA%E5%88%B6/","excerpt":"","text":"什么是RAII？RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。 为什么要使用RAII？上面说到RAII是用来管理资源、避免资源泄漏的方法。那么，用了这么久了，也写了这么多程序了，口头上经常会说资源，那么资源是如何定义的？在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，所以，我们在编程使用系统资源时，都必须遵循一个步骤：1 申请资源；2 使用资源；3 释放资源。第一步和第二步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。 一个最简单的例子：12345678910111213#include &lt;iostream&gt; using namespace std; int main() &#123; int *testArray = new int [10]; // Here, you can use the array delete [] testArray; testArray = NULL ; return 0; &#125; 小结：但是如果程序很复杂的时候，需要为所有的new 分配的内存delete掉，导致极度臃肿，效率下降，更可怕的是，程序的可理解性和可维护性明显降低了，当操作增多时，处理资源释放的代码就会越来越多，越来越乱。如果某一个操作发生了异常而导致释放资源的语句没有被调用，怎么办？这个时候，RAII机制就可以派上用场了。 如何使用RAII？当我们在一个函数内部使用局部变量，当退出了这个局部变量的作用域时，这个变量也就别销毁了；当这个变量是类对象时，这个时候，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显示的去调用完成。这个也太好了，RAII就是这样去完成的。 由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。 使用RAII 机制的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt; using namespace std; class ArrayOperation &#123; public : ArrayOperation() &#123; m_Array = new int [10]; &#125; void InitArray() &#123; for (int i = 0; i &lt; 10; ++i) &#123; *(m_Array + i) = i; &#125; &#125; void ShowArray() &#123; for (int i = 0; i &lt;10; ++i) &#123; cout&lt;&lt;m_Array[i]&lt;&lt;endl; &#125; &#125; ~ArrayOperation() &#123; cout&lt;&lt; &quot;~ArrayOperation is called&quot; &lt;&lt;endl; if (m_Array != NULL ) &#123; delete[] m_Array; // 非常感谢益可达非常犀利的review，详细可以参加益可达在本文的评论 2014.04.13 m_Array = NULL ; &#125; &#125; private : int *m_Array; &#125;; bool OperationA(); bool OperationB(); int main() &#123; ArrayOperation arrayOp; arrayOp.InitArray(); arrayOp.ShowArray(); return 0;&#125; 不使用RAII（没有使用类的思想）的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt; using namespace std; bool OperationA(); bool OperationB(); int main() &#123; int *testArray = new int [10]; // Here, you can use the array if (!OperationA()) &#123; // If the operation A failed, we should delete the memory delete [] testArray; testArray = NULL ; return 0; &#125; if (!OperationB()) &#123; // If the operation A failed, we should delete the memory delete [] testArray; testArray = NULL ; return 0; &#125; // All the operation succeed, delete the memory delete [] testArray; testArray = NULL ; return 0; &#125; bool OperationA() &#123; // Do some operation, if the operate succeed, then return true, else return false return false ; &#125; bool OperationB() &#123; // Do some operation, if the operate succeed, then return true, else return false return true ; &#125; 上面这个例子没有多大的实际意义，只是为了说明RAII的机制问题。下面说一个具有实际意义的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;using namespace std;CRITICAL_SECTION cs;int gGlobal = 0;class MyLock&#123;public: MyLock() &#123; EnterCriticalSection(&amp;cs); &#125; ~MyLock() &#123; LeaveCriticalSection(&amp;cs); &#125;private: MyLock( const MyLock &amp;); MyLock operator =(const MyLock &amp;);&#125;;void DoComplex(MyLock &amp;lock ) // 非常感谢益可达犀利的review 2014.04.13&#123;&#125;unsigned int __stdcall ThreadFun(PVOID pv) &#123; MyLock lock; int *para = (int *) pv; // I need the lock to do some complex thing DoComplex(lock); for (int i = 0; i &lt; 10; ++i) &#123; ++gGlobal; cout&lt;&lt; &quot;Thread &quot; &lt;&lt;*para&lt;&lt;endl; cout&lt;&lt;gGlobal&lt;&lt;endl; &#125; return 0;&#125;int main()&#123; InitializeCriticalSection(&amp;cs); int thread1, thread2; thread1 = 1; thread2 = 2; HANDLE handle[2]; handle[0] = ( HANDLE )_beginthreadex(NULL , 0, ThreadFun, ( void *)&amp;thread1, 0, NULL ); handle[1] = ( HANDLE )_beginthreadex(NULL , 0, ThreadFun, ( void *)&amp;thread2, 0, NULL ); WaitForMultipleObjects(2, handle, TRUE , INFINITE ); return 0;&#125; 这个例子可以说是实际项目的一个模型，当多个进程访问临界变量时，为了不出现错误的情况，需要对临界变量进行加锁；上面的例子就是使用的Windows的临界区域实现的加锁。 但是，在使用CRITICAL_SECTION时，EnterCriticalSection和LeaveCriticalSection必须成对使用，很多时候，经常会忘了调用LeaveCriticalSection，此时就会发生死锁的现象。当我将对CRITICAL_SECTION的访问封装到MyLock类中时，之后，我只需要定义一个MyLock变量，而不必手动的去显示调用LeaveCriticalSection函数。 上述的两个例子都是RAII机制的应用，理解了上面的例子，就应该能理解了RAII机制的使用了。 参考： https://www.jianshu.com/p/b7ffe79498be","categories":[],"tags":[]},{"title":"cpp11多线程5-atomic","slug":"cpp11多线程5-atomic","date":"2021-08-19T14:08:01.000Z","updated":"2021-08-30T15:46:34.630Z","comments":true,"path":"2021/08/19/cpp11多线程5-atomic/","link":"","permalink":"https://marblemm.gitee.io/2021/08/19/cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B5-atomic/","excerpt":"","text":"对简单临界资源的访问，如果使用mutex开销较大。 如有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条语句可能会被拆成3、4条汇编语句来执行，所以仍然有可能混乱） 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono;int g_count = 0;void mythread()&#123; for (int i = 0; i &lt; 1000000; i++) &#123; g_count++; &#125;&#125;int main()&#123; std::thread t1(mythread); std::thread t2(mythread); auto start = steady_clock::now(); t1.join(); t2.join(); auto end = steady_clock::now(); auto tt = duration_cast&lt;milliseconds&gt;(end - start); cout &lt;&lt; &quot;程序用时=&quot; &lt;&lt; tt.count() &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl; cout &lt;&lt; &quot;正常情况下结果应该是200 0000次，实际是&quot; &lt;&lt; g_count &lt;&lt; endl; return 0;&#125;/*结果：程序用时=16毫秒正常情况下结果应该是200 0000次，实际是1303733*/ 使用std::mutex来解决上述对临界资源访问的问题。结果正常，但是每一次循环都要加锁解锁是的程序开销很大。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;mutex&gt;using namespace std;using namespace std::chrono;int g_count = 0;std::mutex mymutex;void mythread()&#123; for (int i = 0; i &lt; 1000000; i++) &#123; std::unique_lock&lt;std::mutex&gt; u1(mymutex); g_count++; &#125;&#125;int main()&#123; std::thread t1(mythread); std::thread t2(mythread); auto start = steady_clock::now(); t1.join(); t2.join(); auto end = steady_clock::now(); auto tt = duration_cast&lt;milliseconds&gt;(end - start); cout &lt;&lt; &quot;程序用时=&quot; &lt;&lt; tt.count() &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl; cout &lt;&lt; &quot;正常情况下结果应该是200 0000次，实际是&quot; &lt;&lt; g_count &lt;&lt; endl; return 0;&#125;/*结果：程序用时=349毫秒正常情况下结果应该是200 0000次，实际是2000000*/ std::atomic std::atomic包含在头文件中。可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。原子操作：在多线程中不会被打断的程序执行片段。从效率上来说，原子操作要比互斥量的方式效率要高。互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。std::atomic来代表原子操作，是个类模板。其实std::atomic是用来封装某个类型的值。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono;std::atomic&lt;int&gt; g_count = 0; //封装了一个类型为int的 对象（值）void mythread()&#123; for (int i = 0; i &lt; 1000000; i++) &#123; g_count++; &#125;&#125;int main()&#123; std::thread t1(mythread); std::thread t2(mythread); auto start = steady_clock::now(); t1.join(); t2.join(); auto end = steady_clock::now(); auto tt = duration_cast&lt;milliseconds&gt;(end - start); cout &lt;&lt; &quot;程序用时=&quot; &lt;&lt; tt.count() &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl; cout &lt;&lt; &quot;正常情况下结果应该是200 0000次，实际是&quot; &lt;&lt; g_count &lt;&lt; endl; return 0;&#125;/*程序用时=51毫秒正常情况下结果应该是200 0000次，实际是2000000*/ 一般atomic原子操作，针对++，–，+=，-=，&amp;=，|=，^=是支持的，其他操作不一定支持。如下使用g_count = g_count + 1就会产生错误。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;using namespace std;std::atomic&lt;int&gt; g_count = 0; //封装了一个类型为int的 对象（值）void mythread1() &#123; for (int i = 0; i &lt; 1000000; i++) &#123; //虽然g_count使用了原子操作模板，但是这种写法既读又写， //会导致计数错误 g_count = g_count + 1; &#125;&#125;int main() &#123; std::thread t1(mythread1); std::thread t2(mythread1); t1.join(); t2.join(); cout &lt;&lt; &quot;正常情况下结果应该是200 0000次，实际是&quot; &lt;&lt; g_count &lt;&lt; endl;&#125; 其他需要注意的地方12std::atomic&lt;int&gt; atm = 0; cout &lt;&lt; atm &lt;&lt; endl; 这里只有读取atm是原子操作，但是整个这一行代码 cout &lt;&lt; atm &lt;&lt; endl; 并不是原子操作，导致最终显示在屏幕上的值是一个“曾经值”。 12std::atomic&lt;int&gt; atm = 0;auto atm2 = atm; //不可以 这种拷贝初始化不可以，会报错。 1atomic&lt;int&gt; atm2(atm.load()); load()：以原子方式读atomic对象的值。 1atm2.store(12); store()：以原子方式写。 参考： https://www.cnblogs.com/chen-cs/p/13254219.html","categories":[{"name":"多线程","slug":"多线程","permalink":"https://marblemm.gitee.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"cpp11多线程4-condition","slug":"cpp11多线程4-condition","date":"2021-08-18T13:44:18.000Z","updated":"2021-08-27T16:44:57.259Z","comments":true,"path":"2021/08/18/cpp11多线程4-condition/","link":"","permalink":"https://marblemm.gitee.io/2021/08/18/cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B4-condition/","excerpt":"","text":"std::condition_variable条件变量是C++11提供的另外一种线程同步机制，通过判断条件是否满足，决定是否阻塞线程，当线程执行条件满足的时候就会唤醒阻塞的线程，常与std::mutex配合使用，C++11提供了两种条件变量。 123std::condition_variable，配合std::unique_lock&lt;std::mutex&gt;使用，通过wait()函数阻塞线程；std::condition_variable_any，可以和任意带有lock()、unlock()语义的std::mutex搭配使用，比较灵活，但是其效率不及std::condition_variable；std::unique_lock：C++11提供的 std::unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。std::unique_lock比std::lock_guard使用更加灵活，功能更加强大。使用std::unique_lock需要付出更多的时间、性能成本。 互斥锁std::mutex是一种最常见的线程间同步的手段，但是在有些情况下不太高效。 假设想实现一个简单的消费者生产者模型，一个线程往队列中放入数据，一个线程往队列中取数据，取数据前需要判断一下队列中确实有数据，由于这个队列是线程间共享的，所以，需要使用互斥锁进行保护，一个线程在往队列添加数据的时候，另一个线程不能取，反之亦然。用互斥锁实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::deque&lt;int&gt; q;std::mutex mu;void function_1() &#123; int count = 10; while (count &gt; 0) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); q.push_front(count); locker.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); count--; &#125;&#125;void function_2() &#123; int data = 0; while ( data != 1) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); if (!q.empty()) &#123; data = q.back(); q.pop_back(); locker.unlock(); std::cout &lt;&lt; &quot;t2 got a value from t1: &quot; &lt;&lt; data &lt;&lt; std::endl; &#125; else &#123; locker.unlock(); &#125; &#125;&#125;int main() &#123; std::thread t1(function_1); std::thread t2(function_2); t1.join(); t2.join(); return 0;&#125;//输出结果//t2 got a value from t1: 10//t2 got a value from t1: 9//t2 got a value from t1: 8//t2 got a value from t1: 7//t2 got a value from t1: 6//t2 got a value from t1: 5//t2 got a value from t1: 4//t2 got a value from t1: 3//t2 got a value from t1: 2//t2 got a value from t1: 1 ​可以看到，互斥锁其实可以完成这个任务，但是却存在着性能问题。 首先，function_1函数是生产者，在生产过程中，std::this_thread::sleep_for(std::chrono::seconds(1));表示延时1s，所以这个生产的过程是很慢的；function_2函数是消费者，存在着一个while循环，只有在接收到表示结束的数据的时候，才会停止，每次循环内部，都是先加锁，判断队列不空，然后就取出一个数，最后解锁。所以说，在1s内，做了很多无用功！这样的话，CPU占用率会很高，可能达到100%（单核）。如图： 解决办法之一是给消费者也加一个小延时，如果一次判断后，发现队列是空的，就惩罚一下自己，延时500ms，这样可以减小CPU的占用率。 123456789101112131415void function_2() &#123; int data = 0; while ( data != 1) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); if (!q.empty()) &#123; data = q.back(); q.pop_back(); locker.unlock(); std::cout &lt;&lt; &quot;t2 got a value from t1: &quot; &lt;&lt; data &lt;&lt; std::endl; &#125; else &#123; locker.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(500)); &#125; &#125;&#125; 如图： 然后困难之处在于，如何确定这个延时时间呢，假如生产者生产的很快，消费者却延时500ms，也不是很好，如果生产者生产的更慢，那么消费者延时500ms，还是不必要的占用了CPU。 这就引出了条件变量（condition variable）,c++11中提供了#include 头文件，其中的std::condition_variable可以和std::mutex结合一起使用，其中有两个重要的接口，notify_one()和wait()，wait()可以让线程陷入休眠状态，在消费者生产者模型中，如果生产者发现队列中没有东西，就可以让自己休眠，但是不能一直不干活啊，notify_one()就是唤醒处于wait中的其中一个条件变量（可能当时有很多条件变量都处于wait状态）。那什么时刻使用notify_one()比较好呢，当然是在生产者往队列中放数据的时候了，队列中有数据，就可以赶紧叫醒等待中的线程起来干活了。 使用条件变量修改后如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;std::deque&lt;int&gt; q;std::mutex mu;std::condition_variable cond;void function_1() &#123; int count = 10; while (count &gt; 0) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); q.push_front(count); locker.unlock(); cond.notify_one(); // Notify one waiting thread, if there is one. std::this_thread::sleep_for(std::chrono::seconds(1)); count--; &#125;&#125;void function_2() &#123; int data = 0; while ( data != 1) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); while(q.empty()) cond.wait(locker); // Unlock mu and wait to be notified data = q.back(); q.pop_back(); locker.unlock(); std::cout &lt;&lt; &quot;t2 got a value from t1: &quot; &lt;&lt; data &lt;&lt; std::endl; &#125;&#125;int main() &#123; std::thread t1(function_1); std::thread t2(function_2); t1.join(); t2.join(); return 0;&#125; 此时CPU的占用率也很低。 上面的代码有三个注意事项： 在function_2中，在判断队列是否为空的时候，使用的是while(q.empty())，而不是if(q.empty())，这是因为wait()从阻塞到返回，不一定就是由于notify_one()函数造成的，还有可能由于系统的不确定原因唤醒（可能和条件变量的实现机制有关），这个的时机和频率都是不确定的，被称作伪唤醒，如果在错误的时候被唤醒了，执行后面的语句就会错误，所以需要再次判断队列是否为空，如果还是为空，就继续wait()阻塞。 在管理互斥锁的时候，使用的是std::unique_lock而不是std::lock_guard，而且事实上也不能使用std::lock_guard，这需要先解释下wait()函数所做的事情。可以看到，在wait()函数之前，使用互斥锁保护了，如果wait的时候什么都没做，岂不是一直持有互斥锁？那生产者也会一直卡住，不能够将数据放入队列中了。所以，wait()函数会先调用互斥锁的unlock()函数，然后再将自己睡眠，在被唤醒后，又会继续持有锁，保护后面的队列操作。而lock_guard没有lock和unlock接口，而unique_lock提供了。这就是必须使用unique_lock的原因。 使用细粒度锁，尽量减小锁的范围，在notify_one()的时候，不需要处于互斥锁的保护范围内，所以在唤醒条件变量之前可以将锁unlock()。 还可以将cond.wait(locker);换一种写法，wait()的第二个参数可以传入一个函数表示检查条件，这里使用lambda函数最为简单，如果这个函数返回的是true，wait()函数不会阻塞会直接返回，如果这个函数返回的是false，wait()函数就会阻塞着等待唤醒，如果被伪唤醒，会继续判断函数返回值。 1234567891011void function_2() &#123; int data = 0; while ( data != 1) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); cond.wait(locker, []()&#123; return !q.empty();&#125; ); // Unlock mu and wait to be notified data = q.back(); q.pop_back(); locker.unlock(); std::cout &lt;&lt; &quot;t2 got a value from t1: &quot; &lt;&lt; data &lt;&lt; std::endl; &#125;&#125; 除了notify_one()函数，c++还提供了notify_all()函数，可以同时唤醒所有处于wait状态的条件变量。 参考： https://www.jianshu.com/p/c1dfa1d40f53","categories":[{"name":"多线程","slug":"多线程","permalink":"https://marblemm.gitee.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"cpp11多线程3-mutex","slug":"cpp11多线程3-mutex","date":"2021-08-17T13:22:05.000Z","updated":"2021-08-27T16:44:52.294Z","comments":true,"path":"2021/08/17/cpp11多线程3-mutex/","link":"","permalink":"https://marblemm.gitee.io/2021/08/17/cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B3-mutex/","excerpt":"","text":"std::mutex进入多线程编程的世界，除了要牢牢掌握std::thread使用方法，还要掌握互斥量（锁）的使用，这是一种线程同步机制，在C++11中提供了4中互斥量。 1234std::mutex; //非递归的互斥量std::timed_mutex; //带超时的非递归互斥量std::recursive_mutex; //递归互斥量std::recursive_timed_mutex; //带超时的递归互斥量 从各种互斥量的名字可以看出其具有的特性，在实际开发中，常用就是std::mutex，它就像是一把锁，我们需要做的就是对它进行加锁与解锁。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;​std::mutex g_mutex;void func()&#123; std::cout &lt;&lt; &quot;entry func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::microseconds(1000)); std::cout &lt;&lt; &quot;leave func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;&#125;int main()&#123; std::thread t1(func); std::thread t2(func); std::thread t3(func); std::thread t4(func); std::thread t5(func); t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); return 0;&#125; 创建了5个线程，然后分别调用func()函数，得到结果： 12345678910entry func test thread ID is : entry func test thread ID is : 19180entry func test thread ID is : 359613632entry func test thread ID is : 9520entry func test thread ID is : 4460leave func test thread ID is : 13632leave func test thread ID is : 19180leave func test thread ID is : leave func test thread ID is : 95203596leave func test thread ID is : 4460 可以看出，并没有按顺序去执行线程函数，后面创建的线程并没有等待前面的线程执行完毕，导致结果混乱，下面用std::mutex进行控制： 保护共享数据的最基本的方式，是使用C++标准库提供的互斥量（头文件）。当访问共享数据前，使用互斥量将相关数据锁住，再当访问结束后，再将数据解锁。线程库需要保证，当一个线程使用特定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能进行访问。这就保证了所有线程能看到共享数据，而不破坏不变量。 C++中通过实例化 std::mutex 创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;​std::mutex g_mutex;using namespace std;void func()&#123; g_mutex.lock(); std::cout &lt;&lt; &quot;entry func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::microseconds(1000)); std::cout &lt;&lt; &quot;leave func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; g_mutex.unlock();&#125;int main()&#123; std::thread t1(func); std::thread t2(func); std::thread t3(func); std::thread t4(func); std::thread t5(func); t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); return 0;&#125; 只要线程进入func()函数就进行加锁处理，当线程执行完毕后进行解锁，保证每个线程都能按顺序执行，输出结果： 12345678910entry func test thread ID is : 8852leave func test thread ID is : 8852entry func test thread ID is : 15464leave func test thread ID is : 15464entry func test thread ID is : 17600leave func test thread ID is : 17600entry func test thread ID is : 16084leave func test thread ID is : 16084entry func test thread ID is : 4156leave func test thread ID is : 4156 虽然通过lock()与unlock()可以解决线程之间的资源竞争问题，但是这里也存在不足。 123456789101112func()&#123; //加锁 执行逻辑处理; //如果该过程抛出异常导致程序退出了，就没法unlock //解锁 &#125;​int main()&#123; ......&#125; func()中再执行逻辑处理中程序因为某些原因退出了，此时就无法unlock()了，这样其他线程也就无法获取std::mutex，造成死锁现象，其实在加锁之前可以通过trylock()尝试一下能不能加锁。实际开发中，通常也不会这样写代码，而是采用lock_guard来控制std::mutex。 1234567891011121314151617181920212223242526template &lt;class _Mutex&gt;class lock_guard &#123; public: using mutex_type = _Mutex;​ explicit lock_guard(_Mutex&amp; _Mtx) : _MyMutex(_Mtx) &#123; _MyMutex.lock(); //构造函数加锁 &#125;​ lock_guard(_Mutex&amp; _Mtx, adopt_lock_t) : _MyMutex(_Mtx) &#123; &#125;​ ~lock_guard() noexcept &#123; _MyMutex.unlock(); //析构函数解锁 &#125;​ lock_guard(const lock_guard&amp;) = delete; lock_guard&amp; operator=(const lock_guard&amp;) = delete;​private: _Mutex&amp; _MyMutex;&#125;;​ lock_guard是类模板，在其构造函数中自动给std::mutex加锁，在退出作用域的时候自动解锁，这样就可以保证std::mutex的正确操作，这也是RAII（获取资源便初始化）技术的体现。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;​std::mutex g_mutex;void func()&#123; std::lock_guard&lt;std::mutex&gt; lock(g_mutex); //加锁 std::cout &lt;&lt; &quot;entry func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::microseconds(1000)); std::cout &lt;&lt; &quot;leave func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; //退出作用域后，lock_guard对象析构就自动解锁&#125;int main()&#123; std::thread t1(func); std::thread t2(func); std::thread t3(func); std::thread t4(func); std::thread t5(func); t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); return 0;&#125;运行结果：entry func test thread ID is : 19164leave func test thread ID is : 19164entry func test thread ID is : 15124leave func test thread ID is : 15124entry func test thread ID is : 2816leave func test thread ID is : 2816entry func test thread ID is : 17584leave func test thread ID is : 17584entry func test thread ID is : 15792leave func test thread ID is : 15792 但互斥量自身也有问题。 当其中一个成员函数返回的是保护数据的指针或引用时，会破坏对数据的保护。具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。所以切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去。 另外还会造成死锁，或是对数据保护的太多(或太少)的问题。 参考： https://www.cnblogs.com/chen-cs/p/13060353.html","categories":[{"name":"多线程","slug":"多线程","permalink":"https://marblemm.gitee.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"cpp11多线程2-join注意","slug":"cpp11多线程2-join注意","date":"2021-08-16T12:24:06.000Z","updated":"2021-08-27T16:42:34.270Z","comments":true,"path":"2021/08/16/cpp11多线程2-join注意/","link":"","permalink":"https://marblemm.gitee.io/2021/08/16/cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B2-join%E6%B3%A8%E6%84%8F/","excerpt":"","text":"join()函数的作用是让主线程的等待该子线程完成，然后主线程再继续执行。这种情况下，子线程可以安全的访问主线程中的资源。子线程结束后由主线程负责回收子线程资源。一个子线程只能调用join()和detach()中的一个，且只允许调用一次。可以调用joinable()来判断是否可以成功调用join()或detach()。 123456789101112131415161718192021222324252627282930#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;void test()&#123; cout &lt;&lt; &quot;子线程开始执行！&quot; &lt;&lt; endl; //do something cout &lt;&lt; &quot;子线程执行完毕！&quot; &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; &quot;主线程开始执行！&quot; &lt;&lt; endl; thread t(test); cout &lt;&lt; &quot;join()是否可调：&quot; &lt;&lt; boolalpha &lt;&lt; t.joinable() &lt;&lt; endl; t.join(); //主线程等待子线程 cout &lt;&lt; &quot;join()是否可调：&quot; &lt;&lt; boolalpha &lt;&lt; t.joinable() &lt;&lt; endl; cout &lt;&lt; &quot;主线程执行完毕！&quot; &lt;&lt; endl; return 0;&#125;结果输出：主线程开始执行！join()是否可调：true子线程开始执行！子线程执行完毕！join()是否可调：false主线程执行完毕！ 注意 1、为了确保子线程程序在发送异常退出前完成，就需要对注意调用join()函数的位置，否则当主线发生异常而此时还没有调用到join()函数，那么子线程随主线程终止。解决方法是在异常处理中调用join()。 异常发生的情况，子线程没有完成就随主线程终止。 123456789101112131415161718192021222324#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;static void func()&#123; cout &lt;&lt; &quot;子线程func开始执行！&quot; &lt;&lt; endl; //do something int i = 100000; while (i--) &#123;&#125; cout &lt;&lt; &quot;子线程func执行结束！&quot; &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; &quot;主线程main开始执行！&quot; &lt;&lt; endl; thread t(func); throw 123; t.join(); cout &lt;&lt; &quot;主线程main执行结束！&quot; &lt;&lt; endl; return 0;&#125; 在异常处理中调用join() 12345678910111213141516171819202122232425262728293031323334353637#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt; //for rand()using namespace std;void func()&#123; cout &lt;&lt; &quot;子线程func开始执行！&quot; &lt;&lt; endl; //do something int i = 100000; while(i--) &#123; &#125; cout &lt;&lt; &quot;子线程func执行结束！&quot; &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; &quot;主线程main开始执行！&quot; &lt;&lt; endl; thread t(func); try &#123; //do something if (rand() % 7) //随机抛出异常来模拟异常发生 &#123; throw 123; &#125; &#125; catch(...) &#123; //do something t.join(); abort(); //终止主线程 &#125; t.join(); //未发生异常时使用 cout &lt;&lt; &quot;主线程main执行结束！&quot; &lt;&lt; endl; return 0;&#125; 2、为了应对忘记使用join()和选择位置的问题，可以使用RAII机制来管理子线程，在RAII析构中调用join()。这样在我根本不需要考虑join的位置问题，还是是否忘记的问题。但是这个方式在程序异常的情况下并不能保证主线程被终止时，子线程执行结束。因为程序因异常而终止时，如果没有捕获，对象的析构不会发生，只能由系统来回收资源。关于RAII：cpp中的RAII机制 使用RAII在析构中调用join() 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;void func()&#123; cout &lt;&lt; &quot;子线程func开始执行！&quot; &lt;&lt; endl; //do something int i = 100000 ; while(i--) &#123; &#125; cout &lt;&lt; &quot;子线程func执行结束！&quot; &lt;&lt; endl;&#125;class RAII_thread&#123; thread&amp; t;public: explicit RAII_thread(thread&amp; t_): t(t_) &#123; &#125; ~RAII_thread()&#123; if(t.joinable()) t.join(); &#125; RAII_thread(RAII_thread const&amp;) = delete; RAII_thread&amp; operator=(RAII_thread const&amp;) = delete;&#125;;int main()&#123; //确保异常发生时，子线程执行完毕的技巧2，使用RAII管理子线程 cout &lt;&lt; &quot;主线程main开始执行！&quot; &lt;&lt; endl; thread t(func); RAII_thread raii(t); //do something cout &lt;&lt; &quot;主线程main执行结束！&quot; &lt;&lt; endl; return 0;&#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"https://marblemm.gitee.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"cpp11多线程1-thread","slug":"cpp11多线程1-thread","date":"2021-08-15T12:08:58.000Z","updated":"2021-08-27T16:44:45.117Z","comments":true,"path":"2021/08/15/cpp11多线程1-thread/","link":"","permalink":"https://marblemm.gitee.io/2021/08/15/cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B1-thread/","excerpt":"","text":"std::thread在C++11之前，C++语言层面是不支持多线程的，想利用C++实现并发程序，借助操作系统的API实现跨平台的并发程序存在着诸多不便，当C++11在语言层面支持多线程后，编写跨平台的多线程代码就方便了许多。 C++11提供的std::thread在开发多线程方面带来了便捷。 123456789101112131415#include &lt;iostream&gt;#include &lt;thread&gt;​void threadfunc()&#123; std::cout &lt;&lt; &quot;thread func&quot; &lt;&lt; std::endl;&#125;​​int main()&#123; std::thread t1(threadfunc); t1.join(); //等待threadfunc运行结束 return 0;&#125; 首先定义线程对象t1，线程函数threadfunc运行在线程对象t1中，当线程创建成功并执行线程函数后，一定要保证线程函数运行结束才能退出，这里调用了join()函数阻塞线程，直到threadfunc()运行结束，回收对应创建线程的资源。如果不阻塞线程，就不能保证线程对象t1在threadfunc()运行期间有效，下面不调用join()阻塞线程。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;thread&gt;​void threadfunc()&#123; std::cout &lt;&lt; &quot;thread func&quot; &lt;&lt; std::endl;&#125;​​int main()&#123; std::thread t1(threadfunc); //t1.join(); //等待threadfunc运行结束 return 0;&#125;````在运行时引起了程序崩溃。![error1.jpg](error1.jpg)除了调用join()阻塞线程，保证线程对象在线程函数运行期间的有效性，还可以通过线程分离的手段实现，调用detach()函数使得线程对象与线程函数分离，这样，在线程函数运行期间，线程对象与线程函数就没有联系了，此时的线程是作为后台线程去执行，detach()后就无法再和线程发生联系，也不能通过join()来等待线程执行完毕，线程何时执行完无法控制，它的资源会被init进程回收，所以，通常不采用detach()方法。 #include #include ​void threadfunc(){ std::cout &lt;&lt; “ detach thread func” &lt;&lt; std::endl;}​int main(){ std::thread t1(threadfunc); t1.detach(); //线程分离​ return 0;} 12这里调用detach()实现线程分离，但是运行后，主线程退出的时候threadfunc()还没有输出“detach thread func”，threadfunc()什么时候运行结束也无法确定，为了看到所创建的线程运行结果，在主线程等待一下再退出。 #include #include #include //时间​void threadfunc(){ std::cout &lt;&lt; “detach thread func” &lt;&lt; std::endl;}​int main(){ std::thread t1(threadfunc); t1.detach(); while (true) { std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒 break; } return 0; } 1此时运行结果： detach thread func 1通过std::thread创建的线程是不可以复制的，但是可以移动。 #include #include #include ​void threadfunc(){ std::cout &lt;&lt; “move thread func” &lt;&lt; std::endl;}​int main(){ std::thread t1(threadfunc); std::thread t2(std::move(t1)); t2.join(); while (true) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒 break; &#125; return 0; } 1输出结果： move thread func 1234567移动后t1就不代表任何线程了，t2对象代表着线程threadfunc()。## 其他创建线程方式### 通过std::bind来创建线程函数。 #include #include #include //时间#include //std::bind​class A {public: void threadfunc() { std::cout &lt;&lt; “bind thread func” &lt;&lt; std::endl; }};​​int main(){ A a; std::thread t1(std::bind(&amp;A::threadfunc,&amp;a)); t1.join(); while (true) { std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒 break; } return 0; } 创建一个类A，然后再main函数中将类A中的成员函数绑定到线程对象t1上，运行结果： 1bind thread func ### 仿函数对象 1234567891011121314151617181920#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;class Test&#123;public: void operator()()&#123; cout &lt;&lt; &quot;子线程开始执行！&quot; &lt;&lt; endl; //do something cout &lt;&lt; &quot;子线程执行完毕！&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; // thread t(Test()); 这种写法会编译器会认为是一个函数声明，这个函数带有一个参数(函数指针指向没有参数并返回Test对象的函数) thread t((Test())); //可以使用加小括号，或者使用一只初始化，或者传入命名变量 t.join(); //主线程等待子线程 return 0;&#125; ### lambda表达式 1234567891011121314151617#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; thread t( [] () &#123; cout &lt;&lt; &quot;子线程开始执行！&quot; &lt;&lt; endl; //do something cout &lt;&lt; &quot;子线程执行完毕！&quot; &lt;&lt; endl; &#125; ); t.join(); //主线程等待子线程 return 0;&#125; ### 非静态成员函数，静态成员函数 以下的下写法中是将对象拷贝了一份副本来创建线程。当我们在进行共享数据的管理时，有时候需要传入对象的指针或者地址。而静态成员函数，不需要传入对象，只需要传入类函数地址。根据C++对象模型，这很好理解因为编译器对非静态成员函数的处理需要this指针，而对静态成员函数的处理不需要。 1234567891011121314151617181920#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;class Test&#123;public: void test()&#123; cout &lt;&lt; &quot;子线程开始执行！&quot; &lt;&lt; endl; // do somesthing cout &lt;&lt; &quot;子线程执行完毕！&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Test obj; thread t(&amp;Test::test, obj); //注意写法，传入成员函数地址，还需要传入对象 t.join(); //主线程等待子线程 return 0;&#125; ## 获取线程id 线程标识类型是 std::thread::id 类型。有两种获取id的方法。 方法一：可以通过调用 std::thread 对象的成员函数 get_id() 来获取id。 方法二：在当前线程中使用std::this_thread::get_id()来获取线程id。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;functional&gt;​class A &#123;public: void threadfunc() &#123; std::cout &lt;&lt; &quot;bind thread func&quot; &lt;&lt; std::endl; &#125;&#125;;​​int main()&#123; A a; std::thread t1(std::bind(&amp;A::threadfunc,&amp;a)); std::cout &lt;&lt; &quot;main thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;t1 thread ID is : &quot; &lt;&lt; t1.get_id() &lt;&lt; std::endl; t1.join(); while (true) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒 break; &#125; return 0;&#125; std::this_thread::get_id()获取的是当前线程的ID，t1.get_id()获取的是所创建的t1对象中运行的线程ID，对应的ID分别为： 123main thread ID is : 11932t1 thread ID is : 12076bind thread func 虽然get_id()可以获取线程的ID，但是其返回类型是thread::id，通过std::cout可以输出线程ID，但是这样使用似乎不太方面，要是能转换为整形就好了。其实可以将得到的线程ID写入到ostreamstring流中，转换成string类型，再转换成整形。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;functional&gt;#include &lt;sstream&gt;​class A &#123;public: void threadfunc() &#123; std::cout &lt;&lt; &quot;bind thread func&quot; &lt;&lt; std::endl; &#125;&#125;;​​int main()&#123; A a; std::thread t1(std::bind(&amp;A::threadfunc, &amp;a));​ std::ostringstream os1; os1 &lt;&lt; t1.get_id() &lt;&lt; std::endl; std::string strID = os1.str(); //转换成string类型 int threadID = atoi(strID.c_str()); //转换成int类型 std::cout &lt;&lt; &quot;t1 thread ID is : &quot; &lt;&lt; threadID &lt;&lt; std::endl;​ t1.join(); while (true) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒 break; &#125;​ return 0;&#125; 输出结果： 123t1 thread ID is : 6956bind thread func 参考： https://zhuanlan.zhihu.com/p/157171731 https://www.cnblogs.com/chen-cs/p/13054027.html","categories":[{"name":"多线程","slug":"多线程","permalink":"https://marblemm.gitee.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"字符类型总结区别wchar_t和char","slug":"字符类型总结区别wchar_t和char","date":"2021-08-14T03:07:29.000Z","updated":"2021-08-31T15:36:30.783Z","comments":true,"path":"2021/08/14/字符类型总结区别wchar_t和char/","link":"","permalink":"https://marblemm.gitee.io/2021/08/14/%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93%E5%8C%BA%E5%88%ABwchar_t%E5%92%8Cchar/","excerpt":"","text":"1.区别wchar_t,char,WCHARANSI：即 char(8bit)，可用字符串处理函数：strcat( ),strcpy( ), strlen( )等以str打头的函数。 UNICODE：wchar_t(16bit)是Unicode字符的数据类型，可用字符串处理函数：wcscat(),wcscpy(),wcslen()等以wcs打头的函数。它实际定义在里： 123 typedef unsigned short wchar_t; 另外，在头文件中有这样的定义：typedef wchar_t WCHAR; 所以WCHAR实际就是wchar_t 为了让编译器识别Unicode字符串，必须以在前面加一个“L”,例如: wchar_t *szTest=L&quot;This is a Unicode string.&quot;; 2.TCHAR 在C语言里面提供了 _UNICODE宏（有下划线），在Windows里面提供了UNICODE宏（无下划线），只要定了_UNICODE宏和UNICODE宏，系统就会自 动切换到UNICODE版本，否则，系统按照ANSI的方式进行编译和运行。只定义了宏并不能实现自动的转换，他还需要一系列的字符定义支持。 1234567891． TCHAR 如果定义了UNICODE宏则TCHAR被定义为wchar_t。 typedef wchar_t TCHAR; 否则TCHAR被定义为char typedef char TCHAR;2． LPTSTR 如果定义了UNICODE宏则LPTSTR被定义为LPWSTR。 typedef LPTSTR LPWSTR; 否则TCHAR被定义为char typedef LPTSTR LPSTR; 说明：在使用字符串常量的时候需要使用_TEXT(“MyStr”)或者_T(&quot;&quot;)来支持系统的自动转换。 3.bstr字符串BSTR 4.更进一步的字符串以及其指针的类型定义 由于Win32 API文档的函数列表使用函数的常用名字（例如， “SetWindowText”），所有的字符串都是用TCHAR来定义的。（除了XP中引入的只适用于Unicode的API）。下面列出一些常用的typedefs，你可以在msdn中看到他们。 12345678910type Meaning in MBCS builds Meaning in Unicode buildsWCHAR wchar_t wchar_tLPSTR char* char*LPCSTR const char* const char*LPWSTR wchar_t* wchar_t*LPCWSTR wchar_t* wchar_t*TCHAR TCHAR char wchar_tLPTSTR TCHAR* TCHAR*LPCTSTR const TCHAR* const TCHAR* 5.相互转换wchar_t* 转为 char*123456wchar_t* pwszUnicode = L&quot;Holle&quot;; //wcslen(pwsUnicode)=5int iSize;char* pszMultiByte;//返回接受字符串所需缓冲区的大小，已经包含字符结尾符&#x27;\\0&#x27;iSize = WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, NULL, 0, NULL, NULL); //iSize =wcslen(pwsUnicode)+1=6pszMultiByte = (char*)malloc(iSize*sizeof(char)); //不需要 pszMultiByte = (char*)malloc(iSize*sizeof(char)+1);WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, pszMultiByte, iSize, NULL, NULL); char 转为 wchar_t123456char* pszMultiByte = &quot;Holle&quot;; //strlen(pwsUnicode)=5int iSize; wchar_t* pwszUnicode ; //返回接受字符串所需缓冲区的大小，已经包含字符结尾符&#x27;\\0&#x27;iSize = MultiByteToWideChar(CP_ACP, 0, pszMultiByte , -1, NULL, 0); //iSize =wcslen(pwsUnicode)+1=6pwszUnicode = (wchar_t *)malloc(iSize*sizeof(wchar_t)); //不需要 pwszUnicode = (wchar_t *)malloc((iSize+1)*sizeof(wchar_t))MultiByteToWideChar(CP_ACP, 0, pszMultiByte , -1, pwszUnicode , iSize); char*转换成CString12345678910111213141516171819202122 若将char*转换成CString，除了直接赋值外，还可使用CString::Format进行。例如： char chArray[] = &quot;This is a test&quot;; char * p = &quot;This is a test&quot;; 或 LPSTR p = &quot;This is a test&quot;; 或在已定义Unicode应的用程序中 TCHAR * p = _T(&quot;This is a test&quot;); 或 LPTSTR p = _T(&quot;This is a test&quot;); CString theString = chArray; theString.Format(_T(&quot;%s&quot;), chArray); theString = p;//方法一char *p = &quot;test&quot;;CString str(p);//方法二char * pFileName = &quot;test&quot;; USES_CONVERSION;CString s = A2T(pFileName);//CString s = A2W(pFileName); CString转换成char*12345678910111213141516171819202122232425262728 若将CString类转换成char*(LPSTR)类型，常常使用下列三种方法： 方法一，使用强制转换。例如： CString theString( &quot;This is a test&quot; ); LPTSTR lpsz =(LPTSTR)(LPCTSTR)theString; 方法二，使用strcpy。例如： CString theString( &quot;This is a test&quot; ); LPTSTR lpsz = new TCHAR[theString.GetLength()+1]; _tcscpy(lpsz, theString); 需要说明的是，strcpy(或可移值Unicode/MBCS的_tcscpy)的第二个参数是 const wchar_t* (Unicode)或const char* (ANSI)，系统编译器将会自动对其进行转换。 方法三，使用CString::GetBuffer。例如： CString s(_T(&quot;This is a test &quot;)); LPTSTR p = s.GetBuffer(); // 在这里添加使用p的代码 if(p != NULL) *p = _T(&#x27;\\0&#x27;); s.ReleaseBuffer(); // 使用完后及时释放，以便能使用其它的CString成员函数//方法四CString cstr = _T(&quot;test&quot;)//声明标识USES_CONVERSION;//函数T2A和W2A均支持ATL和MFC中的字符char * pFileName = T2A(cstr); //char * pFileName = W2A(cstr); //也可实现转换//注意：有时候可能还需要添加引用#include &lt;afxpriv.h&gt; BSTR转换成char*123456789101112131415 方法一，使用ConvertBSTRToString。例如： #include #pragma comment(lib, &quot;comsupp.lib&quot;) int _tmain(int argc, _TCHAR* argv[])&#123; BSTR bstrText = ::SysAllocString(L&quot;Test&quot;); char* lpszText2 = _com_util::ConvertBSTRToString(bstrText); SysFreeString(bstrText); // 用完释放 delete[] lpszText2; return 0; &#125; 方法二，使用_bstr_t的赋值运算符重载。例如： _bstr_t b = bstrText; char* lpszText2 = b;//底层还是调的_com_util::ConvertBSTRToString(bstrText);``` ### char*转换成BSTR 方法一，使用SysAllocString等API函数。例如： BSTR bstrText = ::SysAllocString(L”Test”); BSTR bstrText = ::SysAllocStringLen(L”Test”,4); BSTR bstrText = ::SysAllocStringByteLen(“Test”,4); 方法二，使用COleVariant或_variant_t。例如： //COleVariant strVar(“This is a test”); _variant_t strVar(“This is a test”); BSTR bstrText = strVar.bstrVal; 方法三，使用_bstr_t，这是一种最简单的方法。例如： BSTR bstrText = _bstr_t(“This is a test”);//底层还是调的方法五 方法四，使用CComBSTR。例如： BSTR bstrText = CComBSTR(“This is a test”); 或 CComBSTR bstr(“This is a test”); BSTR bstrText = bstr.m_str; 方法五，使用ConvertStringToBSTR。例如： char* lpszText = “Test”; BSTR bstrText = _com_util::ConvertStringToBSTR(lpszText); //使用前需要加上头文件comutil.h 反之可以使用char *p=_com_util::ConvertBSTRToString(b); 1### CString转换成BSTR 通常是通过使用CStringT::AllocSysString来实现。例如： CString str(“This is a test”); BSTR bstrText = str.AllocSysString(); … SysFreeString(bstrText); // 用完释放 123 注意：用完之后必须使用SysFreeString 释放！！！### BSTR转换成CString 方法一： BSTR bstrText = ::SysAllocString(L”Test”); CStringA str; str.Empty(); str = (LPCSTR)bstrText;方法二： BSTR bstrText = ::SysAllocString(L”Test”); CStringA str(bstrText); 12345### CString转_bstr_t``` _bstr_t bstr; CString strSql; bstr = (_bstr_t)strSql; _bstr_t转CString123_bstr_t bstr;CString strSql; strSql = (LPCSTR)bstr; BSTR 转LPCTSTR1234567//方法一：_bstr_t strstr = bstrtext;LPCTSTR lpctstrname = strstr;//方法二:CString str = bstrtext;LPCTSTR lpctstrname = (LPCTSTR)str; LPCTSTR转CString12345678910//方法一：LPCTSTR lpctStr;CString cStr=lpctStr;//方法二：LPCTSTR p; CString str=&quot;hello&quot;; p=str.GetBuffer(str.GetLength()); str.ReleaseBuffer(); CString与LPCWSTR12345678910111213141516171819两者的不同：LPCWSTR 是Unicode字符串指针，初始化时串有多大，申请空间就有多大，以后存贮若超过则出现无法预料的结果，这是它与CString的不同之处。而CString是一个串类，内存空间类会自动管理。CString转换成LPCWSTR方法一：CString strFileName; LPCWSTR lpcwStr = strFileName.AllocSysString();方法二：CString str=_T(&quot;TestStr&quot;); USES_CONVERSION; LPCWSTR lpcwStr = A2CW((LPCSTR)str);MFC中CString和LPSTR是可以通用，其中A2CW表示(LPCSTR) -&gt; (LPCWSTR)，USER_CONVERSION表示用来定义一些中间变量，在使用ATL的转换宏之前必须定义该语句。LPCWSTR转换成CStringLPCWSTR lpcwStr = L&quot;TestWStr&quot;; CString str(lpcwStr); CString转换成LPSTR1234567891011121314151617181920方法一：CString strFileName; LPSTR lpStr = strFileName.GetBuffer(); strFileName.ReleaseBuffer();方法二：CString strFileName; LPSTR lpStr = (LPSTR)(LPCSTR)strFimeName;LPSTR转换成CString: LPSTR lpStr = L&quot;TestStr&quot;; CString str(lpStr);注意：CString和LPCSTR可直接转换，如下: CString str; LPCSTR lpcStr = (LPCSTR)str; ANSI、Unicode和宽字符之间的转换 方法一，使用MultiByteToWideChar将ANSI字符转换成Unicode字符，使用WideCharToMultiByte将Unicode字符转换成ANSI字符。12345678910111213141516171819202122232425//将单字节char*转化为宽字节wchar_t* wchar_t* AnsiToUnicode( const char* szStr ) &#123; int nLen = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, NULL, 0 ); if (nLen == 0) &#123; return NULL; &#125; wchar_t* pResult = new wchar_t[nLen]; MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, pResult, nLen ); return pResult; &#125; //将宽字节wchar_t*转化为单字节char* inline char* UnicodeToAnsi( const wchar_t* szStr ) &#123; int nLen = WideCharToMultiByte( CP_ACP, 0, szStr, -1, NULL, 0, NULL, NULL ); if (nLen == 0) &#123; return NULL; &#125; char* pResult = new char[nLen]; WideCharToMultiByte( CP_ACP, 0, szStr, -1, pResult, nLen, NULL, NULL ); return pResult; &#125; 方法二，使用“_T”将ANSI转换成“一般”类型字符串，使用“L”将ANSI转换成Unicode，而在托管C++环境中还可使用S将ANSI字符串转换成String对象。例如： TCHAR tstr[] = _T(“this is a test”); wchar_t wszStr[] = L”This is a test”; String str = S”This is a test”; 方法三，使用ATL 7.0的转换宏和类。ATL7.0在原有3.0基础上完善和增加了许多字符串转换宏以及提供相应的类，它具有如图3所示的统一形式： 其中，第一个C表示“类”，以便于ATL 3.0宏相区别，第二个C表示常量，2表示“to”，EX表示要开辟一定大小的缓冲。SourceType和DestinationType可以是A、 T、W和OLE，其含义分别是ANSI、Unicode、“一般”类型和OLE字符串。例如，CA2CT就是将ANSI转换成一般类型的字符串常量。下面 是一些示例代码： LPTSTR tstr= CA2TEX&lt;16&gt;(“this is a test”); LPCTSTR tcstr= CA2CT(“this is a test”); wchar_t wszStr[] = L”This is a test”; char* chstr = CW2A(wszStr); https://www.cnblogs.com/zhoug2020/archive/2012/06/13/2547463.html http://www.imkevinyang.com/2010/06/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84.html http://cppblog.com/lizao2/articles/169250.html","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]},{"title":"c++面试总结-STL","slug":"cpp面试总结-STL","date":"2021-08-13T14:51:37.000Z","updated":"2021-08-27T14:41:37.811Z","comments":true,"path":"2021/08/13/cpp面试总结-STL/","link":"","permalink":"https://marblemm.gitee.io/2021/08/13/cpp%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-STL/","excerpt":"","text":"STL常用的容器有哪些以及各自的特点是什么?12345678910111213141.vector:底层数据结构为数组 ，支持快速随机访问。2.list:底层数据结构为双向链表，支持快速增删。3.deque:底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问。4.stack:底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时5.queue:底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）6.priority_queue:的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现7.set:底层数据结构为红黑树，有序，不重复。8.multiset:底层数据结构为红黑树，有序，可重复。 9.map:底层数据结构为红黑树，有序，不重复。10.multimap:底层数据结构为红黑树，有序，可重复。11.hash_set:底层数据结构为hash表，无序，不重复。12.hash_multiset:底层数据结构为hash表，无序，可重复 。13.hash_map :底层数据结构为hash表，无序，不重复。14.hash_multimap:底层数据结构为hash表，无序，可重复。 使用场景 1、如果你需要高效的随机存取，而不在乎插入和删除的效率，使用vector 2、如果你需要大量的插入和删除，而不关心随机存取，则应使用list 3、如果你需要随机存取，而且关心两端数据的插入和删除，则应使用deque。 4、如果你要存储一个数据字典，并要求方便地根据key找value，那么map是较好的选择 5、如果你要查找一个元素是否在某集合内存中，则使用set存储这个集合比较好 说说 vector 和 list 的区别1） vector， 连续存储的容器，动态数组，在堆上分配空间 ； 底层实现：数组。 如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素。 适用场景：经常随机访问，且不经常对非尾节点进行插入删除。 2）list，动态链表，在堆上分配空间，每插入一个元素都会分配空间，每删除一个元素都会释放空间。 底层：双向链表 访问：随机访问性能很差，只能快速访问头尾节点。 适用场景：经常插入删除大量数据 2） vector在中间节点进行插入删除会导致内存拷贝，list不会。 3） vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。 4） vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。 list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。 map 和 set 有什么区别1） map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。 2） map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。 3） set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。 4） map支持下标操作，set不支持下标操作。map可以用key做下标， unordered_map和map 说说区别内部实现机理 map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。 unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的优缺点以及适用处 1234567891011121314map 优点： 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作红黑树，内部实现一个红黑书使得map的很多操作在的时间复杂度下就可以实现，因此效率非常的高缺点： 适用处，对于那些有顺序要求的问题，用map会更高效一些空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间unordered_map 优点： 因为内部实现了哈希表，因此其查找速度非常的快缺点： 适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map哈希表的建立比较耗费时间 STL 中迭代器的作用，有指针为何还要迭代器1） Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 2） 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等，相当于一种智能指针。 3） 迭代器产生原因： Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。 STL 迭代器是怎么删除元素的呢1） 对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器； 2） 对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。 3） 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator， 平衡二叉树（AVL树）和红黑树1）平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。 2）红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑），红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。 3）所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。 1234567891011121314151617请你回答一下map底层为什么用红黑树实现1、红黑树：红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。性质：1. 每个节点非红即黑2. 根节点是黑的;3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;4. 如果一个节点是红色的，则它的子节点必须是黑色的。5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;2、平衡二叉树（AVL树）：红黑树是在AVL树的基础上提出来的。平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。3、红黑树较AVL树的优点：AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。 栈溢出的原因栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数。 1） 局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出，局部变量是存储在栈中的。 2） 递归调用层次太多。 3） 指针或数组越界。例如进行字符串拷贝，或处理用户输入等等。 堆和栈的区别C语言的内存模型分为5个区：栈区、堆区、静态区、常量区、代码区。 1）栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放。栈由系统自动分配，速度快，但是程序员无法控制。 2） 堆区：就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作。一般是由程序员分配释放，未被释放可能引起内存泄漏。堆是有程序员自己分配，速度较慢，容易产生碎片，不过用起来方便。 3）全局变量和静态变量的存储是放在一块的。 4）常量区：常量存储在这里，不允许修改。 5） 代码区：存放函数体的二进制代码。 哈希表（hash表）哈希表的实现主要包括构造哈希和处理哈希冲突：构造哈希，主要包括直接地址法，除留余数法。 处理哈希冲突：当哈希表关键字集合很大时，关键字值不同的元素可能会映射到哈希表的同一地址上，这样的现象称为哈希冲突。常用的解决方法有： 1） 开放定址法，冲突时，用某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。（如，线性探测，平方探测） 2） 再哈希法：当发生冲突时，用另一个哈希函数计算地址值，直到冲突不再发生。 3） 链地址法：将所有哈希值相同的key通过链表存储，key按顺序插入链表中。","categories":[{"name":"c++面试","slug":"c-面试","permalink":"https://marblemm.gitee.io/categories/c-%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"string和char*的区别","slug":"string和char-的区别","date":"2021-08-13T12:52:19.000Z","updated":"2021-08-13T14:50:32.436Z","comments":true,"path":"2021/08/13/string和char-的区别/","link":"","permalink":"https://marblemm.gitee.io/2021/08/13/string%E5%92%8Cchar-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1、定义：string：string是STL当中的一个容器，对其进行了封装，所以操作起来非常方便。 char*：char *是一个指针，可以指向一个字符串数组，至于这个数组可以在栈上分配，也可以在堆上分配，堆得话就要你手动释放了。 2、区别：string的内存管理是由系统处理，除非系统内存池用完，不然不会出现这种内存问题。char *的内存管理由用户自己处理，很容易出现内存不足的问题。 当我们要存一个串，但是不知道其他需要多少内存时， 用string来处理就最好不过了。当你知道了存储的内存的时候，可以用char *，但是不如用string的好，用指针总会有隐患。 用string还可以使用各种成员函数来处理串的每一个字符，方便处理。用char *处理串，就不如string的方便了，没有相应的函数来直接调用，而是要自己编写函数来完成串的处理，而且处理过程中用指针还很容易出现内存问题。 char *s=”string”的内容是不可以改的；char s[10]=”string”的内容是可以改的 const char* c_str(); c_str()函数返回一个指向C字符串的指针，该指针指向内存内容和string 相同。因为c语言不支持string类型，故为了在c++兼容C字符串，提供了c_str()函数来实现转换。注意一定要使用strcpy()函数来操作c_str()；c_str()返回的是一个临时指针，不能对其进行操作。 char ch[20]; string s=”123456”; strcpy(ch,s.c_str()); c_str()以char* 形式传回string内含字符串 如果一个函数要求char*参数，可以使用c_str()方法 3、注意：当我们定义了一个string，就不能用scanf(“%s”,s)和printf(“%s”,s)输入输出。主要是因为%s要求后面是对象的首地址 4、转化：当 string 直接转化成 const char *时，可以通过两个函数c_str()，data成员函数，其中c_str()函数返回一个以’\\0’结尾的字符数组，而data()仅返回字符串内容，而不含有结束符’\\0’。","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]},{"title":"c++编程书籍总结","slug":"cpp编程书籍总结","date":"2021-08-11T12:49:13.000Z","updated":"2021-08-27T14:43:21.847Z","comments":true,"path":"2021/08/11/cpp编程书籍总结/","link":"","permalink":"https://marblemm.gitee.io/2021/08/11/cpp%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.入门书籍C++ Primer 中文版（第5版）C++ Primer (Fifth Edition)C++ Primer Plus 中文版（第六版）C++ Primer Plus (Sixth Edition) 2.进阶书籍Thinking in C++A Tour Of C++The C++ Standard Library: A Tutorial and ReferenceEffective STL泛型编程与STLSTL源码剖析 3.高阶书籍深度探索C对象模型Design Patterns:Elements of Reusable Object-Oriented software设计模式：可复用面向对象软件的基础STL 源码剖析The C Standard : Incorporating Technical Corrigendum No. 1Preprocessor C++(More)Effective C++(More)Exceptional C++C++ TemplatesCore C++ A Software Engineering Approach高质量C++编程指南——上海贝尔标准编程文档","categories":[{"name":"书籍","slug":"书籍","permalink":"https://marblemm.gitee.io/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[]},{"title":"c++面试总结（二）","slug":"cpp面试总结（二）","date":"2021-08-10T13:28:09.000Z","updated":"2021-08-27T14:42:51.327Z","comments":true,"path":"2021/08/10/cpp面试总结（二）/","link":"","permalink":"https://marblemm.gitee.io/2021/08/10/cpp%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"1.有哪几种情况只能用intialization list 而不能用assignment?答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。 2. C++是不是类型安全的？答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。 3. main 函数执行以前，还会执行什么代码？答案：全局对象的构造函数会在main 函数之前执行。 4. 描述内存分配方式以及它们的区别?1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。 2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。 3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。 5.请说出const与#define 相比，有何优点？答案： const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。 1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。 2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。 6.简述数组与指针的区别？数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。 1234567891011121314151617181920212223242526272829(1)修改内容上的差别char a[] = “hello”;a[0] = ‘X’;char *p = “world”; // 注意p 指向常量字符串p[0] = ‘X’; // 编译器不能发现该错误，运行时错误(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。char a[] = &quot;hello world&quot;;char *p = a;cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节计算数组和指针的内存容量void Func(char a[100])&#123;cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节&#125; 7： int (*s[10])(int) 表示的是什么？int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 8：栈内存与文字常量区12345678910111213141516171819char str1[] = &quot;abc&quot;; char str2[] = &quot;abc&quot;; const char str3[] = &quot;abc&quot;; const char str4[] = &quot;abc&quot;; const char *str5 = &quot;abc&quot;; const char *str6 = &quot;abc&quot;; char *str7 = &quot;abc&quot;; char *str8 = &quot;abc&quot;; cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;//0 分别指向各自的栈内存 cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;//0 分别指向各自的栈内存 cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;//1指向文字常量区地址相同 cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;//1指向文字常量区地址相同 结果是：0 0 1 1 解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。 9：将程序跳转到指定内存地址要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？ 123456789 *((void (*)( ))0x100000 ) ( ); 首先要将0x100000强制转换成函数指针,即: (void (*)())0x100000 然后再调用它: *((void (*)())0x100000)(); 用typedef可以看得更直观些: typedef void(*)() voidFuncPtr; *((voidFuncPtr)0x100000)(); 10：int id[sizeof(unsigned long)];这个对吗？为什么？ 答案:正确 这个 sizeof是编译时运算符，编译时就确定了 ,可以看成和机器有关的常量。 当sizeof的参数是数组名时，计算的是整个数组的存储大小；当sizeof的参数是指针时，计算的是指针的大小（8字节，64位系统） 11：引用与指针有什么区别？【参考答案】 引用必须被初始化，指针不必。 引用初始化以后不能被改变，指针可以改变所指的对象。 不存在指向空值的引用，但是存在指向空值的指针。 12：基类的析构函数不是虚函数，会带来什么问题？【参考答案】派生类的析构函数用不上，会造成资源的泄漏。 13：全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？【参考答案】 生命周期不同： 全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。 操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。 STL中排序算法的实现是什么解答：STL中的sort()，在数据量大时，采用quicksort，分段递归排序；一旦分段后的数量小于某个门限值，改用Insertion sort，避免quicksort深度递归带来的过大的额外负担，如果递归层次过深，还会改用heapsort。 为什么函数参数的入栈的顺序是从右往左因为好多函数是不定参数个数的，比如最常用的printf，所以需要参数的入栈顺序是从右往左。 5. static的用法和作用？1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可） 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。 2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。 3.static的第三个作用是默认初始化为0（static变量） 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。 4.static的第四个作用：C++中的类成员声明static 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问； 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内； 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝； 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。 类内： static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化； 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员； static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function 8. const成员函数的理解和应用？① const Stock &amp; Stock::topval (②const Stock &amp; s) ③const ①处const：确保返回的Stock对象在以后的使用中不能被修改 ②处const：确保此方法不修改传递的参数 S ③处const：保证此方法不修改调用它的对象，const对象只能调用const成员函数,不能调用非const函数 11. extern用法？ extern修饰变量的声明 如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。 extern修饰函数的声明 如果文件a.c需要引用b.c中的函数，比如在b.c中原型是int fun(int mu)，那么就可以在a.c中声明extern int fun（int mu），然后就能使用fun来做任何事情。就像变量的声明一样，extern int fun（int mu）可以放在a.c中任何地方，而不一定非要放在a.c的文件作用域的范围中。 extern修饰符可用于指示C或者C＋＋函数的调用规范。 比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。 21. 构造函数和析构函数可以调用虚函数吗，为什么 在C++中，提倡不在构造函数和析构函数中调用虚函数； 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本； 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编； 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。 参考： https://zhuanlan.zhihu.com/p/143177919","categories":[{"name":"c++面试","slug":"c-面试","permalink":"https://marblemm.gitee.io/categories/c-%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"c++面试总结（一）","slug":"cpp面试总结（一）","date":"2021-08-09T15:50:50.000Z","updated":"2021-08-27T14:42:07.081Z","comments":true,"path":"2021/08/09/cpp面试总结（一）/","link":"","permalink":"https://marblemm.gitee.io/2021/08/09/cpp%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"1.new、delete、malloc、free关系delete会调用对象的析构函数,和new对应free只会释放内存，new调用构造函数。malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。 2.delete与 delete []区别delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套 （1）. 针对简单类型 使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可 如： 123456int *a = new int[10];delete a;delete [] a;此种情况中的释放效果相同，原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间(在分配过程中 系统会记录分配内存的大小等信息，此信息保存在结构体_CrtMemBlockHeader中，具体情况可参看VC安装目录下CRT\\SRC\\DBGDEL.cpp) （2）. 针对类Class，两种方式体现出具体差异 123456789101112131415161718 当你通过下列方式分配一个类对象数组： class A &#123; private: char *m_cBuffer; int m_nLen; public: A()&#123; m_cBuffer = new char[m_nLen]; &#125; ~A() &#123; delete [] m_cBuffer; &#125; &#125;; A *a = new A[10]; delete a; //仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏 delete [] a; //调用使用类对象的析构函数释放用户自己分配内存空间并且 释放了a指针指向的全部内存空间所以总结下就是，如果ptr代表一个用new申请的内存返回的内存空间地址，即所谓的指针，那么： delete ptr 代表用来释放内存，且只用来释放ptr指向的内存。 delete[] rg 用来释放rg指向的内存，！！还逐一调用数组中每个对象的destructor！！ 对于像int/char/long/int*/struct等等简单数据类型，由于对象没有destructor，所以用delete 和delete [] 是一样的！但是如果是C++对象数组就不同了！ 3.子类析构时要调用父类的析构函数吗？析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。 4.多态，虚函数，纯虚函数多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现； 在程序编译时多态性体现在函数和运算符的重载上； 虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。 纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。 从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。 抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。 5.什么是“引用”？申明和使用“引用”要注意哪些问题？答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。 6.将“引用”作为函数参数有哪些特点？（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。 （2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。 （3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。 7.dynamic_cast和static_cast的区别static_cast相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法： 1 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 2 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。 3 把空指针转换成目标类型的空指针。 4 把任何类型的表达式转换成void类型。 注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性 12345678910111213141516171819202122232425262728基本类型数据转换举例如下：char a = &#x27;a&#x27;;int b = static_cast&lt;char&gt;(a);//正确，将char型数据转换成int型数据double *c = new double;void *d = static_cast&lt;void*&gt;(c);//正确，将double指针转换成void指针int e = 10;const int f = static_cast&lt;const int&gt;(e);//正确，将int型数据转换成const int型数据const int g = 20;int *h = static_cast&lt;int*&gt;(&amp;g);//编译错误，static_cast不能转换掉g的const属性类上行和下行转换：class Base&#123;&#125;;class Derived : public Base&#123;&#125;Base* pB = new Base();if(Derived* pD = static_cast&lt;Derived*&gt;(pB))&#123;&#125;//下行转换是不安全的(坚决抵制这种方法)Derived* pD = new Derived();if(Base* pB = static_cast&lt;Base*&gt;(pD))&#123;&#125;//上行转换是安全的 dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）。 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。尽量少使用转型操作，尤其是dynamic_cast，耗时较高，会导致性能的下降，尽量使用其他方法替代。 8.将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?格式：类型标识符 &amp;函数名（形参列表及类型说明）{ //函数体 } 好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error! 注意事项： （1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。 （2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。 （3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。 （4）流操作符重载返回值申明为“引用”的作用： 流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl; 因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。 12345678910111213141516171819202122232425262728293031＃include&lt;iostream.h&gt;int &amp;put(int n);int vals[10];int error=-1;void main()&#123;put(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10; put(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20; cout&lt;&lt;vals[0]; cout&lt;&lt;vals[9];&#125; int &amp;put(int n)&#123;if (n&gt;=0 &amp;&amp; n&lt;=9 ) return vals[n]; else &#123; cout&lt;&lt;&quot;subscript error&quot;; return error; &#125;&#125; （5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。 9、结构与联合有和区别？(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。 (2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。 10.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？常考的题目。从定义上来说： 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。 重写：是指子类重新定义父类虚函数的方法。 从实现原理上来说： 重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！ 重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。","categories":[{"name":"c++面试","slug":"c-面试","permalink":"https://marblemm.gitee.io/categories/c-%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"git命令整理-导图","slug":"git命令整理-导图","date":"2021-08-09T15:28:16.000Z","updated":"2021-08-09T15:30:36.829Z","comments":true,"path":"2021/08/09/git命令整理-导图/","link":"","permalink":"https://marblemm.gitee.io/2021/08/09/git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86-%E5%AF%BC%E5%9B%BE/","excerpt":"","text":"git命令整理-导图","categories":[{"name":"git","slug":"git","permalink":"https://marblemm.gitee.io/categories/git/"}],"tags":[]},{"title":"git命令整理-分支","slug":"git命令整理-分支","date":"2021-08-09T15:21:59.000Z","updated":"2021-08-09T15:30:42.034Z","comments":true,"path":"2021/08/09/git命令整理-分支/","link":"","permalink":"https://marblemm.gitee.io/2021/08/09/git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86-%E5%88%86%E6%94%AF/","excerpt":"","text":"git分支命令git branch git branch可以用来列出分支,创建分支和删除分支. git branch -v可以看见每一个分支的最后一次提交. git branch: 列出本地所有分支,当前分支会被星号标示出. git branch -a 加上-a参数列出本地和远程所有分支，远程分支会用红色表示出来（如果你开了颜色支持的话） git branch -av git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). git branch -d (branchname): 删除一个分支.（已合并） git branch -D (branchname): 删除一个分支.（未合并） git push --delete origin [branch] 删除远程分支 git branch -m devel develop 重命名本地分支 git checkout git checkout (branchname) 切换到一个分支. git checkout -b (branchname): 创建并切换到新的分支. 这个命令是将git branch newbranch和git checkout newbranch合在一起的结果. checkout还有另一个作用:替换本地改动: git checkout --&lt;filename&gt; 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响. 注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的. git merge 把一个分支merge进当前的分支. git merge [alias]/[branch] 把远程分支merge到当前分支. 如果出现冲突,需要手动修改,可以用git mergetool. 解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved. git tag tag a point in history as import. 会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag. 比如: git tag v1.0 git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag. 当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息. 我们可以利用commit SHA来给一个过去的提交打tag: git tag -a v0.9 XXXX push的时候是不包含tag的,如果想包含,可以在push时加上--tags参数. fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上--tags选项. git remote list, add and delete remote repository aliases. 因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list. git remote: 列出remote aliases. 如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin. git remote -v:可以看见每一个别名对应的实际url. git remote add [alias] [url]: 添加一个新的remote repo. git remote rm [alias]: 删除一个存在的remote alias. git remote rename [old-alias] [new-alias]: 重命名. git remote set-url [alias] [url] 通过命令更新远程url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址. 修改远程仓库地址方法： 以下均以项目git_test为例： 老地址：http://192.168.1.12:9797/john/git_test.git 新地址：http://192.168.100.235:9797/john/git_test.git 远程仓库名称： origin 方法一 通过命令直接修改远程地址 进入git_test根目录git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址 git remote set-url origin http://192.168.100.235:9797/john/git_test.git 方法二 通过命令先删除再添加远程仓库 进入git_test根目录 git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址 git remote rm origin git remote add origin http://192.168.100.235:9797/john/git_test.git 方法三 直接修改配置文件 进入git_test/.git 修改 config 中的 [remote “origin”]下面的url即可 git fetch download new branches and data from a remote repository. 可以git fetch [alias]取某一个远程repo,也可以git fetch --all取到全部repo fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pull fetch from a remote repo and try to merge into the current branch. pull == fetch + merge FETCH_HEAD git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit. 如果使用--rebase参数,它会执行git rebase来取代原来的git merge. git rebase --rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上. rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要: git rebase --continue就会继续打余下的补丁. git rebase --abort将会终止rebase,当前分支将会回到rebase之前的状态. git push push your new branches and data to a remote repository. git push [alias] [branch] 将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支. 如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来. git push --delete origin develop 删除远程develop分支 git reflog git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化. 当git reflog不指定引用的时候,默认列出HEAD的reflog. HEAD@&#123;0&#125;代表HEAD当前的值,HEAD@&#123;3&#125;代表HEAD在3次变化之前的值. git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中.","categories":[{"name":"git","slug":"git","permalink":"https://marblemm.gitee.io/categories/git/"}],"tags":[]},{"title":"git命令整理-提交","slug":"git命令整理-提交","date":"2021-08-08T03:15:12.000Z","updated":"2021-08-09T15:30:32.139Z","comments":true,"path":"2021/08/08/git命令整理-提交/","link":"","permalink":"https://marblemm.gitee.io/2021/08/08/git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86-%E6%8F%90%E4%BA%A4/","excerpt":"","text":"git 常用命令整理git init 在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. git clone 获取一个url对应的远程Git repo, 创建一个local copy. 一般的格式是git clone [url]. clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定. git status 查询repo的状态. git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言. git log show commit history of a branch. git log --oneline --number: 每条log只显示一行,显示number条. git log --oneline --graph:可以图形化地表示出分支合并历史. git log branchname可以显示特定分支的log. git log --oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号). git log --decorate会显示出tag信息. git log --author=[author name] 可以指定作者的提交历史. git log --since --before --until --after 根据提交时间筛选log. --no-merges可以将merge的commits排除在外. git log --grep 根据commit信息过滤log: git log --grep=keywords 默认情况下, git log --grep --author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上--all-match的option. git log -S: filter by introduced diff. 比如: git log -SmethodName (注意S和后面的词之间没有等号分隔). git log -p: show patch introduced at each commit. 每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看. 另一种方法是git show [SHA]. git log --stat: show diffstat of changes introduced at each commit. 同样是用来看改动的相对信息的,--stat比-p的输出更简单一些. git add 在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动. git add . 会递归地添加当前工作目录中的所有文件. git diff 不加参数的git diff: show diff of unstaged changes. 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容. 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用: git diff --cached 命令. show diff of staged changes. (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的). git diff HEAD show diff of all staged or unstated changes. 也即比较woking directory和上次提交之间所有的改动. 如果想看自从某个版本之后都改动了什么,可以用: git diff [version tag] 跟log命令一样,diff也可以加上--stat参数来简化输出. git diff [branchA] [branchB]可以用来比较两个分支. 它实际上会返回一个由A到B的patch,不是我们想要的结果. 一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令: git diff [branchA]…[branchB]给出的. 实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果. git commit 提交已经被add进来的改动. git commit -m “the commit message&quot; git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下. git commit --amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消. git reset undo changes and commits. 这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本. git reset HEAD: unstage files from index and reset pointer to HEAD 这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD -- filename, 这个- - 也可以不加. git reset --soft move HEAD to specific commit reference, index and staging are untouched. git reset --hard unstage files AND undo any changes in the working directory since last commit. 使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态. 这里的HEAD可以被写成任何一次提交的SHA-1. 不带soft和hard参数的git reset,实际上带的是默认参数mixed. 总结: git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容. git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容. git reset --hard id.是将git的HEAD变了,文件也变了. 按改动范围排序如下: soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working) git revert 反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了. git revert HEAD: 撤销最近的一个提交. git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交. git rm git rm file: 从staging区移除文件,同时也移除出工作目录. git rm --cached: 从staging区移除文件,但留在工作目录中. git rm --cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树. git clean git clean是从工作目录中移除没有track的文件. 通常的参数是git clean -df: -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行. git mv git rm - - cached orig; mv orig new; git add new git stash 把当前的改动压入一个栈. git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处. git stash list会显示这个栈的list. git stash apply:取出stash中的上一个项目(stash@&#123;0&#125;),并且应用于当前的工作目录. 也可以指定别的项目,比如git stash apply stash@&#123;1&#125;. 如果你在应用stash中项目的同时想要删除它,可以用git stash pop 删除stash中的项目: git stash drop: 删除上一个,也可指定参数删除指定的一个项目. git stash clear: 删除所有项目.","categories":[{"name":"git","slug":"git","permalink":"https://marblemm.gitee.io/categories/git/"}],"tags":[]},{"title":"git命令整理-配置","slug":"git命令整理-配置","date":"2021-08-08T02:49:54.000Z","updated":"2021-08-09T15:26:03.785Z","comments":true,"path":"2021/08/08/git命令整理-配置/","link":"","permalink":"https://marblemm.gitee.io/2021/08/08/git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"git config 查看配置信息123456789101112131415161. 查看git配置信息，列表中可以查看git的设置选项$ git config --list 2.查看git用户名、密码、邮箱的配置$ git config user.name$ git config user.email3.设置git用户名、密码、邮箱的配置$ git config user.name &quot;freedom&quot;$ git config user.password &quot;123456&quot;$ git config user.email &quot;1548429568@qq.com&quot;设置全局模式（推荐）git config --global user.name [username]git config --global user.email [email] 设置记住密码（默认15分钟）12345678git config --global credential.helper cache如果想自己设置时间，可以这样做：git config credential.helper &#x27;cache --timeout=3600&#x27;这样就设置一个小时之后失效长期存储密码：git config --global credential.helper store git忽略项gitegnore配置在git中如果想忽略掉某个文件， 不让这个文件提交到版本库中，可以使用修改 .gitignore 文件的方法。这个文件每一行保存了一个匹配的规则 例如 12345678# 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 另外 git 提供了一个全局的 .gitignore你可以在你的用户目录下创建 ~/.gitignoreglobal 文件，以同样的规则来划定哪些文件是不需要版本控制的。需要执行git config –global core.excludesfile ~/.gitignoreglobal来使得它生效。 另外 git 还提供了另一种 exclude 的方式来做同样的事情，不同的是 .gitignore 这个文件本身会提交到版本库中去。用来保存的是公共的需要排除的文件。而 .git/info/exclude 这里设置的 则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。 但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交,所以项目创建的时候就把ignore文件加上，如果没加上，此时也可以把要忽略的文件先删除，然后把ignore加上要忽略的文件，提交到服务器，此后再提交时，要忽略的文件就不会提交上去了","categories":[{"name":"git","slug":"git","permalink":"https://marblemm.gitee.io/categories/git/"}],"tags":[]},{"title":"从新电脑根据hexo部署到github","slug":"从新电脑根据hexo部署到github","date":"2021-08-04T14:07:48.000Z","updated":"2021-10-25T15:11:25.929Z","comments":true,"path":"2021/08/04/从新电脑根据hexo部署到github/","link":"","permalink":"https://marblemm.gitee.io/2021/08/04/%E4%BB%8E%E6%96%B0%E7%94%B5%E8%84%91%E6%A0%B9%E6%8D%AEhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/","excerpt":"","text":"marblemm.github.io个人博客 http://marblemm.github.io hexo部署说明准备环境1、安装git 2、设置ssh keygithub设置添加SSH 3、安装nodejs ——-windows：nodejs选择LTS版本就行了。 验证环境打开cmd窗口，输入命令 123git --versionnode -vnpm -v 如果出现，类似如下图所示，说明环境正确 4、 安装hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。输入命令 12npm install -g cnpm --registry=https://registry.npm.taobao.org #使用淘宝镜像，国内速度会比较快npm install hexo-cli -g #安装hexo 然后用hexo -v查看一下版本，至此就全部安装完了。 本地发布1234hexo g #生成静态主页hexo s #启动服务hexo d #部署静态页面推送到GitHub仓库hexo n &quot;博客名字&quot; #生成文章","categories":[{"name":"git","slug":"git","permalink":"https://marblemm.gitee.io/categories/git/"}],"tags":[]},{"title":"c++ 开源项目-入门","slug":"cpp开源项目-入门","date":"2021-08-04T13:16:23.537Z","updated":"2021-09-11T14:43:23.221Z","comments":true,"path":"2021/08/04/cpp开源项目-入门/","link":"","permalink":"https://marblemm.gitee.io/2021/08/04/cpp%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-%E5%85%A5%E9%97%A8/","excerpt":"","text":"CPlusPlusThingsCPlusPlusThings 是国人开源一个 C++ 学习项目。它系统地将 C++ 学习分为了【基础进阶】、【实战系列】、【C++2.0 新特性】、【设计模式】和【STL 源码剖析】、【并发编程】、【C++ 惯用法】、【学习课程】、【工具】、【拓展】。 作为一个全面系统的 C++ 学习项目，CPlusPlusThings 是优秀的，它合理地安排了 10 Days 的实战部分，在实战中了解语法和函数用法，唯一不足的是，在注释部分有些不尽人意，对部分新手程序员并不是很友好GitHub 地址 MyTinySTL当你学习完 C++ 的“书本”知识后，是不是有些手痒了呢？MyTinySTL 这个注释详细、实践夯实基础的项目便是你 C++ 学习之旅的下一站。作为新手练习用途，MyTinySTL 的作者 Alinshans 用 C++11 重新复写了一个小型 STL（容器库＋算法库）。代码结构清晰规范、包含中文文档与注释，并且自带一个简单的测试框架，适合 C++ 新手来实践一番。GitHub 地址 calculator微软开源的 Windows 系统预装的计算器工具。该工具提供标准、科学、程序员计算器的功能，以及各种度量单位和货币之间的转换功能。快来看看微软工程师编写的代码吧！学习大厂的编码规范、项目结构之类的，提高阅读源码的能力。英文的项目且没有讲解部分，需要通过阅读源码学习，难度较高。GitHub 地址 TinytetrisTinytetris 是一个用 C++ 编写的终端版俄罗斯方块游戏。它提供了两个版本的源码，分为注释版和库版，注释较多易于理解和学习。GitHub 地址 Google开源代码规范GitHub 地址 现代 C++：modern-cpp-tutorialmodern-cpp-tutorial 是现代 C++ 教程，它的目的是提供关于现代 C++（2020 年前）的相关特性的全面介绍。除了介绍了代码之外，它还尽可能简单地介绍了其技术需求的历史背景，这对理解为什么会出现这些特性提供了很大的帮助。 GitHub 地址 数独游戏一个简单的命令行数独游戏GitHub 地址 c++设计模式汇总c++的设计模式GitHub 地址","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"}],"tags":[]}],"categories":[{"name":"com","slug":"com","permalink":"https://marblemm.gitee.io/categories/com/"},{"name":"cmake","slug":"cmake","permalink":"https://marblemm.gitee.io/categories/cmake/"},{"name":"tool","slug":"tool","permalink":"https://marblemm.gitee.io/categories/tool/"},{"name":"c++","slug":"c","permalink":"https://marblemm.gitee.io/categories/c/"},{"name":"多线程","slug":"多线程","permalink":"https://marblemm.gitee.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"c++面试","slug":"c-面试","permalink":"https://marblemm.gitee.io/categories/c-%E9%9D%A2%E8%AF%95/"},{"name":"书籍","slug":"书籍","permalink":"https://marblemm.gitee.io/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"git","slug":"git","permalink":"https://marblemm.gitee.io/categories/git/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"https://marblemm.gitee.io/tags/cmake/"}]}