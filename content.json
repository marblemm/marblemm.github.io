{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://marblemm.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-08-08T09:14:53.702Z","updated":"2021-08-08T09:14:53.702Z","comments":false,"path":"about/index.html","permalink":"https://marblemm.github.io/about/index.html","excerpt":"","text":"c++开发"},{"title":"分类","date":"2021-08-08T09:12:54.798Z","updated":"2021-08-01T10:13:30.755Z","comments":false,"path":"categories/index.html","permalink":"https://marblemm.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-08-08T08:54:09.245Z","updated":"2021-08-08T08:54:09.245Z","comments":true,"path":"links/index.html","permalink":"https://marblemm.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"字符串BSTR","slug":"字符串BSTR","date":"2021-08-29T15:57:04.000Z","updated":"2021-08-30T11:15:41.239Z","comments":true,"path":"2021/08/29/字符串BSTR/","link":"","permalink":"https://marblemm.github.io/2021/08/29/%E5%AD%97%E7%AC%A6%E4%B8%B2BSTR/","excerpt":"","text":"BSTR为什么需要BSTR COM是一种跨编程语言的平台，需要提供语言无关的数据类型。多数编程语言有自己的字符串表示。 C++ 字符串是以0结束的ASCII或Unicode字符数组。 Visual Basic字符串是一个ASCII字符数组加上表示长度的前缀。 Java字符串是以0结束的Unicode字符数组。 需要定义一种通用的字符串类型，可以很容易的匹配到不同编程语言。在C++中，就是BSTR。 什么是BSTR BSTR是“Basic STRing”的简称，微软在COM/OLE中定义的标准字符串数据类型。 对于C++，Windows头文件wtypes.h中定义如下： typedef wchar_t WCHAR; typedef WCHAR OLECHAR; typedef OLECHAR __RPC_FAR *BSTR;; 使用以Null结尾的简单字符串在COM component间传递不太方便。因此，标准BSTR是一个有长度前缀和null结束符的OLECHAR数组。BSTR的前4字节是一个表示字符串长度的前缀。BSTR长度域的值是字符串的字节数，并且不包括0结束符。 由于是Unicode串，所以字符数是字节数的一半。这种方式的优点是允许程序员在BSTR串中间嵌入NULL字符。但是，BSTR的前四个字节表示长度，而OLECHAR数组的前四字节表示前两个字符。这种情况下，对于C++程序，如何实现BSTR和OLECHAR的交换？答案是COM提供了两个BSTR分配用的API：SysAllocString / SysReallocString。函数返回的指针指向BSTR的第一个字符，而不是BSTR在内存的第一个字节。 BSTR的特殊性BSTR字符串可以内嵌零个或多个NULL，因为决定其长度的不是NULL，而是其前缀保存的数值，所以不能以NULL来判断字符串的结束。； 必须用SysAllocString()和SysFreeString（）函数族来分配和释放，用SysStringLen()等取得字符串的长度； BSTR相关函数族内存分配和重分配函数 SysAllocString SysAllocStringLen SysAllocStringByteLen SysReAllocString SysReAllocStringLen 注：通过以上函数分配空间的同时将根据字符串实际占用的字节数填写前缀 字符串释放函数 SysFreeString 注：这个函数的参数可以传入NULL，即在调用此函数时可以不用判断参数是否为NULL 字符串（占用空间）长度函数 SysStringLen SysStringByteLen 如何避免BSTR造成的内存泄漏 对于BSTR的管理（申请、释放和计算长度）严格使用上述对应的函数族，不要使用new、delete、CoTaskMemAlloc、CoTaskMemFree、sizeof 等。 不要在BSTR字符串中嵌入NULL 定义BSTR时要赋初值NULL BSTR bstr = NULL; 调用SysFreeString后要给bstr赋NULL SysFreeString(bstr)； bstr = NULL; 不要给BSTR直接初始化字符串 BSTR bstr = L“kkkkkk”;//BSTR bstr = SysAllocString (L“kkkkkk”); 因为直接初始化字符串时前缀的值可能是一个随机数，这样的话，其他地方使用这个BSTR时将无法决定出字符串的长度，特别在跨进程传送数据时将会出现致命错误。 在给一个BSTR赋值前，如果不能确定它目前是否指向一个有效的空间，最好先调一下SysFreeString，如： SysFreeString（bstr）; bstr = SysAllocString(L“kkkkkk”); 不要将一个BSTR通过“=”赋给另一个BSTR bstr1 = bstr2;//bstr1 = SysAllocString(bstr2); 避免调用SysFreeString（bstr1）和SysFreeString（bstr2）对同一块内存空间释放两次。 参数为[out]的BSTR注意点比如函数GetBSTR([out] BSTR* bstr) 对于客户端 BSTR bstr = NULL；// 传入的bstr必须为NULL GetBSTR(&amp;bstr); 。。。。。。 SysFreeString（bstr）；// 使用完bstr后别忘了释放 bstr = NULL; 对于服务端 HRESULT GetBSTR(BSTR* bstr) &#123; // 一般来说，传入的bstr不指向任何空间应该由客户端保证的，所以下面的判断和释放不是必须的，但有的话可能更安全。 if ( NULL != *bstr ) SysFreeString（*bstr）； // 创建成员变量的拷贝，不要将其值直接给出去（特别对于进程内组件） *bstr = m_bstr;// *bstr = SysAllocString( m_str ); &#125; 参数为[in]的BSTR注意点HRESULT SetBSTR(/*[in]*/ BSTR bstr)&#123; // 如果服务器需要保存传入的bstr供以后使用，必须将成员变量释放，然后重新分配。 SysFreeString(m_bstr); m_bstr = bstr; // m_bstr = SysAllocString( bstr ); &#125; 参数为[out]的数据结构中包含BSTR的注意点typedef struct kk&#123; long i; BSTR bstr; &#125; KK; KK param; param.bstr = NULL; GetKK(&amp;param); 。。。。。。 SysFreeString（param .bstr）；// 这种内嵌在结构体内的BSTR非常容易忽略释放 param .bstr = NULL; BSTR作为SysAllocString或SysReAllocString的参数时的注意点如果bstr作为SysAllocString或SysReAllocString的参数传入，并且不确定这个传入的bstr是否包含内嵌NULL时，为保险起见，请务必改用下面两函数。 SysAllocStringLen SysReAllocStringLen 原因：因为上述4个函数的参数类型都是OLECHAR FAR* 而不是BSTR，但后两个函数多了传入数量的参数。 BSTR的ATL封装类CCOMBSTR 建议：必须在非常清楚CComBSTR各个函数（特别是赋值操作符和构造函数）如何使用和注意事项的情况下才使用它，否则建议使用BSTR，因为使用不慎非常容易造成内存泄漏。 BSTR是一个带长度前缀的字符串,主要由操作系统来管理的,所以要用api.主要用来和VB打交道的(VB里的string就是指它)要操作它的API函数有很多.比如SysAllocString,SysFreeString等等. vc里封装它的类如_bstr_t,及ATL中的CComBSTR等. 一个 BSTR 由头部和字符串组成，头部包含了字符串的长度信息，字符串中可以包含嵌入的 null 值。 BSTR 是以指针的形式进行传递的。(指针是一个变量，包含另外一个变量的内存地址，而不是数据。) BSTR 是 Unicode 的，即每个字符需要两个字节。 BSTR 通常以两字节的 null 字符结束。 wstr是宽字符，以双字节表示一个字符 bstr是为了与原先的basic字符兼容，它的最前面的4个字节为其长度，以’\\0’结束. ATL基础BSTR CComBSTR SysAllocStringATL提供了 BSTR 和 CComBSTR ，还有OLEAUTO32.DLL导出一个API叫SysAllocString。这些东西有什么意思？有什么用呢？ BSTR 是一个typedef，你可以理解为 typedef WCHAR* BSTR它就是一个指针。所以 BSTR p = L”hello”;编译是没问题的。不过不推荐这么做。因为按MSDN，BSTR应该只接收 SysAllocString 的返回值。 就是说，第一，SysAllocString 的返回值是一个 BSTR 第二，如果我们看到一个BSTR，那它应该总从由一个 SysAllocString 得到的，它总是应该用 SysFreeString 释放。 我们可以想像，SysAllocString 实际上做了一个malloc分配了一块内存，然后把内存长度放第一个DWORD，把这个DWORD后面位置作为BSTR返回。因为在BSTR减4的位置已经保存了块长度，所以对BSTR不应该用 wcslen 之类的方法来得到它的长度，要用 SysStringLen。这就是为什么不推荐用 BSTR p = L”hello”这种方法直接给BSTR赋值，因为这样得到到BSTR不符合减4位置有块长度的规范，也不能用 SysStringLen 得到长度，也不能用 SysFreeString 来释放。乱了规矩。 又一个问题，为什么需要 SysAllocString ? 我用 new 或 malloc 不行吗？因为用ATL常常是为了写COM。而COM控件是跨语言的。你用C++写一个COM控件，可能被HTML中的一个VBSCRIPT或PHP调用。你返回的那个BSTR字串可能需要在VBSCRIPT中释放。而 new 或 malloc 等常规的C++分配内存函数，都要求内存在本模块内释放。所以，SysAllocString 分析的内存，是为了支持跨模块使用，并在外地free的。 那么 CComBSTR 又是什么呢？上面讲了，BSTR只是一个指针，它太简单了。如果我要实现字串查找，字串合并等复杂的操作就要自己写代码了。于是就有了 CComBSTR这个类。它只有一个成员 BSTR m_str 但它有大量的方法函数，足够你所可能需要的所有字串操作。 最后结论： * BSTR 只是一个指针，要小心使用，除了 SysAllocString 不要对它赋值。 * 如果发现一个 BSTR， 那它一定是用 SysAllocString 得到的。一定要用 SysStringLen 来得到长度。一定要用 SysFreeString 来释放它 * 如果需要对 BSTR 做字串操作，把它变成 CComBSTR ，总有一个现成的函数直接使用。 * 这一系列东西，都是为了COM跨模块把字串当作返回值使用的。如果一个字串只在本模块内有效，还是用 new 或 malloc 或 CString 来得简单。 SysAllocString,SysFreeString大致伪逻辑如下 1234567891011121314WCHAR* SysAllocString(WCHAR *str)&#123; size_t sz = 4 + wcslen(str)*sizeof(WCHAR); WCHAR *lpstart = malloc(); *(int*)lpstart = sz; wcscpy(lpstart+2,str); return lpstart + 2;&#125;void SysFreeString(WCHAR *str)&#123; str -= 2; free(str);&#125; 参考： https://blog.csdn.net/shihuaguo/article/details/8541172 https://bbs.pediy.com/thread-125705.htm https://www.cnblogs.com/qinfengxiaoyue/p/3428540.html https://blog.csdn.net/weixin_30478757/article/details/97589060","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.github.io/categories/c/"}],"tags":[]},{"title":"cpp11计时器-chrono","slug":"cpp11计时器-chrono","date":"2021-08-23T15:21:16.000Z","updated":"2021-08-23T15:55:27.187Z","comments":true,"path":"2021/08/23/cpp11计时器-chrono/","link":"","permalink":"https://marblemm.github.io/2021/08/23/cpp11%E8%AE%A1%E6%97%B6%E5%99%A8-chrono/","excerpt":"","text":"计时有很多用途，比如：测试某一段代码的运行时间，时间越短，则性能相对越高。计时有很多方法，我将首先给出我以前常用的一种计时方法，然后给出我认为的最佳方法（采用了C++11的标准技术）。 首先给出我以前常用的一种“传统”的计时方法： 12345678910111213#include &lt;ctime&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; clock_t start = clock(); // do something... clock_t end = clock(); cout &lt;&lt; &quot;花费了&quot; &lt;&lt; (double)(end - start) / CLOCKS_PER_SEC &lt;&lt; &quot;秒&quot; &lt;&lt; endl;&#125; 此方法可以精确到毫秒，输出样例：花费了0.123秒 c++11计时器C++11有了chrono库，可以在不同系统中很容易的实现定时功能。 要使用chrono库，需要#include，其所有实现均在std::chrono namespace下。注意标准库里面的每个命名空间代表了一个独立的概念。 chrono是一个模版库，使用简单，功能强大，只需要理解三个概念：duration、time_point、clock 时钟chrono库定义了三种不同的时钟: std::chrono::system_clock: 依据系统的当前时间 (不稳定) std::chrono::steady_clock: 以统一的速率运行(不能被调整) std::chrono::high_resolution_clock: 提供最高精度的计时周期(可能是steady_clock或者system_clock的typedef) system_clock就类似Windows系统右下角那个时钟，是系统时间。明显那个时钟是可以乱设置的。明明是早上10点，却可以设置成下午3点。 steady_clock则针对system_clock可以随意设置这个缺陷而提出来的，他表示时钟是不能设置的。 high_resolution_clock则是一个高分辨率时钟。 这三个时钟类都提供了一个静态成员函数now()用于获取当前时间，该函数的返回值是一个time_point类型， 时间精度其实也就是时间分辨率。抛开时间量纲单论分辨率，其实就是一个比率。如：1000110001、101101、1111 、110110、1100011000。这些比率加上距离量纲就变成距离分辨率，加上时间量纲就变成时间分辨率了。为此，C++11定义了一个新的模板类ratio，用于表示比率，定义如下： 123//#include&lt;ration&gt;template&lt;std::intmax_t Num, std::intmax_t Denom = 1&gt; //前者是分子，后者是分母class ratio; 为了方便，C++标准委员会还预定义了下面这些分辨率，供用户使用。 1234567//#include&lt;ratio&gt;typedef ratio&lt;1, 1000000000000000000&gt; atto;typedef ratio&lt;1, 1000000000000000&gt; femto;typedef ratio&lt;1, 1000000000000&gt; pico;typedef ratio&lt;1, 1000000000&gt; nano;typedef ratio&lt;1, 1000000&gt; micro;typedef ratio&lt;1, 1000&gt; milli; 1234567891011121314#include &lt;chrono&gt; #include &lt;iostream&gt;using namespace std;using namespace chrono;int main()&#123; auto start = system_clock::now(); // do something... auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; &quot;花费了&quot; &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; &quot;秒&quot; &lt;&lt; endl;&#125; 此方法可以精确到微妙，输出样例：花费了0.123456秒 microseconds 表示微妙。除此之外，还有五种时间单位：hours, minutes, seconds, milliseconds, nanosecondsnum 和 den分别表示分子(numerator)和分母(denominator)。在我给出的代码中，num等于1， den等于1,000,000 system_clock除了now()函数外，还提供了to_time_t()静态成员函数。用于将系统时间转换成熟悉的std::time_t类型， 得到了time_t类型的值，在使用ctime()函数将时间转换成字符串格式，就可以很方便地打印当前时间了。 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;ctime&gt;//将时间格式的数据转换成字符串#include&lt;chrono&gt;using namespace std::chrono;using namespace std;int main()&#123; //获取系统的当前时间 auto t = system_clock::now(); //将获取的时间转换成time_t类型 auto tNow = system_clock::to_time_t(t); //ctime()函数将time_t类型的时间转化成字符串格式,这个字符串自带换行符 string str_time = std::ctime(&amp;tNow); cout&lt;&lt;str_time; return 0;&#125; 二、持续的时间 - durationstd::chrono::duration&lt;int,ratio&lt;60,1&gt;&gt; ,表示持续的一段时间,这段时间的单位是由ratio&lt;60,1&gt;决定的,int表示这段时间的值的类型,函数返回的类型还是一个时间段duration std::chrono::duration&lt;double,ratio&lt;60,1&gt;&gt; 由于各种时间段(duration)表示不同，chrono库提供了duration_cast类型转换函数。 duration_cast用于将duration进行转换成另一个类型的duration。 duration还有一个成员函数count(),用来表示这一段时间的长度 1234567891011121314151617#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;chrono&gt;using namespace std::chrono;using namespace std;int main()&#123; auto start = steady_clock::now(); for(int i=0;i&lt;100;i++) cout&lt;&lt;&quot;nice&quot;&lt;&lt;endl; auto end = steady_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); cout&lt;&lt;&quot;程序用时=&quot;&lt;&lt;tt.count()&lt;&lt;&quot;微秒&quot;&lt;&lt;endl; return 0;&#125; 三、时间点 - time_point123//#include&lt;chrono&gt;template&lt; class Clock, class Duration = typename Clock::duration &gt; class time_point; std::chrono::time_point 表示一个具体时间，如上个世纪80年代、今天下午3点、火车出发时间等，只要它能用计算机时钟表示。第一个模板参数Clock用来指定所要使用的时钟（标准库中有三种时钟，system_clock，steady_clock和high_resolution_clock。见4时钟详解），第二个模板函数参数用来表示时间的计量单位(特化的std::chrono::duration&lt;&gt; ) 时间点都有一个时间戳，即时间原点。chrono库中采用的是Unix的时间戳1970年1月1日 00:00。所以time_point也就是距离时间戳(epoch)的时间长度（duration）。 时间点有个重要的函数：duration time_since_epoch() (用于获取当前时间点距离时间戳的时间长度)即经常用来得到当前时间点到1970年1月1日00:00的时间距离、该函数返回的duration的精度和构造time_point的时钟(Clock)有关(见4时钟详解)。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;ctime&gt;using namespace std;int main()&#123; //距离时间戳2两秒 chrono::time_point&lt;chrono::system_clock, chrono::seconds&gt; tp(chrono::seconds(2)); cout &lt;&lt; &quot;to epoch : &quot; &lt;&lt;tp.time_since_epoch().count() &lt;&lt; &quot;s&quot; &lt;&lt;endl; //转化为ctime，打印输出时间点 time_t tt = chrono::system_clock::to_time_t(tp); char a[50]; ctime_s(a, sizeof(a), &amp;tt); cout &lt;&lt; a; system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.github.io/categories/c/"}],"tags":[]},{"title":"cpp单例模式总结","slug":"cpp单例模式总结","date":"2021-08-22T08:40:01.000Z","updated":"2021-08-27T16:40:45.739Z","comments":true,"path":"2021/08/22/cpp单例模式总结/","link":"","permalink":"https://marblemm.github.io/2021/08/22/cpp%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"C++ 单例模式总结与剖析单例可能是最常用的简单的一种设计模式，实现方法多样，根据不同的需求有不同的写法; 同时单例也有其局限性，因此有很多人是反对使用单例的。本文对C++ 单例的常见写法进行了一个总结, 包括懒汉式、线程安全、单例模板等； 按照从简单到复杂，最终回归简单的的方式循序渐进地介绍，并且对各种实现方法的局限进行了简单的阐述，大量用到了C++ 11的特性如智能指针, magic static，线程锁; 从头到尾理解下来，对于学习和巩固C++语言特性还是很有帮助的。本文的全部代码在 g++ 5.4.0 编译器下编译运行通过，可以在这个github 仓库中找到。 一、什么是单例单例 Singleton 是设计模式的一种，其特点是只提供唯一一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;具体运用场景如： 设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动; 数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取; 二、C++单例的实现2.1 基础要点 全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private） 线程安全 禁止赋值和拷贝 用户通过接口获取实例：使用 static 类成员函数 2.2 C++ 实现单例的几种方式2.2.1 有缺陷的懒汉式懒汉式(Lazy-Initialization)的方法是直到使用时才实例化对象，也就说直到调用get_instance() 方法的时候才 new 一个单例的对象， 如果不被调用就不会占用内存。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;// version1:// with problems below:// 1. thread is not safe// 2. memory leakclass Singleton&#123;private: Singleton()&#123; std::cout&lt;&lt;&quot;constructor called!&quot;&lt;&lt;std::endl; &#125; Singleton(Singleton&amp;)=delete; Singleton&amp; operator=(const Singleton&amp;)=delete; static Singleton* m_instance_ptr;public: ~Singleton()&#123; std::cout&lt;&lt;&quot;destructor called!&quot;&lt;&lt;std::endl; &#125; static Singleton* get_instance()&#123; if(m_instance_ptr==nullptr)&#123; m_instance_ptr = new Singleton; &#125; return m_instance_ptr; &#125; void use() const &#123; std::cout &lt;&lt; &quot;in use&quot; &lt;&lt; std::endl; &#125;&#125;;Singleton* Singleton::m_instance_ptr = nullptr;int main()&#123; Singleton* instance = Singleton::get_instance(); Singleton* instance_2 = Singleton::get_instance(); return 0;&#125; 运行的结果是 1constructor called! 可以看到，获取了两次类的实例，却只有一次类的构造函数被调用，表明只生成了唯一实例，这是个最基础版本的单例实现，他有哪些问题呢？ 线程安全的问题,当多线程获取单例时有可能引发竞态条件：第一个线程在if中判断 m_instance_ptr是空的，于是开始实例化单例;同时第2个线程也尝试获取单例，这个时候判断m_instance_ptr还是空的，于是也开始实例化单例;这样就会实例化出两个对象,这就是线程安全问题的由来; 解决办法:加锁 内存泄漏. 注意到类中只负责new出对象，却没有负责delete对象，因此只有构造函数被调用，析构函数却没有被调用;因此会导致内存泄漏。解决办法： 使用共享指针;因此，这里提供一个改进的，线程安全的、使用智能指针的实现; 2.2.2 线程安全、内存安全的懒汉式单例 （智能指针，锁）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;memory&gt; // shared_ptr#include &lt;mutex&gt; // mutex// version 2:// with problems below fixed:// 1. thread is safe now// 2. memory doesn&#x27;t leakclass Singleton&#123;public: typedef std::shared_ptr&lt;Singleton&gt; Ptr; ~Singleton()&#123; std::cout&lt;&lt;&quot;destructor called!&quot;&lt;&lt;std::endl; &#125; Singleton(Singleton&amp;)=delete; Singleton&amp; operator=(const Singleton&amp;)=delete; static Ptr get_instance()&#123; // &quot;double checked lock&quot; if(m_instance_ptr==nullptr)&#123; std::lock_guard&lt;std::mutex&gt; lk(m_mutex); if(m_instance_ptr == nullptr)&#123; m_instance_ptr = std::shared_ptr&lt;Singleton&gt;(new Singleton); &#125; &#125; return m_instance_ptr; &#125;private: Singleton()&#123; std::cout&lt;&lt;&quot;constructor called!&quot;&lt;&lt;std::endl; &#125; static Ptr m_instance_ptr; static std::mutex m_mutex;&#125;;// initialization static variables out of classSingleton::Ptr Singleton::m_instance_ptr = nullptr;std::mutex Singleton::m_mutex;int main()&#123; Singleton::Ptr instance = Singleton::get_instance(); Singleton::Ptr instance2 = Singleton::get_instance(); return 0;&#125; 运行结果如下，发现确实只构造了一次实例，并且发生了析构。 12constructor called!destructor called! shared_ptr和mutex都是C++11的标准，以上这种方法的优点是 基于 shared_ptr, 用了C++比较倡导的 RAII思想，用对象管理资源,当 shared_ptr 析构的时候，new 出来的对象也会被 delete掉。以此避免内存泄漏。 加了锁，使用互斥量来达到线程安全。这里使用了两个 if判断语句的技术称为双检锁；好处是，只有判断指针为空的时候才加锁，避免每次调用 get_instance的方法都加锁，锁的开销毕竟还是有点大的。 不足之处在于： 使用智能指针会要求用户也得使用智能指针，非必要不应该提出这种约束; 使用锁也有开销; 同时代码量也增多了，实现上我们希望越简单越好。 还有更加严重的问题，在某些平台（与编译器和指令集架构有关），双检锁会失效！具体可以看这篇文章，解释了为什么会发生这样的事情。 因此这里还有第三种的基于 Magic Staic的方法达到线程安全 2.2.3 最推荐的懒汉式单例(magic static )——局部静态变量123456789101112131415161718192021222324252627#include &lt;iostream&gt;class Singleton&#123;public: ~Singleton()&#123; std::cout&lt;&lt;&quot;destructor called!&quot;&lt;&lt;std::endl; &#125; Singleton(const Singleton&amp;)=delete; Singleton&amp; operator=(const Singleton&amp;)=delete; static Singleton&amp; get_instance()&#123; static Singleton instance; return instance; &#125;private: Singleton()&#123; std::cout&lt;&lt;&quot;constructor called!&quot;&lt;&lt;std::endl; &#125;&#125;;int main(int argc, char *argv[])&#123; Singleton&amp; instance_1 = Singleton::get_instance(); Singleton&amp; instance_2 = Singleton::get_instance(); return 0;&#125; 运行结果 12constructor called!destructor called! 这种方法又叫做 Meyers’ SingletonMeyer’s的单例， 是著名的写出《Effective C++》系列书籍的作者 Meyers 提出的。所用到的特性是在C++11标准中的Magic Static特性： 12If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。 这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。 C++静态变量的生存期 是从声明到程序结束，这也是一种懒汉式。 这是最推荐的一种单例实现方式： 通过局部静态变量的特性保证了线程安全 (C++11, GCC &gt; 4.3, VS2015支持该特性); 不需要使用共享指针，代码简洁； 注意在使用的时候需要声明单例的引用 Single&amp; 才能获取对象。另外网上有人的实现返回指针而不是返回引用1234static Singleton* get_instance()&#123; static Singleton instance; return &amp;instance;&#125; 这样做并不好，理由主要是无法避免用户使用delete instance导致对象被提前销毁。还是建议大家使用返回引用的方式。 2.2.4 函数返回引用有人在网上提供了这样一种单例的实现方式； 12345678910111213141516171819202122232425#include &lt;iostream&gt;class A&#123;public: A() &#123; std::cout&lt;&lt;&quot;constructor&quot; &lt;&lt;std::endl; &#125; ~A()&#123; std::cout&lt;&lt;&quot;destructor&quot;&lt;&lt;std::endl; &#125;&#125;;A&amp; ret_singleton()&#123; static A instance; return instance;&#125;int main(int argc, char *argv[])&#123; A&amp; instance_1 = ret_singleton(); A&amp; instance_2 = ret_singleton(); return 0;&#125; 严格来说，这不属于单例了，因为类A只是个寻常的类，可以被定义出多个实例，但是亮点在于提供了ret_singleton的方法，可以返回一个全局（静态）变量，起到类似单例的效果，这要求用户必须保证想要获取 全局变量A ，只通过ret_singleton()的方法。 以上是各种方法实现单例的代码和说明，解释了各种技术实现的初衷和原因。这里会比较推荐 C++11 标准下的 2.2.3 的方式，即使用static local的方法，简单的理由来说是因为其足够简单却满足所有需求和顾虑。 在某些情况下，我们系统中可能有多个单例，如果都按照这种方式的话，实际上是一种重复，有没有什么方法可以只实现一次单例而能够复用其代码从而实现多个单例呢？ 很自然的我们会考虑使用模板技术或者继承的方法，在我的博客中有介绍过如何使用单例的模板。 2.3 单例的模板2.3.1 CRTP 奇异递归模板模式实现代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// brief: a singleton base class offering an easy way to create singleton#include &lt;iostream&gt;template&lt;typename T&gt;class Singleton&#123;public: static T&amp; get_instance()&#123; static T instance; return instance; &#125; virtual ~Singleton()&#123; std::cout&lt;&lt;&quot;destructor called!&quot;&lt;&lt;std::endl; &#125; Singleton(const Singleton&amp;)=delete; Singleton&amp; operator =(const Singleton&amp;)=delete;protected: Singleton()&#123; std::cout&lt;&lt;&quot;constructor called!&quot;&lt;&lt;std::endl; &#125;&#125;;/********************************************/// Example:// 1.friend class declaration is requiered!// 2.constructor should be privateclass DerivedSingle:public Singleton&lt;DerivedSingle&gt;&#123; // !!!! attention!!! // needs to be friend in order to // access the private constructor/destructor friend class Singleton&lt;DerivedSingle&gt;;public: DerivedSingle(const DerivedSingle&amp;)=delete; DerivedSingle&amp; operator =(const DerivedSingle&amp;)= delete;private: DerivedSingle()=default;&#125;;int main(int argc, char* argv[])&#123; DerivedSingle&amp; instance1 = DerivedSingle::get_instance(); DerivedSingle&amp; instance2 = DerivedSingle::get_instance(); return 0;&#125; 以上实现一个单例的模板基类，使用方法如例子所示意，子类需要将自己作为模板参数T 传递给 Singleton 模板; 同时需要将基类声明为友元，这样才能调用子类的私有构造函数。 基类模板的实现要点是： 构造函数需要是 protected，这样子类才能继承； 使用了奇异递归模板模式CRTP(Curiously recurring template pattern) get instance 方法和 2.2.3 的static local方法一个原理。 在这里基类的析构函数可以不需要 virtual ，因为子类在应用中只会用 Derived 类型，保证了析构时和构造时的类型一致2.3.2 不需要在子类声明友元的实现方法在 stackoverflow上， 有大神给出了不需要在子类中声明友元的方法，在这里一并放出;精髓在于使用一个代理类 token，子类构造函数需要传递token类才能构造，但是把 token保护其起来， 然后子类的构造函数就可以是公有的了，这个子类只有 Derived(token)的这样的构造函数，这样用户就无法自己定义一个类的实例了，起到控制其唯一性的作用。代码如下。123456789101112131415161718192021222324252627282930313233343536373839404142// brief: a singleton base class offering an easy way to create singleton#include &lt;iostream&gt;template&lt;typename T&gt;class Singleton&#123;public: static T&amp; get_instance() noexcept(std::is_nothrow_constructible&lt;T&gt;::value)&#123; static T instance&#123;token()&#125;; return instance; &#125; virtual ~Singleton() =default; Singleton(const Singleton&amp;)=delete; Singleton&amp; operator =(const Singleton&amp;)=delete;protected: struct token&#123;&#125;; // helper class Singleton() noexcept=default;&#125;;/********************************************/// Example:// constructor should be public because protected `token` control the accessclass DerivedSingle:public Singleton&lt;DerivedSingle&gt;&#123;public: DerivedSingle(token)&#123; std::cout&lt;&lt;&quot;destructor called!&quot;&lt;&lt;std::endl; &#125; ~DerivedSingle()&#123; std::cout&lt;&lt;&quot;constructor called!&quot;&lt;&lt;std::endl; &#125; DerivedSingle(const DerivedSingle&amp;)=delete; DerivedSingle&amp; operator =(const DerivedSingle&amp;)= delete;&#125;;int main(int argc, char* argv[])&#123; DerivedSingle&amp; instance1 = DerivedSingle::get_instance(); DerivedSingle&amp; instance2 = DerivedSingle::get_instance(); return 0;&#125; 2.3.3 函数模板返回引用在 2.2.4 中提供了一种类型的全局变量的方法，可以把一个一般的类，通过这种方式提供一个类似单例的全局性效果（但是不能阻止用户自己声明定义这样的类的对象）;在这里我们把这个方法变成一个 template 模板函数，然后就可以得到任何一个类的全局变量。12345678910111213141516171819202122232425#include &lt;iostream&gt;class A&#123;public: A() &#123; std::cout&lt;&lt;&quot;constructor&quot; &lt;&lt;std::endl; &#125; ~A()&#123; std::cout&lt;&lt;&quot;destructor&quot;&lt;&lt;std::endl; &#125;&#125;;template&lt;typename T&gt;T&amp; get_global()&#123; static T instance; return instance;&#125;int main(int argc, char *argv[])&#123; A&amp; instance_1 = get_global&lt;A&gt;(); A&amp; instance_2 = get_global&lt;A&gt;(); return 0;&#125; 可以看到这种方式确实非常简洁，同时类仍然具有一般类的特点而不受限制，当然也因此失去了单例那么强的约束（禁止赋值、构造和拷贝构造）。这里把函数命名为 get_global() 是为了强调，这里可以通过这种方式获取得到单例最重要的全局变量特性；但是并不是单例的模式。 三、何时应该使用或者不使用单例根据stackoverflow上的一个高票答案 singleton-how-should-it-be-used： 12You need to have one and only one object of a type in system你需要系统中只有唯一一个实例存在的类的全局变量的时候才使用单例。 如果使用单例，应该用什么样子的1234567891011How to create the best singleton:The smaller, the better. I am a minimalistMake sure it is thread safeMake sure it is never nullMake sure it is created only onceLazy or system initialization? Up to your requirementsSometimes the OS or the JVM creates singletons for you (e.g. in Java every class definition is a singleton)Provide a destructor or somehow figure out how to dispose resourcesUse little memory越小越好，越简单越好，线程安全，内存不泄露 反对单例的理由当然程序员是分流派的，有些是反对单例的，有些人是反对设计模式的，有些人甚至连面向对象都反对 😃. 反对单例的理由有哪些： 参考文章在本文写作的过程中参考了一些博客和stackoverflow 的回答，以超链接的方式体现在文中。另外还有一些我觉得非常精彩的回答，放在下面供读者拓展阅读 推荐阅读： 高票回答中提供了一系列有益的链接(https://stackoverflow.com/questions/1008019/c-singleton-design-pattern/1008289#1008289) 面试中的单例(http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html) 一些观点(https://segmentfault.com/q/1010000000593968) https://www.cnblogs.com/sunchaothu/p/10389842.html","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.github.io/categories/c/"}],"tags":[]},{"title":"cpp中std::ref","slug":"cpp中std-ref","date":"2021-08-22T07:07:29.000Z","updated":"2021-08-22T07:09:20.535Z","comments":true,"path":"2021/08/22/cpp中std-ref/","link":"","permalink":"https://marblemm.github.io/2021/08/22/cpp%E4%B8%ADstd-ref/","excerpt":"","text":"C++本身有引用（&amp;），为什么C++11又引入了std::ref（或者std::cref）？使用std::ref可以在模板传参的时候传入引用，否则只能传值。主要是考虑函数式编程（如std::bind）在使用时，是对参数直接拷贝，而不是引用。如下例子： 12345678910111213141516171819202122#include &lt;functional&gt;#include &lt;iostream&gt; void f(int&amp; n1, int&amp; n2, const int&amp; n3)&#123; std::cout &lt;&lt; &quot;In function: &quot; &lt;&lt; n1 &lt;&lt; &#x27; &#x27; &lt;&lt; n2 &lt;&lt; &#x27; &#x27; &lt;&lt; n3 &lt;&lt; &#x27;\\n&#x27;; ++n1; // increments the copy of n1 stored in the function object ++n2; // increments the main()&#x27;s n2 // ++n3; // compile error&#125; int main()&#123; int n1 = 1, n2 = 2, n3 = 3; std::function&lt;void()&gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout &lt;&lt; &quot;Before function: &quot; &lt;&lt; n1 &lt;&lt; &#x27; &#x27; &lt;&lt; n2 &lt;&lt; &#x27; &#x27; &lt;&lt; n3 &lt;&lt; &#x27;\\n&#x27;; bound_f(); std::cout &lt;&lt; &quot;After function: &quot; &lt;&lt; n1 &lt;&lt; &#x27; &#x27; &lt;&lt; n2 &lt;&lt; &#x27; &#x27; &lt;&lt; n3 &lt;&lt; &#x27;\\n&#x27;;&#125; 输出： 1234Output:Before function: 10 11 12In function: 1 11 12After function: 10 12 12 上述代码在执行std::bind后，在函数f()中n1的值仍然是1，n2和n3改成了修改的值。说明std::bind使用的是参数的拷贝而不是引用。具体为什么std::bind不使用引用，可能确实有一些需求，使得C++11的设计者认为默认应该采用拷贝，如果使用者有需求，加上std::ref即可。 &amp;是类型说明符， std::ref 是一个函数，返回 std::reference_wrapper类型。另外std::cref() 用于const引用的版本。 参考： https://www.cnblogs.com/chen-cs/p/13059896.html","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.github.io/categories/c/"}],"tags":[]},{"title":"cpp中的RAII机制","slug":"cpp中的RAII机制","date":"2021-08-20T15:52:47.000Z","updated":"2021-08-22T16:36:28.839Z","comments":true,"path":"2021/08/20/cpp中的RAII机制/","link":"","permalink":"https://marblemm.github.io/2021/08/20/cpp%E4%B8%AD%E7%9A%84RAII%E6%9C%BA%E5%88%B6/","excerpt":"","text":"什么是RAII？RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。 为什么要使用RAII？上面说到RAII是用来管理资源、避免资源泄漏的方法。那么，用了这么久了，也写了这么多程序了，口头上经常会说资源，那么资源是如何定义的？在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，所以，我们在编程使用系统资源时，都必须遵循一个步骤：1 申请资源；2 使用资源；3 释放资源。第一步和第二步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。 一个最简单的例子：12345678910111213#include &lt;iostream&gt; using namespace std; int main() &#123; int *testArray = new int [10]; // Here, you can use the array delete [] testArray; testArray = NULL ; return 0; &#125; 小结：但是如果程序很复杂的时候，需要为所有的new 分配的内存delete掉，导致极度臃肿，效率下降，更可怕的是，程序的可理解性和可维护性明显降低了，当操作增多时，处理资源释放的代码就会越来越多，越来越乱。如果某一个操作发生了异常而导致释放资源的语句没有被调用，怎么办？这个时候，RAII机制就可以派上用场了。 如何使用RAII？当我们在一个函数内部使用局部变量，当退出了这个局部变量的作用域时，这个变量也就别销毁了；当这个变量是类对象时，这个时候，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显示的去调用完成。这个也太好了，RAII就是这样去完成的。 由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。 使用RAII 机制的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt; using namespace std; class ArrayOperation &#123; public : ArrayOperation() &#123; m_Array = new int [10]; &#125; void InitArray() &#123; for (int i = 0; i &lt; 10; ++i) &#123; *(m_Array + i) = i; &#125; &#125; void ShowArray() &#123; for (int i = 0; i &lt;10; ++i) &#123; cout&lt;&lt;m_Array[i]&lt;&lt;endl; &#125; &#125; ~ArrayOperation() &#123; cout&lt;&lt; &quot;~ArrayOperation is called&quot; &lt;&lt;endl; if (m_Array != NULL ) &#123; delete[] m_Array; // 非常感谢益可达非常犀利的review，详细可以参加益可达在本文的评论 2014.04.13 m_Array = NULL ; &#125; &#125; private : int *m_Array; &#125;; bool OperationA(); bool OperationB(); int main() &#123; ArrayOperation arrayOp; arrayOp.InitArray(); arrayOp.ShowArray(); return 0;&#125; 不使用RAII（没有使用类的思想）的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt; using namespace std; bool OperationA(); bool OperationB(); int main() &#123; int *testArray = new int [10]; // Here, you can use the array if (!OperationA()) &#123; // If the operation A failed, we should delete the memory delete [] testArray; testArray = NULL ; return 0; &#125; if (!OperationB()) &#123; // If the operation A failed, we should delete the memory delete [] testArray; testArray = NULL ; return 0; &#125; // All the operation succeed, delete the memory delete [] testArray; testArray = NULL ; return 0; &#125; bool OperationA() &#123; // Do some operation, if the operate succeed, then return true, else return false return false ; &#125; bool OperationB() &#123; // Do some operation, if the operate succeed, then return true, else return false return true ; &#125; 上面这个例子没有多大的实际意义，只是为了说明RAII的机制问题。下面说一个具有实际意义的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;using namespace std;CRITICAL_SECTION cs;int gGlobal = 0;class MyLock&#123;public: MyLock() &#123; EnterCriticalSection(&amp;cs); &#125; ~MyLock() &#123; LeaveCriticalSection(&amp;cs); &#125;private: MyLock( const MyLock &amp;); MyLock operator =(const MyLock &amp;);&#125;;void DoComplex(MyLock &amp;lock ) // 非常感谢益可达犀利的review 2014.04.13&#123;&#125;unsigned int __stdcall ThreadFun(PVOID pv) &#123; MyLock lock; int *para = (int *) pv; // I need the lock to do some complex thing DoComplex(lock); for (int i = 0; i &lt; 10; ++i) &#123; ++gGlobal; cout&lt;&lt; &quot;Thread &quot; &lt;&lt;*para&lt;&lt;endl; cout&lt;&lt;gGlobal&lt;&lt;endl; &#125; return 0;&#125;int main()&#123; InitializeCriticalSection(&amp;cs); int thread1, thread2; thread1 = 1; thread2 = 2; HANDLE handle[2]; handle[0] = ( HANDLE )_beginthreadex(NULL , 0, ThreadFun, ( void *)&amp;thread1, 0, NULL ); handle[1] = ( HANDLE )_beginthreadex(NULL , 0, ThreadFun, ( void *)&amp;thread2, 0, NULL ); WaitForMultipleObjects(2, handle, TRUE , INFINITE ); return 0;&#125; 这个例子可以说是实际项目的一个模型，当多个进程访问临界变量时，为了不出现错误的情况，需要对临界变量进行加锁；上面的例子就是使用的Windows的临界区域实现的加锁。 但是，在使用CRITICAL_SECTION时，EnterCriticalSection和LeaveCriticalSection必须成对使用，很多时候，经常会忘了调用LeaveCriticalSection，此时就会发生死锁的现象。当我将对CRITICAL_SECTION的访问封装到MyLock类中时，之后，我只需要定义一个MyLock变量，而不必手动的去显示调用LeaveCriticalSection函数。 上述的两个例子都是RAII机制的应用，理解了上面的例子，就应该能理解了RAII机制的使用了。 参考： https://www.jianshu.com/p/b7ffe79498be","categories":[],"tags":[]},{"title":"cpp11多线程5-atomic","slug":"cpp11多线程5-atomic","date":"2021-08-19T14:08:01.000Z","updated":"2021-08-30T15:46:34.630Z","comments":true,"path":"2021/08/19/cpp11多线程5-atomic/","link":"","permalink":"https://marblemm.github.io/2021/08/19/cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B5-atomic/","excerpt":"","text":"对简单临界资源的访问，如果使用mutex开销较大。 如有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条语句可能会被拆成3、4条汇编语句来执行，所以仍然有可能混乱） 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono;int g_count = 0;void mythread()&#123; for (int i = 0; i &lt; 1000000; i++) &#123; g_count++; &#125;&#125;int main()&#123; std::thread t1(mythread); std::thread t2(mythread); auto start = steady_clock::now(); t1.join(); t2.join(); auto end = steady_clock::now(); auto tt = duration_cast&lt;milliseconds&gt;(end - start); cout &lt;&lt; &quot;程序用时=&quot; &lt;&lt; tt.count() &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl; cout &lt;&lt; &quot;正常情况下结果应该是200 0000次，实际是&quot; &lt;&lt; g_count &lt;&lt; endl; return 0;&#125;/*结果：程序用时=16毫秒正常情况下结果应该是200 0000次，实际是1303733*/ 使用std::mutex来解决上述对临界资源访问的问题。结果正常，但是每一次循环都要加锁解锁是的程序开销很大。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;mutex&gt;using namespace std;using namespace std::chrono;int g_count = 0;std::mutex mymutex;void mythread()&#123; for (int i = 0; i &lt; 1000000; i++) &#123; std::unique_lock&lt;std::mutex&gt; u1(mymutex); g_count++; &#125;&#125;int main()&#123; std::thread t1(mythread); std::thread t2(mythread); auto start = steady_clock::now(); t1.join(); t2.join(); auto end = steady_clock::now(); auto tt = duration_cast&lt;milliseconds&gt;(end - start); cout &lt;&lt; &quot;程序用时=&quot; &lt;&lt; tt.count() &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl; cout &lt;&lt; &quot;正常情况下结果应该是200 0000次，实际是&quot; &lt;&lt; g_count &lt;&lt; endl; return 0;&#125;/*结果：程序用时=349毫秒正常情况下结果应该是200 0000次，实际是2000000*/ std::atomic std::atomic包含在头文件中。可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。原子操作：在多线程中不会被打断的程序执行片段。从效率上来说，原子操作要比互斥量的方式效率要高。互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。std::atomic来代表原子操作，是个类模板。其实std::atomic是用来封装某个类型的值。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono;std::atomic&lt;int&gt; g_count = 0; //封装了一个类型为int的 对象（值）void mythread()&#123; for (int i = 0; i &lt; 1000000; i++) &#123; g_count++; &#125;&#125;int main()&#123; std::thread t1(mythread); std::thread t2(mythread); auto start = steady_clock::now(); t1.join(); t2.join(); auto end = steady_clock::now(); auto tt = duration_cast&lt;milliseconds&gt;(end - start); cout &lt;&lt; &quot;程序用时=&quot; &lt;&lt; tt.count() &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl; cout &lt;&lt; &quot;正常情况下结果应该是200 0000次，实际是&quot; &lt;&lt; g_count &lt;&lt; endl; return 0;&#125;/*程序用时=51毫秒正常情况下结果应该是200 0000次，实际是2000000*/ 一般atomic原子操作，针对++，–，+=，-=，&amp;=，|=，^=是支持的，其他操作不一定支持。如下使用g_count = g_count + 1就会产生错误。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;using namespace std;std::atomic&lt;int&gt; g_count = 0; //封装了一个类型为int的 对象（值）void mythread1() &#123; for (int i = 0; i &lt; 1000000; i++) &#123; //虽然g_count使用了原子操作模板，但是这种写法既读又写， //会导致计数错误 g_count = g_count + 1; &#125;&#125;int main() &#123; std::thread t1(mythread1); std::thread t2(mythread1); t1.join(); t2.join(); cout &lt;&lt; &quot;正常情况下结果应该是200 0000次，实际是&quot; &lt;&lt; g_count &lt;&lt; endl;&#125; 其他需要注意的地方12std::atomic&lt;int&gt; atm = 0; cout &lt;&lt; atm &lt;&lt; endl; 这里只有读取atm是原子操作，但是整个这一行代码 cout &lt;&lt; atm &lt;&lt; endl; 并不是原子操作，导致最终显示在屏幕上的值是一个“曾经值”。 12std::atomic&lt;int&gt; atm = 0;auto atm2 = atm; //不可以 这种拷贝初始化不可以，会报错。 1atomic&lt;int&gt; atm2(atm.load()); load()：以原子方式读atomic对象的值。 1atm2.store(12); store()：以原子方式写。 参考： https://www.cnblogs.com/chen-cs/p/13254219.html","categories":[{"name":"多线程","slug":"多线程","permalink":"https://marblemm.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"cpp11多线程4-condition","slug":"cpp11多线程4-condition","date":"2021-08-18T13:44:18.000Z","updated":"2021-08-27T16:44:57.259Z","comments":true,"path":"2021/08/18/cpp11多线程4-condition/","link":"","permalink":"https://marblemm.github.io/2021/08/18/cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B4-condition/","excerpt":"","text":"std::condition_variable条件变量是C++11提供的另外一种线程同步机制，通过判断条件是否满足，决定是否阻塞线程，当线程执行条件满足的时候就会唤醒阻塞的线程，常与std::mutex配合使用，C++11提供了两种条件变量。 123std::condition_variable，配合std::unique_lock&lt;std::mutex&gt;使用，通过wait()函数阻塞线程；std::condition_variable_any，可以和任意带有lock()、unlock()语义的std::mutex搭配使用，比较灵活，但是其效率不及std::condition_variable；std::unique_lock：C++11提供的 std::unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。std::unique_lock比std::lock_guard使用更加灵活，功能更加强大。使用std::unique_lock需要付出更多的时间、性能成本。 互斥锁std::mutex是一种最常见的线程间同步的手段，但是在有些情况下不太高效。 假设想实现一个简单的消费者生产者模型，一个线程往队列中放入数据，一个线程往队列中取数据，取数据前需要判断一下队列中确实有数据，由于这个队列是线程间共享的，所以，需要使用互斥锁进行保护，一个线程在往队列添加数据的时候，另一个线程不能取，反之亦然。用互斥锁实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::deque&lt;int&gt; q;std::mutex mu;void function_1() &#123; int count = 10; while (count &gt; 0) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); q.push_front(count); locker.unlock(); std::this_thread::sleep_for(std::chrono::seconds(1)); count--; &#125;&#125;void function_2() &#123; int data = 0; while ( data != 1) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); if (!q.empty()) &#123; data = q.back(); q.pop_back(); locker.unlock(); std::cout &lt;&lt; &quot;t2 got a value from t1: &quot; &lt;&lt; data &lt;&lt; std::endl; &#125; else &#123; locker.unlock(); &#125; &#125;&#125;int main() &#123; std::thread t1(function_1); std::thread t2(function_2); t1.join(); t2.join(); return 0;&#125;//输出结果//t2 got a value from t1: 10//t2 got a value from t1: 9//t2 got a value from t1: 8//t2 got a value from t1: 7//t2 got a value from t1: 6//t2 got a value from t1: 5//t2 got a value from t1: 4//t2 got a value from t1: 3//t2 got a value from t1: 2//t2 got a value from t1: 1 ​可以看到，互斥锁其实可以完成这个任务，但是却存在着性能问题。 首先，function_1函数是生产者，在生产过程中，std::this_thread::sleep_for(std::chrono::seconds(1));表示延时1s，所以这个生产的过程是很慢的；function_2函数是消费者，存在着一个while循环，只有在接收到表示结束的数据的时候，才会停止，每次循环内部，都是先加锁，判断队列不空，然后就取出一个数，最后解锁。所以说，在1s内，做了很多无用功！这样的话，CPU占用率会很高，可能达到100%（单核）。如图： 解决办法之一是给消费者也加一个小延时，如果一次判断后，发现队列是空的，就惩罚一下自己，延时500ms，这样可以减小CPU的占用率。 123456789101112131415void function_2() &#123; int data = 0; while ( data != 1) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); if (!q.empty()) &#123; data = q.back(); q.pop_back(); locker.unlock(); std::cout &lt;&lt; &quot;t2 got a value from t1: &quot; &lt;&lt; data &lt;&lt; std::endl; &#125; else &#123; locker.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(500)); &#125; &#125;&#125; 如图： 然后困难之处在于，如何确定这个延时时间呢，假如生产者生产的很快，消费者却延时500ms，也不是很好，如果生产者生产的更慢，那么消费者延时500ms，还是不必要的占用了CPU。 这就引出了条件变量（condition variable）,c++11中提供了#include 头文件，其中的std::condition_variable可以和std::mutex结合一起使用，其中有两个重要的接口，notify_one()和wait()，wait()可以让线程陷入休眠状态，在消费者生产者模型中，如果生产者发现队列中没有东西，就可以让自己休眠，但是不能一直不干活啊，notify_one()就是唤醒处于wait中的其中一个条件变量（可能当时有很多条件变量都处于wait状态）。那什么时刻使用notify_one()比较好呢，当然是在生产者往队列中放数据的时候了，队列中有数据，就可以赶紧叫醒等待中的线程起来干活了。 使用条件变量修改后如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;std::deque&lt;int&gt; q;std::mutex mu;std::condition_variable cond;void function_1() &#123; int count = 10; while (count &gt; 0) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); q.push_front(count); locker.unlock(); cond.notify_one(); // Notify one waiting thread, if there is one. std::this_thread::sleep_for(std::chrono::seconds(1)); count--; &#125;&#125;void function_2() &#123; int data = 0; while ( data != 1) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); while(q.empty()) cond.wait(locker); // Unlock mu and wait to be notified data = q.back(); q.pop_back(); locker.unlock(); std::cout &lt;&lt; &quot;t2 got a value from t1: &quot; &lt;&lt; data &lt;&lt; std::endl; &#125;&#125;int main() &#123; std::thread t1(function_1); std::thread t2(function_2); t1.join(); t2.join(); return 0;&#125; 此时CPU的占用率也很低。 上面的代码有三个注意事项： 在function_2中，在判断队列是否为空的时候，使用的是while(q.empty())，而不是if(q.empty())，这是因为wait()从阻塞到返回，不一定就是由于notify_one()函数造成的，还有可能由于系统的不确定原因唤醒（可能和条件变量的实现机制有关），这个的时机和频率都是不确定的，被称作伪唤醒，如果在错误的时候被唤醒了，执行后面的语句就会错误，所以需要再次判断队列是否为空，如果还是为空，就继续wait()阻塞。 在管理互斥锁的时候，使用的是std::unique_lock而不是std::lock_guard，而且事实上也不能使用std::lock_guard，这需要先解释下wait()函数所做的事情。可以看到，在wait()函数之前，使用互斥锁保护了，如果wait的时候什么都没做，岂不是一直持有互斥锁？那生产者也会一直卡住，不能够将数据放入队列中了。所以，wait()函数会先调用互斥锁的unlock()函数，然后再将自己睡眠，在被唤醒后，又会继续持有锁，保护后面的队列操作。而lock_guard没有lock和unlock接口，而unique_lock提供了。这就是必须使用unique_lock的原因。 使用细粒度锁，尽量减小锁的范围，在notify_one()的时候，不需要处于互斥锁的保护范围内，所以在唤醒条件变量之前可以将锁unlock()。 还可以将cond.wait(locker);换一种写法，wait()的第二个参数可以传入一个函数表示检查条件，这里使用lambda函数最为简单，如果这个函数返回的是true，wait()函数不会阻塞会直接返回，如果这个函数返回的是false，wait()函数就会阻塞着等待唤醒，如果被伪唤醒，会继续判断函数返回值。 1234567891011void function_2() &#123; int data = 0; while ( data != 1) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); cond.wait(locker, []()&#123; return !q.empty();&#125; ); // Unlock mu and wait to be notified data = q.back(); q.pop_back(); locker.unlock(); std::cout &lt;&lt; &quot;t2 got a value from t1: &quot; &lt;&lt; data &lt;&lt; std::endl; &#125;&#125; 除了notify_one()函数，c++还提供了notify_all()函数，可以同时唤醒所有处于wait状态的条件变量。 参考： https://www.jianshu.com/p/c1dfa1d40f53","categories":[{"name":"多线程","slug":"多线程","permalink":"https://marblemm.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"cpp11多线程3-mutex","slug":"cpp11多线程3-mutex","date":"2021-08-17T13:22:05.000Z","updated":"2021-08-27T16:44:52.294Z","comments":true,"path":"2021/08/17/cpp11多线程3-mutex/","link":"","permalink":"https://marblemm.github.io/2021/08/17/cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B3-mutex/","excerpt":"","text":"std::mutex进入多线程编程的世界，除了要牢牢掌握std::thread使用方法，还要掌握互斥量（锁）的使用，这是一种线程同步机制，在C++11中提供了4中互斥量。 1234std::mutex; //非递归的互斥量std::timed_mutex; //带超时的非递归互斥量std::recursive_mutex; //递归互斥量std::recursive_timed_mutex; //带超时的递归互斥量 从各种互斥量的名字可以看出其具有的特性，在实际开发中，常用就是std::mutex，它就像是一把锁，我们需要做的就是对它进行加锁与解锁。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;​std::mutex g_mutex;void func()&#123; std::cout &lt;&lt; &quot;entry func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::microseconds(1000)); std::cout &lt;&lt; &quot;leave func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;&#125;int main()&#123; std::thread t1(func); std::thread t2(func); std::thread t3(func); std::thread t4(func); std::thread t5(func); t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); return 0;&#125; 创建了5个线程，然后分别调用func()函数，得到结果： 12345678910entry func test thread ID is : entry func test thread ID is : 19180entry func test thread ID is : 359613632entry func test thread ID is : 9520entry func test thread ID is : 4460leave func test thread ID is : 13632leave func test thread ID is : 19180leave func test thread ID is : leave func test thread ID is : 95203596leave func test thread ID is : 4460 可以看出，并没有按顺序去执行线程函数，后面创建的线程并没有等待前面的线程执行完毕，导致结果混乱，下面用std::mutex进行控制： 保护共享数据的最基本的方式，是使用C++标准库提供的互斥量（头文件）。当访问共享数据前，使用互斥量将相关数据锁住，再当访问结束后，再将数据解锁。线程库需要保证，当一个线程使用特定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能进行访问。这就保证了所有线程能看到共享数据，而不破坏不变量。 C++中通过实例化 std::mutex 创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;​std::mutex g_mutex;using namespace std;void func()&#123; g_mutex.lock(); std::cout &lt;&lt; &quot;entry func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::microseconds(1000)); std::cout &lt;&lt; &quot;leave func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; g_mutex.unlock();&#125;int main()&#123; std::thread t1(func); std::thread t2(func); std::thread t3(func); std::thread t4(func); std::thread t5(func); t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); return 0;&#125; 只要线程进入func()函数就进行加锁处理，当线程执行完毕后进行解锁，保证每个线程都能按顺序执行，输出结果： 12345678910entry func test thread ID is : 8852leave func test thread ID is : 8852entry func test thread ID is : 15464leave func test thread ID is : 15464entry func test thread ID is : 17600leave func test thread ID is : 17600entry func test thread ID is : 16084leave func test thread ID is : 16084entry func test thread ID is : 4156leave func test thread ID is : 4156 虽然通过lock()与unlock()可以解决线程之间的资源竞争问题，但是这里也存在不足。 123456789101112func()&#123; //加锁 执行逻辑处理; //如果该过程抛出异常导致程序退出了，就没法unlock //解锁 &#125;​int main()&#123; ......&#125; func()中再执行逻辑处理中程序因为某些原因退出了，此时就无法unlock()了，这样其他线程也就无法获取std::mutex，造成死锁现象，其实在加锁之前可以通过trylock()尝试一下能不能加锁。实际开发中，通常也不会这样写代码，而是采用lock_guard来控制std::mutex。 1234567891011121314151617181920212223242526template &lt;class _Mutex&gt;class lock_guard &#123; public: using mutex_type = _Mutex;​ explicit lock_guard(_Mutex&amp; _Mtx) : _MyMutex(_Mtx) &#123; _MyMutex.lock(); //构造函数加锁 &#125;​ lock_guard(_Mutex&amp; _Mtx, adopt_lock_t) : _MyMutex(_Mtx) &#123; &#125;​ ~lock_guard() noexcept &#123; _MyMutex.unlock(); //析构函数解锁 &#125;​ lock_guard(const lock_guard&amp;) = delete; lock_guard&amp; operator=(const lock_guard&amp;) = delete;​private: _Mutex&amp; _MyMutex;&#125;;​ lock_guard是类模板，在其构造函数中自动给std::mutex加锁，在退出作用域的时候自动解锁，这样就可以保证std::mutex的正确操作，这也是RAII（获取资源便初始化）技术的体现。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;​std::mutex g_mutex;void func()&#123; std::lock_guard&lt;std::mutex&gt; lock(g_mutex); //加锁 std::cout &lt;&lt; &quot;entry func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::microseconds(1000)); std::cout &lt;&lt; &quot;leave func test thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; //退出作用域后，lock_guard对象析构就自动解锁&#125;int main()&#123; std::thread t1(func); std::thread t2(func); std::thread t3(func); std::thread t4(func); std::thread t5(func); t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); return 0;&#125;运行结果：entry func test thread ID is : 19164leave func test thread ID is : 19164entry func test thread ID is : 15124leave func test thread ID is : 15124entry func test thread ID is : 2816leave func test thread ID is : 2816entry func test thread ID is : 17584leave func test thread ID is : 17584entry func test thread ID is : 15792leave func test thread ID is : 15792 但互斥量自身也有问题。 当其中一个成员函数返回的是保护数据的指针或引用时，会破坏对数据的保护。具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。所以切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去。 另外还会造成死锁，或是对数据保护的太多(或太少)的问题。 参考： https://www.cnblogs.com/chen-cs/p/13060353.html","categories":[{"name":"多线程","slug":"多线程","permalink":"https://marblemm.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"cpp11多线程2-join注意","slug":"cpp11多线程2-join注意","date":"2021-08-16T12:24:06.000Z","updated":"2021-08-27T16:42:34.270Z","comments":true,"path":"2021/08/16/cpp11多线程2-join注意/","link":"","permalink":"https://marblemm.github.io/2021/08/16/cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B2-join%E6%B3%A8%E6%84%8F/","excerpt":"","text":"join()函数的作用是让主线程的等待该子线程完成，然后主线程再继续执行。这种情况下，子线程可以安全的访问主线程中的资源。子线程结束后由主线程负责回收子线程资源。一个子线程只能调用join()和detach()中的一个，且只允许调用一次。可以调用joinable()来判断是否可以成功调用join()或detach()。 123456789101112131415161718192021222324252627282930#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;void test()&#123; cout &lt;&lt; &quot;子线程开始执行！&quot; &lt;&lt; endl; //do something cout &lt;&lt; &quot;子线程执行完毕！&quot; &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; &quot;主线程开始执行！&quot; &lt;&lt; endl; thread t(test); cout &lt;&lt; &quot;join()是否可调：&quot; &lt;&lt; boolalpha &lt;&lt; t.joinable() &lt;&lt; endl; t.join(); //主线程等待子线程 cout &lt;&lt; &quot;join()是否可调：&quot; &lt;&lt; boolalpha &lt;&lt; t.joinable() &lt;&lt; endl; cout &lt;&lt; &quot;主线程执行完毕！&quot; &lt;&lt; endl; return 0;&#125;结果输出：主线程开始执行！join()是否可调：true子线程开始执行！子线程执行完毕！join()是否可调：false主线程执行完毕！ 注意 1、为了确保子线程程序在发送异常退出前完成，就需要对注意调用join()函数的位置，否则当主线发生异常而此时还没有调用到join()函数，那么子线程随主线程终止。解决方法是在异常处理中调用join()。 异常发生的情况，子线程没有完成就随主线程终止。 123456789101112131415161718192021222324#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;static void func()&#123; cout &lt;&lt; &quot;子线程func开始执行！&quot; &lt;&lt; endl; //do something int i = 100000; while (i--) &#123;&#125; cout &lt;&lt; &quot;子线程func执行结束！&quot; &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; &quot;主线程main开始执行！&quot; &lt;&lt; endl; thread t(func); throw 123; t.join(); cout &lt;&lt; &quot;主线程main执行结束！&quot; &lt;&lt; endl; return 0;&#125; 在异常处理中调用join() 12345678910111213141516171819202122232425262728293031323334353637#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt; //for rand()using namespace std;void func()&#123; cout &lt;&lt; &quot;子线程func开始执行！&quot; &lt;&lt; endl; //do something int i = 100000; while(i--) &#123; &#125; cout &lt;&lt; &quot;子线程func执行结束！&quot; &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; &quot;主线程main开始执行！&quot; &lt;&lt; endl; thread t(func); try &#123; //do something if (rand() % 7) //随机抛出异常来模拟异常发生 &#123; throw 123; &#125; &#125; catch(...) &#123; //do something t.join(); abort(); //终止主线程 &#125; t.join(); //未发生异常时使用 cout &lt;&lt; &quot;主线程main执行结束！&quot; &lt;&lt; endl; return 0;&#125; 2、为了应对忘记使用join()和选择位置的问题，可以使用RAII机制来管理子线程，在RAII析构中调用join()。这样在我根本不需要考虑join的位置问题，还是是否忘记的问题。但是这个方式在程序异常的情况下并不能保证主线程被终止时，子线程执行结束。因为程序因异常而终止时，如果没有捕获，对象的析构不会发生，只能由系统来回收资源。关于RAII：cpp中的RAII机制 使用RAII在析构中调用join() 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;void func()&#123; cout &lt;&lt; &quot;子线程func开始执行！&quot; &lt;&lt; endl; //do something int i = 100000 ; while(i--) &#123; &#125; cout &lt;&lt; &quot;子线程func执行结束！&quot; &lt;&lt; endl;&#125;class RAII_thread&#123; thread&amp; t;public: explicit RAII_thread(thread&amp; t_): t(t_) &#123; &#125; ~RAII_thread()&#123; if(t.joinable()) t.join(); &#125; RAII_thread(RAII_thread const&amp;) = delete; RAII_thread&amp; operator=(RAII_thread const&amp;) = delete;&#125;;int main()&#123; //确保异常发生时，子线程执行完毕的技巧2，使用RAII管理子线程 cout &lt;&lt; &quot;主线程main开始执行！&quot; &lt;&lt; endl; thread t(func); RAII_thread raii(t); //do something cout &lt;&lt; &quot;主线程main执行结束！&quot; &lt;&lt; endl; return 0;&#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"https://marblemm.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"cpp11多线程1-thread","slug":"cpp11多线程1-thread","date":"2021-08-15T12:08:58.000Z","updated":"2021-08-27T16:44:45.117Z","comments":true,"path":"2021/08/15/cpp11多线程1-thread/","link":"","permalink":"https://marblemm.github.io/2021/08/15/cpp11%E5%A4%9A%E7%BA%BF%E7%A8%8B1-thread/","excerpt":"","text":"std::thread在C++11之前，C++语言层面是不支持多线程的，想利用C++实现并发程序，借助操作系统的API实现跨平台的并发程序存在着诸多不便，当C++11在语言层面支持多线程后，编写跨平台的多线程代码就方便了许多。 C++11提供的std::thread在开发多线程方面带来了便捷。 123456789101112131415#include &lt;iostream&gt;#include &lt;thread&gt;​void threadfunc()&#123; std::cout &lt;&lt; &quot;thread func&quot; &lt;&lt; std::endl;&#125;​​int main()&#123; std::thread t1(threadfunc); t1.join(); //等待threadfunc运行结束 return 0;&#125; 首先定义线程对象t1，线程函数threadfunc运行在线程对象t1中，当线程创建成功并执行线程函数后，一定要保证线程函数运行结束才能退出，这里调用了join()函数阻塞线程，直到threadfunc()运行结束，回收对应创建线程的资源。如果不阻塞线程，就不能保证线程对象t1在threadfunc()运行期间有效，下面不调用join()阻塞线程。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;thread&gt;​void threadfunc()&#123; std::cout &lt;&lt; &quot;thread func&quot; &lt;&lt; std::endl;&#125;​​int main()&#123; std::thread t1(threadfunc); //t1.join(); //等待threadfunc运行结束 return 0;&#125;````在运行时引起了程序崩溃。![error1.jpg](error1.jpg)除了调用join()阻塞线程，保证线程对象在线程函数运行期间的有效性，还可以通过线程分离的手段实现，调用detach()函数使得线程对象与线程函数分离，这样，在线程函数运行期间，线程对象与线程函数就没有联系了，此时的线程是作为后台线程去执行，detach()后就无法再和线程发生联系，也不能通过join()来等待线程执行完毕，线程何时执行完无法控制，它的资源会被init进程回收，所以，通常不采用detach()方法。 #include #include ​void threadfunc(){ std::cout &lt;&lt; “ detach thread func” &lt;&lt; std::endl;}​int main(){ std::thread t1(threadfunc); t1.detach(); //线程分离​ return 0;} 12这里调用detach()实现线程分离，但是运行后，主线程退出的时候threadfunc()还没有输出“detach thread func”，threadfunc()什么时候运行结束也无法确定，为了看到所创建的线程运行结果，在主线程等待一下再退出。 #include #include #include //时间​void threadfunc(){ std::cout &lt;&lt; “detach thread func” &lt;&lt; std::endl;}​int main(){ std::thread t1(threadfunc); t1.detach(); while (true) { std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒 break; } return 0; } 1此时运行结果： detach thread func 1通过std::thread创建的线程是不可以复制的，但是可以移动。 #include #include #include ​void threadfunc(){ std::cout &lt;&lt; “move thread func” &lt;&lt; std::endl;}​int main(){ std::thread t1(threadfunc); std::thread t2(std::move(t1)); t2.join(); while (true) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒 break; &#125; return 0; } 1输出结果： move thread func 1234567移动后t1就不代表任何线程了，t2对象代表着线程threadfunc()。## 其他创建线程方式### 通过std::bind来创建线程函数。 #include #include #include //时间#include //std::bind​class A {public: void threadfunc() { std::cout &lt;&lt; “bind thread func” &lt;&lt; std::endl; }};​​int main(){ A a; std::thread t1(std::bind(&amp;A::threadfunc,&amp;a)); t1.join(); while (true) { std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒 break; } return 0; } 创建一个类A，然后再main函数中将类A中的成员函数绑定到线程对象t1上，运行结果： 1bind thread func ### 仿函数对象 1234567891011121314151617181920#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;class Test&#123;public: void operator()()&#123; cout &lt;&lt; &quot;子线程开始执行！&quot; &lt;&lt; endl; //do something cout &lt;&lt; &quot;子线程执行完毕！&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; // thread t(Test()); 这种写法会编译器会认为是一个函数声明，这个函数带有一个参数(函数指针指向没有参数并返回Test对象的函数) thread t((Test())); //可以使用加小括号，或者使用一只初始化，或者传入命名变量 t.join(); //主线程等待子线程 return 0;&#125; ### lambda表达式 1234567891011121314151617#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; thread t( [] () &#123; cout &lt;&lt; &quot;子线程开始执行！&quot; &lt;&lt; endl; //do something cout &lt;&lt; &quot;子线程执行完毕！&quot; &lt;&lt; endl; &#125; ); t.join(); //主线程等待子线程 return 0;&#125; ### 非静态成员函数，静态成员函数 以下的下写法中是将对象拷贝了一份副本来创建线程。当我们在进行共享数据的管理时，有时候需要传入对象的指针或者地址。而静态成员函数，不需要传入对象，只需要传入类函数地址。根据C++对象模型，这很好理解因为编译器对非静态成员函数的处理需要this指针，而对静态成员函数的处理不需要。 1234567891011121314151617181920#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;class Test&#123;public: void test()&#123; cout &lt;&lt; &quot;子线程开始执行！&quot; &lt;&lt; endl; // do somesthing cout &lt;&lt; &quot;子线程执行完毕！&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Test obj; thread t(&amp;Test::test, obj); //注意写法，传入成员函数地址，还需要传入对象 t.join(); //主线程等待子线程 return 0;&#125; ## 获取线程id 线程标识类型是 std::thread::id 类型。有两种获取id的方法。 方法一：可以通过调用 std::thread 对象的成员函数 get_id() 来获取id。 方法二：在当前线程中使用std::this_thread::get_id()来获取线程id。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;functional&gt;​class A &#123;public: void threadfunc() &#123; std::cout &lt;&lt; &quot;bind thread func&quot; &lt;&lt; std::endl; &#125;&#125;;​​int main()&#123; A a; std::thread t1(std::bind(&amp;A::threadfunc,&amp;a)); std::cout &lt;&lt; &quot;main thread ID is : &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;t1 thread ID is : &quot; &lt;&lt; t1.get_id() &lt;&lt; std::endl; t1.join(); while (true) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒 break; &#125; return 0;&#125; std::this_thread::get_id()获取的是当前线程的ID，t1.get_id()获取的是所创建的t1对象中运行的线程ID，对应的ID分别为： 123main thread ID is : 11932t1 thread ID is : 12076bind thread func 虽然get_id()可以获取线程的ID，但是其返回类型是thread::id，通过std::cout可以输出线程ID，但是这样使用似乎不太方面，要是能转换为整形就好了。其实可以将得到的线程ID写入到ostreamstring流中，转换成string类型，再转换成整形。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;functional&gt;#include &lt;sstream&gt;​class A &#123;public: void threadfunc() &#123; std::cout &lt;&lt; &quot;bind thread func&quot; &lt;&lt; std::endl; &#125;&#125;;​​int main()&#123; A a; std::thread t1(std::bind(&amp;A::threadfunc, &amp;a));​ std::ostringstream os1; os1 &lt;&lt; t1.get_id() &lt;&lt; std::endl; std::string strID = os1.str(); //转换成string类型 int threadID = atoi(strID.c_str()); //转换成int类型 std::cout &lt;&lt; &quot;t1 thread ID is : &quot; &lt;&lt; threadID &lt;&lt; std::endl;​ t1.join(); while (true) &#123; std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒 break; &#125;​ return 0;&#125; 输出结果： 123t1 thread ID is : 6956bind thread func 参考： https://zhuanlan.zhihu.com/p/157171731 https://www.cnblogs.com/chen-cs/p/13054027.html","categories":[{"name":"多线程","slug":"多线程","permalink":"https://marblemm.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[]},{"title":"字符类型总结区别wchar_t和char","slug":"字符类型总结区别wchar_t和char","date":"2021-08-14T03:07:29.000Z","updated":"2021-08-30T15:46:18.123Z","comments":true,"path":"2021/08/14/字符类型总结区别wchar_t和char/","link":"","permalink":"https://marblemm.github.io/2021/08/14/%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93%E5%8C%BA%E5%88%ABwchar_t%E5%92%8Cchar/","excerpt":"","text":"1.区别wchar_t,char,WCHARANSI：即 char(8bit)，可用字符串处理函数：strcat( ),strcpy( ), strlen( )等以str打头的函数。 UNICODE：wchar_t(16bit)是Unicode字符的数据类型，可用字符串处理函数：wcscat(),wcscpy(),wcslen()等以wcs打头的函数。它实际定义在里： 123 typedef unsigned short wchar_t; 另外，在头文件中有这样的定义：typedef wchar_t WCHAR; 所以WCHAR实际就是wchar_t 为了让编译器识别Unicode字符串，必须以在前面加一个“L”,例如: wchar_t *szTest=L&quot;This is a Unicode string.&quot;; 2.TCHAR 在C语言里面提供了 _UNICODE宏（有下划线），在Windows里面提供了UNICODE宏（无下划线），只要定了_UNICODE宏和UNICODE宏，系统就会自 动切换到UNICODE版本，否则，系统按照ANSI的方式进行编译和运行。只定义了宏并不能实现自动的转换，他还需要一系列的字符定义支持。 1234567891． TCHAR 如果定义了UNICODE宏则TCHAR被定义为wchar_t。 typedef wchar_t TCHAR; 否则TCHAR被定义为char typedef char TCHAR;2． LPTSTR 如果定义了UNICODE宏则LPTSTR被定义为LPWSTR。 typedef LPTSTR LPWSTR; 否则TCHAR被定义为char typedef LPTSTR LPSTR; 说明：在使用字符串常量的时候需要使用_TEXT(“MyStr”)或者_T(&quot;&quot;)来支持系统的自动转换。 3.bstr字符串BSTR 4.更进一步的字符串以及其指针的类型定义 由于Win32 API文档的函数列表使用函数的常用名字（例如， “SetWindowText”），所有的字符串都是用TCHAR来定义的。（除了XP中引入的只适用于Unicode的API）。下面列出一些常用的typedefs，你可以在msdn中看到他们。 12345678910type Meaning in MBCS builds Meaning in Unicode buildsWCHAR wchar_t wchar_tLPSTR char* char*LPCSTR const char* const char*LPWSTR wchar_t* wchar_t*LPCWSTR wchar_t* wchar_t*TCHAR TCHAR char wchar_tLPTSTR TCHAR* TCHAR*LPCTSTR const TCHAR* const TCHAR* 5.相互转换wchar_t* 转为 char*123456wchar_t* pwszUnicode = L&quot;Holle&quot;; //wcslen(pwsUnicode)=5int iSize;char* pszMultiByte;//返回接受字符串所需缓冲区的大小，已经包含字符结尾符&#x27;\\0&#x27;iSize = WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, NULL, 0, NULL, NULL); //iSize =wcslen(pwsUnicode)+1=6pszMultiByte = (char*)malloc(iSize*sizeof(char)); //不需要 pszMultiByte = (char*)malloc(iSize*sizeof(char)+1);WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, pszMultiByte, iSize, NULL, NULL); char 转为 wchar_t123456char* pszMultiByte = &quot;Holle&quot;; //strlen(pwsUnicode)=5int iSize; wchar_t* pwszUnicode ; //返回接受字符串所需缓冲区的大小，已经包含字符结尾符&#x27;\\0&#x27;iSize = MultiByteToWideChar(CP_ACP, 0, pszMultiByte , -1, NULL, 0); //iSize =wcslen(pwsUnicode)+1=6pwszUnicode = (wchar_t *)malloc(iSize*sizeof(wchar_t)); //不需要 pwszUnicode = (wchar_t *)malloc((iSize+1)*sizeof(wchar_t))MultiByteToWideChar(CP_ACP, 0, pszMultiByte , -1, pwszUnicode , iSize); char*转换成CString12345678910111213141516171819202122 若将char*转换成CString，除了直接赋值外，还可使用CString::Format进行。例如： char chArray[] = &quot;This is a test&quot;; char * p = &quot;This is a test&quot;; 或 LPSTR p = &quot;This is a test&quot;; 或在已定义Unicode应的用程序中 TCHAR * p = _T(&quot;This is a test&quot;); 或 LPTSTR p = _T(&quot;This is a test&quot;); CString theString = chArray; theString.Format(_T(&quot;%s&quot;), chArray); theString = p;//方法一char *p = &quot;test&quot;;CString str(p);//方法二char * pFileName = &quot;test&quot;; USES_CONVERSION;CString s = A2T(pFileName);//CString s = A2W(pFileName); CString转换成char*12345678910111213141516171819202122232425262728 若将CString类转换成char*(LPSTR)类型，常常使用下列三种方法： 方法一，使用强制转换。例如： CString theString( &quot;This is a test&quot; ); LPTSTR lpsz =(LPTSTR)(LPCTSTR)theString; 方法二，使用strcpy。例如： CString theString( &quot;This is a test&quot; ); LPTSTR lpsz = new TCHAR[theString.GetLength()+1]; _tcscpy(lpsz, theString); 需要说明的是，strcpy(或可移值Unicode/MBCS的_tcscpy)的第二个参数是 const wchar_t* (Unicode)或const char* (ANSI)，系统编译器将会自动对其进行转换。 方法三，使用CString::GetBuffer。例如： CString s(_T(&quot;This is a test &quot;)); LPTSTR p = s.GetBuffer(); // 在这里添加使用p的代码 if(p != NULL) *p = _T(&#x27;\\0&#x27;); s.ReleaseBuffer(); // 使用完后及时释放，以便能使用其它的CString成员函数//方法四CString cstr = _T(&quot;test&quot;)//声明标识USES_CONVERSION;//函数T2A和W2A均支持ATL和MFC中的字符char * pFileName = T2A(cstr); //char * pFileName = W2A(cstr); //也可实现转换//注意：有时候可能还需要添加引用#include &lt;afxpriv.h&gt; BSTR转换成char*123456789101112131415 方法一，使用ConvertBSTRToString。例如： #include #pragma comment(lib, &quot;comsupp.lib&quot;) int _tmain(int argc, _TCHAR* argv[])&#123; BSTR bstrText = ::SysAllocString(L&quot;Test&quot;); char* lpszText2 = _com_util::ConvertBSTRToString(bstrText); SysFreeString(bstrText); // 用完释放 delete[] lpszText2; return 0; &#125; 方法二，使用_bstr_t的赋值运算符重载。例如： _bstr_t b = bstrText; char* lpszText2 = b;//底层还是调的_com_util::ConvertBSTRToString(bstrText);``` ### char*转换成BSTR 方法一，使用SysAllocString等API函数。例如： BSTR bstrText = ::SysAllocString(L”Test”); BSTR bstrText = ::SysAllocStringLen(L”Test”,4); BSTR bstrText = ::SysAllocStringByteLen(“Test”,4); 方法二，使用COleVariant或_variant_t。例如： //COleVariant strVar(“This is a test”); _variant_t strVar(“This is a test”); BSTR bstrText = strVar.bstrVal; 方法三，使用_bstr_t，这是一种最简单的方法。例如： BSTR bstrText = _bstr_t(“This is a test”);//底层还是调的方法五 方法四，使用CComBSTR。例如： BSTR bstrText = CComBSTR(“This is a test”); 或 CComBSTR bstr(“This is a test”); BSTR bstrText = bstr.m_str; 方法五，使用ConvertStringToBSTR。例如： char* lpszText = “Test”; BSTR bstrText = _com_util::ConvertStringToBSTR(lpszText); //使用前需要加上头文件comutil.h 反之可以使用char *p=_com_util::ConvertBSTRToString(b); 1### CString转换成BSTR 通常是通过使用CStringT::AllocSysString来实现。例如： CString str(“This is a test”); BSTR bstrText = str.AllocSysString(); … SysFreeString(bstrText); // 用完释放 123 注意：用完之后必须使用SysFreeString 释放！！！### BSTR转换成CString 方法一： BSTR bstrText = ::SysAllocString(L”Test”); CStringA str; str.Empty(); str = (LPCSTR)bstrText;方法二： BSTR bstrText = ::SysAllocString(L”Test”); CStringA str(bstrText); 12345### CString转_bstr_t``` _bstr_t bstr; CString strSql; bstr = (_bstr_t)strSql; _bstr_t转CString123_bstr_t bstr;CString strSql; strSql = (LPCSTR)bstr; BSTR 转LPCTSTR1234567//方法一：_bstr_t strstr = bstrtext;LPCTSTR lpctstrname = strstr;//方法二:CString str = bstrtext;LPCTSTR lpctstrname = (LPCTSTR)str; LPCTSTR转CString12345678910//方法一：LPCTSTR lpctStr;CString cStr=lpctStr;//方法二：LPCTSTR p; CString str=&quot;hello&quot;; p=str.GetBuffer(str.GetLength()); str.ReleaseBuffer(); CString与LPCWSTR12345678910111213141516171819两者的不同：LPCWSTR 是Unicode字符串指针，初始化时串有多大，申请空间就有多大，以后存贮若超过则出现无法预料的结果，这是它与CString的不同之处。而CString是一个串类，内存空间类会自动管理。CString转换成LPCWSTR方法一：CString strFileName; LPCWSTR lpcwStr = strFileName.AllocSysString();方法二：CString str=_T(&quot;TestStr&quot;); USES_CONVERSION; LPCWSTR lpcwStr = A2CW((LPCSTR)str);MFC中CString和LPSTR是可以通用，其中A2CW表示(LPCSTR) -&gt; (LPCWSTR)，USER_CONVERSION表示用来定义一些中间变量，在使用ATL的转换宏之前必须定义该语句。LPCWSTR转换成CStringLPCWSTR lpcwStr = L&quot;TestWStr&quot;; CString str(lpcwStr); CString转换成LPSTR1234567891011121314151617181920方法一：CString strFileName; LPSTR lpStr = strFileName.GetBuffer(); strFileName.ReleaseBuffer();方法二：CString strFileName; LPSTR lpStr = (LPSTR)(LPCSTR)strFimeName;LPSTR转换成CString: LPSTR lpStr = L&quot;TestStr&quot;; CString str(lpStr);注意：CString和LPCSTR可直接转换，如下: CString str; LPCSTR lpcStr = (LPCSTR)str; ANSI、Unicode和宽字符之间的转换123456789101112131415 方法一，使用MultiByteToWideChar将ANSI字符转换成Unicode字符，使用WideCharToMultiByte将Unicode字符转换成ANSI字符。 方法二，使用“_T”将ANSI转换成“一般”类型字符串，使用“L”将ANSI转换成Unicode，而在托管C++环境中还可使用S将ANSI字符串转换成String*对象。例如： TCHAR tstr[] = _T(&quot;this is a test&quot;); wchar_t wszStr[] = L&quot;This is a test&quot;; String* str = S”This is a test”; 方法三，使用ATL 7.0的转换宏和类。ATL7.0在原有3.0基础上完善和增加了许多字符串转换宏以及提供相应的类，它具有如图3所示的统一形式： 其中，第一个C表示“类”，以便于ATL 3.0宏相区别，第二个C表示常量，2表示“to”，EX表示要开辟一定大小的缓冲。SourceType和DestinationType可以是A、 T、W和OLE，其含义分别是ANSI、Unicode、“一般”类型和OLE字符串。例如，CA2CT就是将ANSI转换成一般类型的字符串常量。下面 是一些示例代码： LPTSTR tstr= CA2TEX&lt;16&gt;(&quot;this is a test&quot;); LPCTSTR tcstr= CA2CT(&quot;this is a test&quot;); wchar_t wszStr[] = L&quot;This is a test&quot;; char* chstr = CW2A(wszStr); https://www.cnblogs.com/zhoug2020/archive/2012/06/13/2547463.html http://www.imkevinyang.com/2010/06/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84.html http://cppblog.com/lizao2/articles/169250.html","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.github.io/categories/c/"}],"tags":[]},{"title":"c++面试总结-STL","slug":"cpp面试总结-STL","date":"2021-08-13T14:51:37.000Z","updated":"2021-08-27T14:41:37.811Z","comments":true,"path":"2021/08/13/cpp面试总结-STL/","link":"","permalink":"https://marblemm.github.io/2021/08/13/cpp%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-STL/","excerpt":"","text":"STL常用的容器有哪些以及各自的特点是什么?12345678910111213141.vector:底层数据结构为数组 ，支持快速随机访问。2.list:底层数据结构为双向链表，支持快速增删。3.deque:底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问。4.stack:底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时5.queue:底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）6.priority_queue:的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现7.set:底层数据结构为红黑树，有序，不重复。8.multiset:底层数据结构为红黑树，有序，可重复。 9.map:底层数据结构为红黑树，有序，不重复。10.multimap:底层数据结构为红黑树，有序，可重复。11.hash_set:底层数据结构为hash表，无序，不重复。12.hash_multiset:底层数据结构为hash表，无序，可重复 。13.hash_map :底层数据结构为hash表，无序，不重复。14.hash_multimap:底层数据结构为hash表，无序，可重复。 使用场景 1、如果你需要高效的随机存取，而不在乎插入和删除的效率，使用vector 2、如果你需要大量的插入和删除，而不关心随机存取，则应使用list 3、如果你需要随机存取，而且关心两端数据的插入和删除，则应使用deque。 4、如果你要存储一个数据字典，并要求方便地根据key找value，那么map是较好的选择 5、如果你要查找一个元素是否在某集合内存中，则使用set存储这个集合比较好 说说 vector 和 list 的区别1） vector， 连续存储的容器，动态数组，在堆上分配空间 ； 底层实现：数组。 如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素。 适用场景：经常随机访问，且不经常对非尾节点进行插入删除。 2）list，动态链表，在堆上分配空间，每插入一个元素都会分配空间，每删除一个元素都会释放空间。 底层：双向链表 访问：随机访问性能很差，只能快速访问头尾节点。 适用场景：经常插入删除大量数据 2） vector在中间节点进行插入删除会导致内存拷贝，list不会。 3） vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。 4） vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。 list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。 map 和 set 有什么区别1） map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。 2） map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。 3） set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。 4） map支持下标操作，set不支持下标操作。map可以用key做下标， unordered_map和map 说说区别内部实现机理 map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。 unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的优缺点以及适用处 1234567891011121314map 优点： 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作红黑树，内部实现一个红黑书使得map的很多操作在的时间复杂度下就可以实现，因此效率非常的高缺点： 适用处，对于那些有顺序要求的问题，用map会更高效一些空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间unordered_map 优点： 因为内部实现了哈希表，因此其查找速度非常的快缺点： 适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map哈希表的建立比较耗费时间 STL 中迭代器的作用，有指针为何还要迭代器1） Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 2） 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等，相当于一种智能指针。 3） 迭代器产生原因： Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。 STL 迭代器是怎么删除元素的呢1） 对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器； 2） 对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。 3） 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator， 平衡二叉树（AVL树）和红黑树1）平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。 2）红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑），红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。 3）所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。 1234567891011121314151617请你回答一下map底层为什么用红黑树实现1、红黑树：红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。性质：1. 每个节点非红即黑2. 根节点是黑的;3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;4. 如果一个节点是红色的，则它的子节点必须是黑色的。5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;2、平衡二叉树（AVL树）：红黑树是在AVL树的基础上提出来的。平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。3、红黑树较AVL树的优点：AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。 栈溢出的原因栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数。 1） 局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出，局部变量是存储在栈中的。 2） 递归调用层次太多。 3） 指针或数组越界。例如进行字符串拷贝，或处理用户输入等等。 堆和栈的区别C语言的内存模型分为5个区：栈区、堆区、静态区、常量区、代码区。 1）栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放。栈由系统自动分配，速度快，但是程序员无法控制。 2） 堆区：就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作。一般是由程序员分配释放，未被释放可能引起内存泄漏。堆是有程序员自己分配，速度较慢，容易产生碎片，不过用起来方便。 3）全局变量和静态变量的存储是放在一块的。 4）常量区：常量存储在这里，不允许修改。 5） 代码区：存放函数体的二进制代码。 哈希表（hash表）哈希表的实现主要包括构造哈希和处理哈希冲突：构造哈希，主要包括直接地址法，除留余数法。 处理哈希冲突：当哈希表关键字集合很大时，关键字值不同的元素可能会映射到哈希表的同一地址上，这样的现象称为哈希冲突。常用的解决方法有： 1） 开放定址法，冲突时，用某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。（如，线性探测，平方探测） 2） 再哈希法：当发生冲突时，用另一个哈希函数计算地址值，直到冲突不再发生。 3） 链地址法：将所有哈希值相同的key通过链表存储，key按顺序插入链表中。","categories":[{"name":"c++面试","slug":"c-面试","permalink":"https://marblemm.github.io/categories/c-%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"string和char*的区别","slug":"string和char-的区别","date":"2021-08-13T12:52:19.000Z","updated":"2021-08-13T14:50:32.436Z","comments":true,"path":"2021/08/13/string和char-的区别/","link":"","permalink":"https://marblemm.github.io/2021/08/13/string%E5%92%8Cchar-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1、定义：string：string是STL当中的一个容器，对其进行了封装，所以操作起来非常方便。 char*：char *是一个指针，可以指向一个字符串数组，至于这个数组可以在栈上分配，也可以在堆上分配，堆得话就要你手动释放了。 2、区别：string的内存管理是由系统处理，除非系统内存池用完，不然不会出现这种内存问题。char *的内存管理由用户自己处理，很容易出现内存不足的问题。 当我们要存一个串，但是不知道其他需要多少内存时， 用string来处理就最好不过了。当你知道了存储的内存的时候，可以用char *，但是不如用string的好，用指针总会有隐患。 用string还可以使用各种成员函数来处理串的每一个字符，方便处理。用char *处理串，就不如string的方便了，没有相应的函数来直接调用，而是要自己编写函数来完成串的处理，而且处理过程中用指针还很容易出现内存问题。 char *s=”string”的内容是不可以改的；char s[10]=”string”的内容是可以改的 const char* c_str(); c_str()函数返回一个指向C字符串的指针，该指针指向内存内容和string 相同。因为c语言不支持string类型，故为了在c++兼容C字符串，提供了c_str()函数来实现转换。注意一定要使用strcpy()函数来操作c_str()；c_str()返回的是一个临时指针，不能对其进行操作。 char ch[20]; string s=”123456”; strcpy(ch,s.c_str()); c_str()以char* 形式传回string内含字符串 如果一个函数要求char*参数，可以使用c_str()方法 3、注意：当我们定义了一个string，就不能用scanf(“%s”,s)和printf(“%s”,s)输入输出。主要是因为%s要求后面是对象的首地址 4、转化：当 string 直接转化成 const char *时，可以通过两个函数c_str()，data成员函数，其中c_str()函数返回一个以’\\0’结尾的字符数组，而data()仅返回字符串内容，而不含有结束符’\\0’。","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.github.io/categories/c/"}],"tags":[]},{"title":"c++编程书籍总结","slug":"cpp编程书籍总结","date":"2021-08-11T12:49:13.000Z","updated":"2021-08-27T14:43:21.847Z","comments":true,"path":"2021/08/11/cpp编程书籍总结/","link":"","permalink":"https://marblemm.github.io/2021/08/11/cpp%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.入门书籍C++ Primer 中文版（第5版）C++ Primer (Fifth Edition)C++ Primer Plus 中文版（第六版）C++ Primer Plus (Sixth Edition) 2.进阶书籍Thinking in C++A Tour Of C++The C++ Standard Library: A Tutorial and ReferenceEffective STL泛型编程与STLSTL源码剖析 3.高阶书籍深度探索C对象模型Design Patterns:Elements of Reusable Object-Oriented software设计模式：可复用面向对象软件的基础STL 源码剖析The C Standard : Incorporating Technical Corrigendum No. 1Preprocessor C++(More)Effective C++(More)Exceptional C++C++ TemplatesCore C++ A Software Engineering Approach高质量C++编程指南——上海贝尔标准编程文档","categories":[{"name":"书籍","slug":"书籍","permalink":"https://marblemm.github.io/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[]},{"title":"c++面试总结（二）","slug":"cpp面试总结（二）","date":"2021-08-10T13:28:09.000Z","updated":"2021-08-27T14:42:51.327Z","comments":true,"path":"2021/08/10/cpp面试总结（二）/","link":"","permalink":"https://marblemm.github.io/2021/08/10/cpp%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"1.有哪几种情况只能用intialization list 而不能用assignment?答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。 2. C++是不是类型安全的？答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。 3. main 函数执行以前，还会执行什么代码？答案：全局对象的构造函数会在main 函数之前执行。 4. 描述内存分配方式以及它们的区别?1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。 2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。 3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。 5.请说出const与#define 相比，有何优点？答案： const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。 1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。 2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。 6.简述数组与指针的区别？数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。 1234567891011121314151617181920212223242526272829(1)修改内容上的差别char a[] = “hello”;a[0] = ‘X’;char *p = “world”; // 注意p 指向常量字符串p[0] = ‘X’; // 编译器不能发现该错误，运行时错误(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。char a[] = &quot;hello world&quot;;char *p = a;cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节计算数组和指针的内存容量void Func(char a[100])&#123;cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节&#125; 7： int (*s[10])(int) 表示的是什么？int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 8：栈内存与文字常量区12345678910111213141516171819char str1[] = &quot;abc&quot;; char str2[] = &quot;abc&quot;; const char str3[] = &quot;abc&quot;; const char str4[] = &quot;abc&quot;; const char *str5 = &quot;abc&quot;; const char *str6 = &quot;abc&quot;; char *str7 = &quot;abc&quot;; char *str8 = &quot;abc&quot;; cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;//0 分别指向各自的栈内存 cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;//0 分别指向各自的栈内存 cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;//1指向文字常量区地址相同 cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;//1指向文字常量区地址相同 结果是：0 0 1 1 解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。 9：将程序跳转到指定内存地址要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？ 123456789 *((void (*)( ))0x100000 ) ( ); 首先要将0x100000强制转换成函数指针,即: (void (*)())0x100000 然后再调用它: *((void (*)())0x100000)(); 用typedef可以看得更直观些: typedef void(*)() voidFuncPtr; *((voidFuncPtr)0x100000)(); 10：int id[sizeof(unsigned long)];这个对吗？为什么？ 答案:正确 这个 sizeof是编译时运算符，编译时就确定了 ,可以看成和机器有关的常量。 当sizeof的参数是数组名时，计算的是整个数组的存储大小；当sizeof的参数是指针时，计算的是指针的大小（8字节，64位系统） 11：引用与指针有什么区别？【参考答案】 引用必须被初始化，指针不必。 引用初始化以后不能被改变，指针可以改变所指的对象。 不存在指向空值的引用，但是存在指向空值的指针。 12：基类的析构函数不是虚函数，会带来什么问题？【参考答案】派生类的析构函数用不上，会造成资源的泄漏。 13：全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？【参考答案】 生命周期不同： 全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。 操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。 STL中排序算法的实现是什么解答：STL中的sort()，在数据量大时，采用quicksort，分段递归排序；一旦分段后的数量小于某个门限值，改用Insertion sort，避免quicksort深度递归带来的过大的额外负担，如果递归层次过深，还会改用heapsort。 为什么函数参数的入栈的顺序是从右往左因为好多函数是不定参数个数的，比如最常用的printf，所以需要参数的入栈顺序是从右往左。 5. static的用法和作用？1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可） 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。 2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。 3.static的第三个作用是默认初始化为0（static变量） 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。 4.static的第四个作用：C++中的类成员声明static 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问； 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内； 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝； 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。 类内： static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化； 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员； static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function 8. const成员函数的理解和应用？① const Stock &amp; Stock::topval (②const Stock &amp; s) ③const ①处const：确保返回的Stock对象在以后的使用中不能被修改 ②处const：确保此方法不修改传递的参数 S ③处const：保证此方法不修改调用它的对象，const对象只能调用const成员函数,不能调用非const函数 11. extern用法？ extern修饰变量的声明 如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。 extern修饰函数的声明 如果文件a.c需要引用b.c中的函数，比如在b.c中原型是int fun(int mu)，那么就可以在a.c中声明extern int fun（int mu），然后就能使用fun来做任何事情。就像变量的声明一样，extern int fun（int mu）可以放在a.c中任何地方，而不一定非要放在a.c的文件作用域的范围中。 extern修饰符可用于指示C或者C＋＋函数的调用规范。 比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。 21. 构造函数和析构函数可以调用虚函数吗，为什么 在C++中，提倡不在构造函数和析构函数中调用虚函数； 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本； 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编； 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。 参考： https://zhuanlan.zhihu.com/p/143177919","categories":[{"name":"c++面试","slug":"c-面试","permalink":"https://marblemm.github.io/categories/c-%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"c++面试总结（一）","slug":"cpp面试总结（一）","date":"2021-08-09T15:50:50.000Z","updated":"2021-08-27T14:42:07.081Z","comments":true,"path":"2021/08/09/cpp面试总结（一）/","link":"","permalink":"https://marblemm.github.io/2021/08/09/cpp%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"1.new、delete、malloc、free关系delete会调用对象的析构函数,和new对应free只会释放内存，new调用构造函数。malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。 2.delete与 delete []区别delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套 （1）. 针对简单类型 使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可 如： 123456int *a = new int[10];delete a;delete [] a;此种情况中的释放效果相同，原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间(在分配过程中 系统会记录分配内存的大小等信息，此信息保存在结构体_CrtMemBlockHeader中，具体情况可参看VC安装目录下CRT\\SRC\\DBGDEL.cpp) （2）. 针对类Class，两种方式体现出具体差异 123456789101112131415161718 当你通过下列方式分配一个类对象数组： class A &#123; private: char *m_cBuffer; int m_nLen; public: A()&#123; m_cBuffer = new char[m_nLen]; &#125; ~A() &#123; delete [] m_cBuffer; &#125; &#125;; A *a = new A[10]; delete a; //仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏 delete [] a; //调用使用类对象的析构函数释放用户自己分配内存空间并且 释放了a指针指向的全部内存空间所以总结下就是，如果ptr代表一个用new申请的内存返回的内存空间地址，即所谓的指针，那么： delete ptr 代表用来释放内存，且只用来释放ptr指向的内存。 delete[] rg 用来释放rg指向的内存，！！还逐一调用数组中每个对象的destructor！！ 对于像int/char/long/int*/struct等等简单数据类型，由于对象没有destructor，所以用delete 和delete [] 是一样的！但是如果是C++对象数组就不同了！ 3.子类析构时要调用父类的析构函数吗？析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。 4.多态，虚函数，纯虚函数多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现； 在程序编译时多态性体现在函数和运算符的重载上； 虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。 纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。 从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。 抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。 5.什么是“引用”？申明和使用“引用”要注意哪些问题？答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。 6.将“引用”作为函数参数有哪些特点？（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。 （2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。 （3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。 7.dynamic_cast和static_cast的区别static_cast相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法： 1 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 2 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。 3 把空指针转换成目标类型的空指针。 4 把任何类型的表达式转换成void类型。 注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性 12345678910111213141516171819202122232425262728基本类型数据转换举例如下：char a = &#x27;a&#x27;;int b = static_cast&lt;char&gt;(a);//正确，将char型数据转换成int型数据double *c = new double;void *d = static_cast&lt;void*&gt;(c);//正确，将double指针转换成void指针int e = 10;const int f = static_cast&lt;const int&gt;(e);//正确，将int型数据转换成const int型数据const int g = 20;int *h = static_cast&lt;int*&gt;(&amp;g);//编译错误，static_cast不能转换掉g的const属性类上行和下行转换：class Base&#123;&#125;;class Derived : public Base&#123;&#125;Base* pB = new Base();if(Derived* pD = static_cast&lt;Derived*&gt;(pB))&#123;&#125;//下行转换是不安全的(坚决抵制这种方法)Derived* pD = new Derived();if(Base* pB = static_cast&lt;Base*&gt;(pD))&#123;&#125;//上行转换是安全的 dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）。 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。尽量少使用转型操作，尤其是dynamic_cast，耗时较高，会导致性能的下降，尽量使用其他方法替代。 8.将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?格式：类型标识符 &amp;函数名（形参列表及类型说明）{ //函数体 } 好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error! 注意事项： （1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。 （2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。 （3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。 （4）流操作符重载返回值申明为“引用”的作用： 流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl; 因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。 12345678910111213141516171819202122232425262728293031＃include&lt;iostream.h&gt;int &amp;put(int n);int vals[10];int error=-1;void main()&#123;put(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10; put(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20; cout&lt;&lt;vals[0]; cout&lt;&lt;vals[9];&#125; int &amp;put(int n)&#123;if (n&gt;=0 &amp;&amp; n&lt;=9 ) return vals[n]; else &#123; cout&lt;&lt;&quot;subscript error&quot;; return error; &#125;&#125; （5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。 9、结构与联合有和区别？(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。 (2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。 10.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？常考的题目。从定义上来说： 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。 重写：是指子类重新定义父类虚函数的方法。 从实现原理上来说： 重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！ 重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。","categories":[{"name":"c++面试","slug":"c-面试","permalink":"https://marblemm.github.io/categories/c-%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"git命令整理-导图","slug":"git命令整理-导图","date":"2021-08-09T15:28:16.000Z","updated":"2021-08-09T15:30:36.829Z","comments":true,"path":"2021/08/09/git命令整理-导图/","link":"","permalink":"https://marblemm.github.io/2021/08/09/git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86-%E5%AF%BC%E5%9B%BE/","excerpt":"","text":"git命令整理-导图","categories":[{"name":"git","slug":"git","permalink":"https://marblemm.github.io/categories/git/"}],"tags":[]},{"title":"git命令整理-分支","slug":"git命令整理-分支","date":"2021-08-09T15:21:59.000Z","updated":"2021-08-09T15:30:42.034Z","comments":true,"path":"2021/08/09/git命令整理-分支/","link":"","permalink":"https://marblemm.github.io/2021/08/09/git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86-%E5%88%86%E6%94%AF/","excerpt":"","text":"git分支命令git branch git branch可以用来列出分支,创建分支和删除分支. git branch -v可以看见每一个分支的最后一次提交. git branch: 列出本地所有分支,当前分支会被星号标示出. git branch -a 加上-a参数列出本地和远程所有分支，远程分支会用红色表示出来（如果你开了颜色支持的话） git branch -av git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). git branch -d (branchname): 删除一个分支.（已合并） git branch -D (branchname): 删除一个分支.（未合并） git push --delete origin [branch] 删除远程分支 git branch -m devel develop 重命名本地分支 git checkout git checkout (branchname) 切换到一个分支. git checkout -b (branchname): 创建并切换到新的分支. 这个命令是将git branch newbranch和git checkout newbranch合在一起的结果. checkout还有另一个作用:替换本地改动: git checkout --&lt;filename&gt; 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响. 注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的. git merge 把一个分支merge进当前的分支. git merge [alias]/[branch] 把远程分支merge到当前分支. 如果出现冲突,需要手动修改,可以用git mergetool. 解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved. git tag tag a point in history as import. 会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag. 比如: git tag v1.0 git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag. 当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息. 我们可以利用commit SHA来给一个过去的提交打tag: git tag -a v0.9 XXXX push的时候是不包含tag的,如果想包含,可以在push时加上--tags参数. fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上--tags选项. git remote list, add and delete remote repository aliases. 因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list. git remote: 列出remote aliases. 如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin. git remote -v:可以看见每一个别名对应的实际url. git remote add [alias] [url]: 添加一个新的remote repo. git remote rm [alias]: 删除一个存在的remote alias. git remote rename [old-alias] [new-alias]: 重命名. git remote set-url [alias] [url] 通过命令更新远程url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址. 修改远程仓库地址方法： 以下均以项目git_test为例： 老地址：http://192.168.1.12:9797/john/git_test.git 新地址：http://192.168.100.235:9797/john/git_test.git 远程仓库名称： origin 方法一 通过命令直接修改远程地址 进入git_test根目录git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址 git remote set-url origin http://192.168.100.235:9797/john/git_test.git 方法二 通过命令先删除再添加远程仓库 进入git_test根目录 git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址 git remote rm origin git remote add origin http://192.168.100.235:9797/john/git_test.git 方法三 直接修改配置文件 进入git_test/.git 修改 config 中的 [remote “origin”]下面的url即可 git fetch download new branches and data from a remote repository. 可以git fetch [alias]取某一个远程repo,也可以git fetch --all取到全部repo fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pull fetch from a remote repo and try to merge into the current branch. pull == fetch + merge FETCH_HEAD git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit. 如果使用--rebase参数,它会执行git rebase来取代原来的git merge. git rebase --rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上. rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要: git rebase --continue就会继续打余下的补丁. git rebase --abort将会终止rebase,当前分支将会回到rebase之前的状态. git push push your new branches and data to a remote repository. git push [alias] [branch] 将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支. 如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来. git push --delete origin develop 删除远程develop分支 git reflog git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化. 当git reflog不指定引用的时候,默认列出HEAD的reflog. HEAD@&#123;0&#125;代表HEAD当前的值,HEAD@&#123;3&#125;代表HEAD在3次变化之前的值. git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中.","categories":[{"name":"git","slug":"git","permalink":"https://marblemm.github.io/categories/git/"}],"tags":[]},{"title":"git命令整理-提交","slug":"git命令整理-提交","date":"2021-08-08T03:15:12.000Z","updated":"2021-08-09T15:30:32.139Z","comments":true,"path":"2021/08/08/git命令整理-提交/","link":"","permalink":"https://marblemm.github.io/2021/08/08/git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86-%E6%8F%90%E4%BA%A4/","excerpt":"","text":"git 常用命令整理git init 在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. git clone 获取一个url对应的远程Git repo, 创建一个local copy. 一般的格式是git clone [url]. clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定. git status 查询repo的状态. git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言. git log show commit history of a branch. git log --oneline --number: 每条log只显示一行,显示number条. git log --oneline --graph:可以图形化地表示出分支合并历史. git log branchname可以显示特定分支的log. git log --oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号). git log --decorate会显示出tag信息. git log --author=[author name] 可以指定作者的提交历史. git log --since --before --until --after 根据提交时间筛选log. --no-merges可以将merge的commits排除在外. git log --grep 根据commit信息过滤log: git log --grep=keywords 默认情况下, git log --grep --author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上--all-match的option. git log -S: filter by introduced diff. 比如: git log -SmethodName (注意S和后面的词之间没有等号分隔). git log -p: show patch introduced at each commit. 每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看. 另一种方法是git show [SHA]. git log --stat: show diffstat of changes introduced at each commit. 同样是用来看改动的相对信息的,--stat比-p的输出更简单一些. git add 在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动. git add . 会递归地添加当前工作目录中的所有文件. git diff 不加参数的git diff: show diff of unstaged changes. 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容. 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用: git diff --cached 命令. show diff of staged changes. (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的). git diff HEAD show diff of all staged or unstated changes. 也即比较woking directory和上次提交之间所有的改动. 如果想看自从某个版本之后都改动了什么,可以用: git diff [version tag] 跟log命令一样,diff也可以加上--stat参数来简化输出. git diff [branchA] [branchB]可以用来比较两个分支. 它实际上会返回一个由A到B的patch,不是我们想要的结果. 一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令: git diff [branchA]…[branchB]给出的. 实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果. git commit 提交已经被add进来的改动. git commit -m “the commit message&quot; git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下. git commit --amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消. git reset undo changes and commits. 这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本. git reset HEAD: unstage files from index and reset pointer to HEAD 这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD -- filename, 这个- - 也可以不加. git reset --soft move HEAD to specific commit reference, index and staging are untouched. git reset --hard unstage files AND undo any changes in the working directory since last commit. 使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态. 这里的HEAD可以被写成任何一次提交的SHA-1. 不带soft和hard参数的git reset,实际上带的是默认参数mixed. 总结: git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容. git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容. git reset --hard id.是将git的HEAD变了,文件也变了. 按改动范围排序如下: soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working) git revert 反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了. git revert HEAD: 撤销最近的一个提交. git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交. git rm git rm file: 从staging区移除文件,同时也移除出工作目录. git rm --cached: 从staging区移除文件,但留在工作目录中. git rm --cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树. git clean git clean是从工作目录中移除没有track的文件. 通常的参数是git clean -df: -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行. git mv git rm - - cached orig; mv orig new; git add new git stash 把当前的改动压入一个栈. git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处. git stash list会显示这个栈的list. git stash apply:取出stash中的上一个项目(stash@&#123;0&#125;),并且应用于当前的工作目录. 也可以指定别的项目,比如git stash apply stash@&#123;1&#125;. 如果你在应用stash中项目的同时想要删除它,可以用git stash pop 删除stash中的项目: git stash drop: 删除上一个,也可指定参数删除指定的一个项目. git stash clear: 删除所有项目.","categories":[{"name":"git","slug":"git","permalink":"https://marblemm.github.io/categories/git/"}],"tags":[]},{"title":"git命令整理-配置","slug":"git命令整理-配置","date":"2021-08-08T02:49:54.000Z","updated":"2021-08-09T15:26:03.785Z","comments":true,"path":"2021/08/08/git命令整理-配置/","link":"","permalink":"https://marblemm.github.io/2021/08/08/git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"git config 查看配置信息123456789101112131415161. 查看git配置信息，列表中可以查看git的设置选项$ git config --list 2.查看git用户名、密码、邮箱的配置$ git config user.name$ git config user.email3.设置git用户名、密码、邮箱的配置$ git config user.name &quot;freedom&quot;$ git config user.password &quot;123456&quot;$ git config user.email &quot;1548429568@qq.com&quot;设置全局模式（推荐）git config --global user.name [username]git config --global user.email [email] 设置记住密码（默认15分钟）12345678git config --global credential.helper cache如果想自己设置时间，可以这样做：git config credential.helper &#x27;cache --timeout=3600&#x27;这样就设置一个小时之后失效长期存储密码：git config --global credential.helper store git忽略项gitegnore配置在git中如果想忽略掉某个文件， 不让这个文件提交到版本库中，可以使用修改 .gitignore 文件的方法。这个文件每一行保存了一个匹配的规则 例如 12345678# 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 另外 git 提供了一个全局的 .gitignore你可以在你的用户目录下创建 ~/.gitignoreglobal 文件，以同样的规则来划定哪些文件是不需要版本控制的。需要执行git config –global core.excludesfile ~/.gitignoreglobal来使得它生效。 另外 git 还提供了另一种 exclude 的方式来做同样的事情，不同的是 .gitignore 这个文件本身会提交到版本库中去。用来保存的是公共的需要排除的文件。而 .git/info/exclude 这里设置的 则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。 但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交,所以项目创建的时候就把ignore文件加上，如果没加上，此时也可以把要忽略的文件先删除，然后把ignore加上要忽略的文件，提交到服务器，此后再提交时，要忽略的文件就不会提交上去了","categories":[{"name":"git","slug":"git","permalink":"https://marblemm.github.io/categories/git/"}],"tags":[]},{"title":"从新电脑根据hexo部署到github","slug":"从新电脑根据hexo部署到github","date":"2021-08-04T14:07:48.000Z","updated":"2021-08-09T15:19:26.007Z","comments":true,"path":"2021/08/04/从新电脑根据hexo部署到github/","link":"","permalink":"https://marblemm.github.io/2021/08/04/%E4%BB%8E%E6%96%B0%E7%94%B5%E8%84%91%E6%A0%B9%E6%8D%AEhexo%E9%83%A8%E7%BD%B2%E5%88%B0github/","excerpt":"","text":"marblemm.github.io个人博客 http://marblemm.github.io hexo部署说明准备环境1、安装git 2、设置ssh keygithub设置添加SSH 3、安装nodejs ——-windows：nodejs选择LTS版本就行了。 验证环境打开cmd窗口，输入命令 123git --versionnode -vnpm -v 如果出现，类似如下图所示，说明环境正确 4、 安装hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。输入命令 12npm install -g cnpm --registry=https://registry.npm.taobao.org #使用淘宝镜像，国内速度会比较快npm install hexo-cli -g #安装hexo 然后用hexo -v查看一下版本，至此就全部安装完了。 本地发布123hexo g #生成静态主页hexo s #启动服务hexo d #部署静态页面推送到GitHub仓库","categories":[{"name":"git","slug":"git","permalink":"https://marblemm.github.io/categories/git/"}],"tags":[]},{"title":"c++ 开源项目-入门","slug":"cpp开源项目-入门","date":"2021-08-04T13:16:23.537Z","updated":"2021-08-27T14:43:43.727Z","comments":true,"path":"2021/08/04/cpp开源项目-入门/","link":"","permalink":"https://marblemm.github.io/2021/08/04/cpp%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-%E5%85%A5%E9%97%A8/","excerpt":"","text":"CPlusPlusThingsCPlusPlusThings 是国人开源一个 C++ 学习项目。它系统地将 C++ 学习分为了【基础进阶】、【实战系列】、【C++2.0 新特性】、【设计模式】和【STL 源码剖析】、【并发编程】、【C++ 惯用法】、【学习课程】、【工具】、【拓展】。 作为一个全面系统的 C++ 学习项目，CPlusPlusThings 是优秀的，它合理地安排了 10 Days 的实战部分，在实战中了解语法和函数用法，唯一不足的是，在注释部分有些不尽人意，对部分新手程序员并不是很友好GitHub 地址 MyTinySTL当你学习完 C++ 的“书本”知识后，是不是有些手痒了呢？MyTinySTL 这个注释详细、实践夯实基础的项目便是你 C++ 学习之旅的下一站。作为新手练习用途，MyTinySTL 的作者 Alinshans 用 C++11 重新复写了一个小型 STL（容器库＋算法库）。代码结构清晰规范、包含中文文档与注释，并且自带一个简单的测试框架，适合 C++ 新手来实践一番。GitHub 地址 calculator微软开源的 Windows 系统预装的计算器工具。该工具提供标准、科学、程序员计算器的功能，以及各种度量单位和货币之间的转换功能。快来看看微软工程师编写的代码吧！学习大厂的编码规范、项目结构之类的，提高阅读源码的能力。英文的项目且没有讲解部分，需要通过阅读源码学习，难度较高。GitHub 地址 TinytetrisTinytetris 是一个用 C++ 编写的终端版俄罗斯方块游戏。它提供了两个版本的源码，分为注释版和库版，注释较多易于理解和学习。GitHub 地址 Google开源代码规范GitHub 地址 现代 C++：modern-cpp-tutorialmodern-cpp-tutorial 是现代 C++ 教程，它的目的是提供关于现代 C++（2020 年前）的相关特性的全面介绍。除了介绍了代码之外，它还尽可能简单地介绍了其技术需求的历史背景，这对理解为什么会出现这些特性提供了很大的帮助。 GitHub 地址","categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.github.io/categories/c/"}],"tags":[]}],"categories":[{"name":"c++","slug":"c","permalink":"https://marblemm.github.io/categories/c/"},{"name":"多线程","slug":"多线程","permalink":"https://marblemm.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"c++面试","slug":"c-面试","permalink":"https://marblemm.github.io/categories/c-%E9%9D%A2%E8%AF%95/"},{"name":"书籍","slug":"书籍","permalink":"https://marblemm.github.io/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"git","slug":"git","permalink":"https://marblemm.github.io/categories/git/"}],"tags":[]}